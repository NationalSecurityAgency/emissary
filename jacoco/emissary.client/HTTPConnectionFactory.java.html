<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HTTPConnectionFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.client</a> &gt; <span class="el_source">HTTPConnectionFactory.java</span></div><h1>HTTPConnectionFactory.java</h1><pre class="source lang-java linenums">package emissary.client;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.util.PkiUtil;

import com.google.common.annotations.VisibleForTesting;
import jakarta.annotation.Nullable;
import org.apache.hc.client5.http.impl.DefaultClientConnectionReuseStrategy;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;
import org.apache.hc.client5.http.socket.ConnectionSocketFactory;
import org.apache.hc.client5.http.socket.PlainConnectionSocketFactory;
import org.apache.hc.client5.http.ssl.DefaultHostnameVerifier;
import org.apache.hc.client5.http.ssl.NoopHostnameVerifier;
import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;
import org.apache.hc.core5.http.ConnectionReuseStrategy;
import org.apache.hc.core5.http.config.Registry;
import org.apache.hc.core5.http.config.RegistryBuilder;
import org.apache.log4j.Logger;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

/**
 * Emissary HTTP Connection Factory. This is a singleton class that allows for the central configuration of an Apache
 * HTTP Client Connection manager and also provides a method for building default HTTP Clients. This object can be
 * configured by providing an HTTPConnectionFactory.cfg with the following:&lt;br&gt;
 *
 * &lt;pre&gt;
 * // Standard SSL Properties
 * javax.net.ssl.trustStore = &quot;[Path to trust store]&quot;
 * javax.net.ssl.trustStoreType = &quot;[Trust Store type, defaults to JKS]&quot;
 * javax.net.ssl.trustStorePassword = &quot;[Trust store password OR path to file, see below]&quot;
 * javax.net.ssl.keyStore = &quot;[Path to key store]&quot;
 * javax.net.ssl.keyStoreType = &quot;[Key Store type, defaults to JKS]&quot;
 * javax.net.ssl.keyStorePassword = &quot;[Key store password OR path to file, see below]&quot;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Password configs: For the key or trust store options, if the values are prepended with &quot;file://&quot;, this class will
 * attempt to load the password from the file on the path. This is intended to be a single line text file. This is
 * provided to allow for passwords to be placed in limited access files and directories and to eliminate the need to
 * pass these options in JVM System properties which are easily found.
 */
public class HTTPConnectionFactory {

    static final String CFG_TRUST_STORE = &quot;javax.net.ssl.trustStore&quot;;
    static final String CFG_TRUST_STORE_TYPE = &quot;javax.net.ssl.trustStoreType&quot;;
    static final String CFG_TRUST_STORE_PW = &quot;javax.net.ssl.trustStorePassword&quot;;
    static final String CFG_KEY_STORE = &quot;javax.net.ssl.keyStore&quot;;
    static final String CFG_KEY_STORE_TYPE = &quot;javax.net.ssl.keyStoreType&quot;;
    static final String CFG_KEY_STORE_PW = &quot;javax.net.ssl.keyStorePassword&quot;;
    static final String CFG_HTTP_KEEPALIVE = &quot;http.keepAlive&quot;;
    static final String CFG_HTTP_MAXCONNS = &quot;http.maxConnections&quot;;
    static final String CFG_HTTP_AGENT = &quot;http.agent&quot;;
    static final String CFG_NOOP_VERIFIER = &quot;https.useNoopHostnameVerifier&quot;;
    static final String CFG_SSLCONTEXT_TYPE = &quot;emissary.sslcontext.type&quot;;
    static final String DEFAULT_HTTP_AGENT = &quot;emissary&quot;;
    static final int DFLT_MAXCONNS = 200;
    static final boolean DFLT_KEEPALIVE = true;
    static final String DFLT_STORE_TYPE = &quot;JKS&quot;;
    static final String DFLT_CONTEXT_TYPE = &quot;TLS&quot;;
    // meaningful constants
    private static final String HTTP = &quot;http&quot;;
    private static final String HTTPS = &quot;https&quot;;

<span class="fc" id="L74">    private static final Logger log = Logger.getLogger(HTTPConnectionFactory.class);</span>

    // singleton
<span class="fc" id="L77">    private static final HTTPConnectionFactory FACTORY = new HTTPConnectionFactory();</span>

    final PoolingHttpClientConnectionManager connMan;

<span class="fc" id="L81">    private ConnectionReuseStrategy connReuseStrategy = DefaultClientConnectionReuseStrategy.INSTANCE;</span>

<span class="fc" id="L83">    int maxConns = DFLT_MAXCONNS;</span>

<span class="fc" id="L85">    String userAgent = DEFAULT_HTTP_AGENT;</span>

    private HTTPConnectionFactory() {
<span class="fc" id="L88">        this(null);</span>
<span class="fc" id="L89">    }</span>

    @VisibleForTesting
<span class="fc" id="L92">    HTTPConnectionFactory(@Nullable final Configurator config) {</span>
<span class="fc" id="L93">        Registry&lt;ConnectionSocketFactory&gt; registry = null;</span>
        try {
<span class="fc bfc" id="L95" title="All 2 branches covered.">            final Configurator cfg = config == null ? ConfigUtil.getConfigInfo(HTTPConnectionFactory.class) : config;</span>
            // if someone doesn't want keep alives...
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (!cfg.findBooleanEntry(CFG_HTTP_KEEPALIVE, DFLT_KEEPALIVE)) {</span>
<span class="nc" id="L98">                this.connReuseStrategy = (httpRequest, httpResponse, httpContext) -&gt; false;</span>
            }
<span class="fc" id="L100">            this.maxConns = cfg.findIntEntry(CFG_HTTP_MAXCONNS, DFLT_MAXCONNS);</span>
<span class="fc" id="L101">            this.userAgent = cfg.findStringEntry(CFG_HTTP_AGENT, DEFAULT_HTTP_AGENT);</span>
<span class="fc" id="L102">            final SSLContext sslContext = build(cfg);</span>
            // mainly for using in test environments where cert name may not match host name
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">            final HostnameVerifier v = cfg.findBooleanEntry(CFG_NOOP_VERIFIER, false) ? new NoopHostnameVerifier() : new DefaultHostnameVerifier();</span>
            registry =
<span class="fc" id="L106">                    RegistryBuilder.&lt;ConnectionSocketFactory&gt;create().register(HTTP, PlainConnectionSocketFactory.getSocketFactory())</span>
<span class="fc" id="L107">                            .register(HTTPS, new SSLConnectionSocketFactory(sslContext, v)).build();</span>
<span class="nc" id="L108">        } catch (IOException | GeneralSecurityException ex) {</span>
<span class="nc" id="L109">            log.error(&quot;Error configuring HTTPConnectionFactory. The connection factory will use HTTP Client default settings&quot;, ex);</span>
<span class="fc" id="L110">        }</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (registry == null) {</span>
<span class="nc" id="L112">            this.connMan = new PoolingHttpClientConnectionManager();</span>
        } else {
<span class="fc" id="L114">            this.connMan = new PoolingHttpClientConnectionManager(registry);</span>
        }

<span class="fc" id="L117">        this.connMan.setMaxTotal(this.maxConns);</span>
<span class="fc" id="L118">    }</span>

    /**
     * This method will attempt to configure an SSLSocketFactory using configuration parameters from the
     * HTTPConnectionFactory.cfg.
     *
     * @param cfg The configurator.
     * @return the SSLContext
     * @throws IOException If there is some I/O problem.
     * @throws GeneralSecurityException If there is some security problem.
     */
    SSLContext build(final Configurator cfg) throws IOException, GeneralSecurityException {
<span class="fc" id="L130">        final char[] kpChar = PkiUtil.loadPassword(cfg.findStringEntry(CFG_KEY_STORE_PW));</span>
<span class="fc" id="L131">        final char[] tsChar = PkiUtil.loadPassword(cfg.findStringEntry(CFG_TRUST_STORE_PW));</span>

<span class="fc" id="L133">        final KeyStore keyStore =</span>
<span class="fc" id="L134">                PkiUtil.buildStore(cfg.findStringEntry(CFG_KEY_STORE), kpChar, cfg.findStringEntry(CFG_KEY_STORE_TYPE, DFLT_STORE_TYPE));</span>
<span class="fc" id="L135">        final KeyStore trustStore =</span>
<span class="fc" id="L136">                PkiUtil.buildStore(cfg.findStringEntry(CFG_TRUST_STORE), tsChar, cfg.findStringEntry(CFG_TRUST_STORE_TYPE, DFLT_STORE_TYPE));</span>
<span class="pc bpc" id="L137" title="1 of 4 branches missed.">        if ((trustStore == null) &amp;&amp; (keyStore == null)) {</span>
<span class="fc" id="L138">            log.debug(&quot;Trust Store and Key Store are null. Using JDK default SSLContext&quot;);</span>
<span class="fc" id="L139">            return SSLContext.getDefault();</span>
        }

<span class="fc" id="L142">        final TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="fc" id="L143">        tmf.init(trustStore);</span>

<span class="fc" id="L145">        final KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="fc" id="L146">        kmf.init(keyStore, kpChar);</span>

<span class="fc" id="L148">        final SSLContext sc = SSLContext.getInstance(cfg.findStringEntry(CFG_SSLCONTEXT_TYPE, DFLT_CONTEXT_TYPE));</span>
<span class="fc" id="L149">        sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());</span>

<span class="fc" id="L151">        return sc;</span>
    }


    /**
     * Return the configured connection manager with TLS SSL if configured.
     *
     * @return the connection manager
     */
    public PoolingHttpClientConnectionManager getDefaultConnectionManager() {
<span class="fc" id="L161">        return this.connMan;</span>
    }

    /**
     * Returns a CloseableHttpClient using the configuration options of the factory singleton. Detailed information:
     * &lt;ul&gt;
     * &lt;li&gt;The connection manager will be set
     * &lt;li&gt;The Client will have the connection manager marked as shared to preserve cached connections
     * &lt;li&gt;The Client will use the configured reuse strategy (HTTP Keep Alive)
     * &lt;/ul&gt;
     *
     * @return a CloseableHttpClient
     */
    public CloseableHttpClient buildDefaultClient() {
<span class="nc" id="L175">        return HttpClientBuilder.create().setConnectionManager(this.connMan).setConnectionManagerShared(true).setUserAgent(this.userAgent)</span>
<span class="nc" id="L176">                .setConnectionReuseStrategy(this.connReuseStrategy).build();</span>
    }

    /**
     * Returns the Factory
     *
     * @return the connection factory
     */
    public static HTTPConnectionFactory getFactory() {
<span class="fc" id="L185">        return FACTORY;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>