<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseDataObject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.core</a> &gt; <span class="el_source">BaseDataObject.java</span></div><h1>BaseDataObject.java</h1><pre class="source lang-java linenums">package emissary.core;

import emissary.core.channels.SeekableByteChannelFactory;
import emissary.core.channels.SeekableByteChannelHelper;
import emissary.directory.DirectoryEntry;
import emissary.pickup.Priority;
import emissary.util.ByteUtil;
import emissary.util.PayloadUtil;

import com.google.common.collect.LinkedListMultimap;
import jakarta.annotation.Nullable;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.SeekableByteChannel;
import java.rmi.Remote;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.UUID;

/**
 * Class to hold data, header, footer, and attributes
 */
public class BaseDataObject implements Serializable, Cloneable, Remote, IBaseDataObject {
<span class="fc" id="L44">    protected static final Logger logger = LoggerFactory.getLogger(BaseDataObject.class);</span>

    /* Used to limit the size of a returned byte array to avoid certain edge case scenarios */
    public static final int MAX_BYTE_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /* Including this here make serialization of this object faster. */
    private static final long serialVersionUID = 7362181964652092657L;

    /* Actual data - migrate away from this towards byte channels. */
    @Nullable
    protected byte[] theData;

    /**
     * Original name of the input data. Can only be set in the constructor of the DataObject. returned via the
     * {@link #getFilename()} method. Also used in constructing the {@link #shortName()} of the document.
     */
    protected String theFileName;

    /**
     * Terminal portion of theFileName
     */
    protected String shortName;

    /**
     * The internal identifier, generated for each constructed object
     */
<span class="fc" id="L70">    protected UUID internalId = UUID.randomUUID();</span>

    /**
     * The currentForm is a stack of the itinerary items. The contents of the list are {@link String} and map to the
     * dataType portion of the keys in the emissary.DirectoryPlace.
     */
<span class="fc" id="L76">    protected List&lt;String&gt; currentForm = new ArrayList&lt;&gt;();</span>

    /**
     * History of processing errors. Lines of text are accumulated from String and returned in-toto as a String.
     */
    protected StringBuilder procError;

    /**
     * A travelogue built up as the agent moves about. Appended to by the agent as it goes from place to place.
     */
<span class="fc" id="L86">    protected TransformHistory history = new TransformHistory();</span>

    /**
     * The last determined language(characterset) of the data.
     */
<span class="fc" id="L91">    @Nullable</span>
    protected String fontEncoding = null;

    /**
     * Dynamic facets or metadata attributes of the data
     */
<span class="fc" id="L97">    protected LinkedListMultimap&lt;String, Object&gt; parameters = LinkedListMultimap.create(100);</span>

    /**
     * If this file caused other agents to be sprouted, indicate how many
     */
<span class="fc" id="L102">    protected int numChildren = 0;</span>

    /**
     * If this file has siblings that were sprouted at the same time, this will indicate how many total siblings there are.
     * This can be used to navigate among siblings without needing to refer to the parent.
     */
<span class="fc" id="L108">    protected int numSiblings = 0;</span>

    /**
     * What child is this in the family order
     */
<span class="fc" id="L113">    protected int birthOrder = 0;</span>

    /**
     * Hash of alternate views of the data {@link String} current form is the key, byte[] is the value
     */
<span class="fc" id="L118">    protected Map&lt;String, byte[]&gt; multipartAlternative = new TreeMap&lt;&gt;();</span>

    /**
     * Any header that goes along with the data
     */
<span class="fc" id="L123">    @Nullable</span>
    protected byte[] header = null;

    /**
     * Any footer that goes along with the data
     */
<span class="fc" id="L129">    @Nullable</span>
    protected byte[] footer = null;

    /**
     * If the header has some encoding scheme record it
     */
<span class="fc" id="L135">    @Nullable</span>
    protected String headerEncoding = null;

    /**
     * Record the classification scheme for the document
     */
<span class="fc" id="L141">    @Nullable</span>
    protected String classification = null;

    /**
     * Keep track of if and how the document is broken so we can report on it later
     */
<span class="fc" id="L147">    @Nullable</span>
    protected StringBuilder brokenDocument = null;

    // Filetypes that we think are equivalent to no file type at all
<span class="fc" id="L151">    protected String[] emptyFileTypes = {Form.UNKNOWN};</span>

    /**
     * The integer priority of the data object. A lower number is higher priority.
     */
<span class="fc" id="L156">    protected int priority = Priority.DEFAULT;</span>

    /**
     * The timestamp for when the BaseDataObject was created. Used in data provenance tracking.
     */
    protected Instant creationTimestamp;

    /**
     * The extracted records, if any
     */
    @Nullable
    protected List&lt;IBaseDataObject&gt; extractedRecords;

    /**
     * Check to see if this tree is able to be written out.
     */
<span class="fc" id="L172">    protected boolean outputable = true;</span>

    /**
     * The unique identifier of this object
     */
    protected String id;

    /**
     * The identifier of the {@link emissary.pickup.WorkBundle}
     */
    protected String workBundleId;

    /**
     * The identifier used to track the object through the system
     */
    protected String transactionId;

    /**
     * A factory to create channels for the referenced data.
     */
    @Nullable
    protected SeekableByteChannelFactory seekableByteChannelFactory;

    @Nullable
    protected final IBaseDataObject tld;

<span class="fc" id="L198">    protected enum DataState {</span>
<span class="fc" id="L199">        NO_DATA, CHANNEL_ONLY, BYTE_ARRAY_ONLY, BYTE_ARRAY_AND_CHANNEL</span>
    }

    protected static final String INVALID_STATE_MSG = &quot;Can't have both theData and seekableByteChannelFactory set. Object is %s&quot;;

    /**
     * &lt;p&gt;
     * Determine what state we're in with respect to the byte[] of data vs a channel.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Not exposed publicly as consumers should be moving to channels, meaning ultimately the states will be simply either a
     * channel factory exists or does not exist.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Consumers should not modify their behaviour based on the state of the BDO, if they're being modified to handle
     * channels, they should only handle channels, not both channels and byte[].
     * &lt;/p&gt;
     * 
     * @return the {@link DataState} of this BDO
     */
    protected DataState getDataState() {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (theData == null) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (seekableByteChannelFactory == null) {</span>
<span class="fc" id="L224">                return DataState.NO_DATA;</span>
            } else {
<span class="fc" id="L226">                return DataState.CHANNEL_ONLY;</span>
            }
        } else {
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (seekableByteChannelFactory == null) {</span>
<span class="fc" id="L230">                return DataState.BYTE_ARRAY_ONLY;</span>
            } else {
<span class="fc" id="L232">                return DataState.BYTE_ARRAY_AND_CHANNEL;</span>
            }
        }
    }

    /**
     * Create an empty BaseDataObject.
     */
<span class="fc" id="L240">    public BaseDataObject() {</span>
<span class="fc" id="L241">        this.theData = null;</span>
<span class="fc" id="L242">        setCreationTimestamp(Instant.now());</span>
<span class="fc" id="L243">        tld = null;</span>
<span class="fc" id="L244">    }</span>

    /**
     * Create a new BaseDataObject with byte array and name passed in. WARNING: this implementation uses the passed in array
     * directly, no copy is made so the caller should not reuse the array.
     *
     * @param newData the bytes to hold
     * @param name the name of the data item
     */
<span class="fc" id="L253">    public BaseDataObject(final byte[] newData, final String name) {</span>
<span class="fc" id="L254">        setData(newData);</span>
<span class="fc" id="L255">        setFilename(name);</span>
<span class="fc" id="L256">        setCreationTimestamp(Instant.now());</span>
<span class="fc" id="L257">        tld = null;</span>
<span class="fc" id="L258">    }</span>

    /**
     * Create a new BaseDataObject with byte array, name, and initial form WARNING: this implementation uses the passed in
     * array directly, no copy is made so the caller should not reuse the array.
     *
     * @param newData the bytes to hold
     * @param name the name of the data item
     * @param form the initial form of the data
     */
    public BaseDataObject(final byte[] newData, final String name, @Nullable final String form) {
<span class="fc" id="L269">        this(newData, name);</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (form != null) {</span>
<span class="fc" id="L271">            pushCurrentForm(form);</span>
        }
<span class="fc" id="L273">    }</span>

    public BaseDataObject(final byte[] newData, final String name, final String form, @Nullable final String fileType) {
<span class="fc" id="L276">        this(newData, name, form);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        if (fileType != null) {</span>
<span class="fc" id="L278">            this.setFileType(fileType);</span>
        }
<span class="fc" id="L280">    }</span>

<span class="fc" id="L282">    public BaseDataObject(final byte[] newData, final String name, @Nullable final String form, IBaseDataObject tld) {</span>
<span class="fc" id="L283">        setData(newData);</span>
<span class="fc" id="L284">        setFilename(name);</span>
<span class="fc" id="L285">        setCreationTimestamp(Instant.now());</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (form != null) {</span>
<span class="fc" id="L287">            pushCurrentForm(form);</span>
        }
<span class="fc" id="L289">        this.tld = tld;</span>
<span class="fc" id="L290">    }</span>

    public BaseDataObject(final byte[] newData, final String name, @Nullable final String form, @Nullable final String fileType,
            IBaseDataObject tld) {
<span class="fc" id="L294">        this(newData, name, form, tld);</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (fileType != null) {</span>
<span class="fc" id="L296">            this.setFileType(fileType);</span>
        }
<span class="fc" id="L298">    }</span>

    /**
     * Set the header byte array WARNING: this implementation uses the passed in array directly, no copy is made so the
     * caller should not reuse the array.
     *
     * @param header the byte array of header data
     */
    @Override
    public void setHeader(final byte[] header) {
<span class="fc" id="L308">        this.header = header;</span>
<span class="fc" id="L309">    }</span>

    /**
     * Get the value of headerEncoding. Tells how to interpret the header information.
     *
     * @return Value of headerEncoding.
     */
    @Override
    public String getHeaderEncoding() {
<span class="fc" id="L318">        return this.headerEncoding;</span>
    }

    /**
     * Set the value of headerEncoding for proper interpretation and processing later
     *
     * @param v Value to assign to headerEncoding.
     */
    @Override
    public void setHeaderEncoding(final String v) {
<span class="fc" id="L328">        this.headerEncoding = v;</span>
<span class="fc" id="L329">    }</span>

    /**
     * Set the footer byte array WARNING: this implementation uses the passed in array directly, no copy is made so the
     * caller should not reuse the array.
     *
     * @param footer byte array of footer data
     */
    @Override
    public void setFooter(final byte[] footer) {
<span class="fc" id="L339">        this.footer = footer;</span>
<span class="fc" id="L340">    }</span>

    /**
     * Set the filename
     *
     * @param f the new name of the data including path
     */
    @Override
    public void setFilename(final String f) {
<span class="fc" id="L349">        this.theFileName = f;</span>
<span class="fc" id="L350">        this.shortName = makeShortName();</span>
<span class="fc" id="L351">    }</span>

    /**
     * Set the byte channel factory using whichever implementation is providing access to the data.
     * 
     * Setting this will null out {@link #theData}
     */
    @Override
    public void setChannelFactory(final SeekableByteChannelFactory sbcf) {
<span class="fc" id="L360">        Validate.notNull(sbcf, &quot;Required: SeekableByteChannelFactory not null&quot;);</span>
<span class="fc" id="L361">        this.theData = null;</span>
<span class="fc" id="L362">        this.seekableByteChannelFactory = sbcf;</span>
<span class="fc" id="L363">    }</span>

    /**
     * Returns the seekable byte channel factory containing a reference to the data, or wraps the in-memory data on the BDO
     * in a new factory.
     * 
     * @return the factory containing the data reference or the data wrapped in a new factory
     */
    @Nullable
    @Override
    @SuppressWarnings(&quot;UnnecessaryDefaultInEnumSwitch&quot;)
    public SeekableByteChannelFactory getChannelFactory() {
<span class="fc bfc" id="L375" title="All 4 branches covered.">        switch (getDataState()) {</span>
            case BYTE_ARRAY_AND_CHANNEL:
<span class="fc" id="L377">                throw new IllegalStateException(String.format(INVALID_STATE_MSG, shortName()));</span>
            case CHANNEL_ONLY:
<span class="fc" id="L379">                return seekableByteChannelFactory;</span>
            case BYTE_ARRAY_ONLY:
<span class="fc" id="L381">                return SeekableByteChannelHelper.memory(this.theData);</span>
            case NO_DATA:
            default:
<span class="fc" id="L384">                return null;</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    @Nullable
    @Override
    public InputStream newInputStream() {
<span class="fc" id="L394">        final SeekableByteChannelFactory sbcf = getChannelFactory();</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">        return sbcf == null ? null : Channels.newInputStream(sbcf.create());</span>
    }

    /**
     * &lt;p&gt;
     * Return BaseDataObjects byte array OR as much as we can from the reference to the data up to MAX_BYTE_ARRAY_SIZE.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Data returned from a backing Channel will be truncated at {@link BaseDataObject#MAX_BYTE_ARRAY_SIZE}. Using
     * channel-related methods is now preferred to allow handling of larger objects
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * &lt;b&gt;WARNING&lt;/b&gt;: There is no way for the caller to know whether the data being returned is the direct array held in
     * memory, or a copy of the data from a byte channel factory, so the returned byte array should be treated as live and
     * not be modified.
     * &lt;/p&gt;
     * 
     * @see #getChannelFactory()
     * @return the data as a byte array
     */
    @Nullable
    @Override
    @SuppressWarnings(&quot;UnnecessaryDefaultInEnumSwitch&quot;)
    public byte[] data() {
<span class="fc bfc" id="L422" title="All 4 branches covered.">        switch (getDataState()) {</span>
            case BYTE_ARRAY_AND_CHANNEL:
<span class="fc" id="L424">                throw new IllegalStateException(String.format(INVALID_STATE_MSG, shortName()));</span>
            case BYTE_ARRAY_ONLY:
<span class="fc" id="L426">                return theData;</span>
            case CHANNEL_ONLY:
                // Max size here is slightly less than the true max size to avoid memory issues
<span class="fc" id="L429">                return SeekableByteChannelHelper.getByteArrayFromBdo(this, MAX_BYTE_ARRAY_SIZE);</span>
            case NO_DATA:
            default:
<span class="fc" id="L432">                return null; // NOSONAR maintains backwards compatibility</span>
        }
    }

    /**
     * @see #setData(byte[], int, int)
     */
    @Override
    public void setData(@Nullable final byte[] newData) {
<span class="fc" id="L441">        this.seekableByteChannelFactory = null;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">        this.theData = newData == null ? new byte[0] : newData;</span>
<span class="fc" id="L443">    }</span>

    /**
     * &lt;p&gt;
     * Set new data on the BDO, using a range of the provided byte array. This will remove the reference to any byte channel
     * factory that backs this BDO so be careful!
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Limited in size to 2^31. Use channel-based methods for larger data.
     * &lt;/p&gt;
     * 
     * @param newData containing the source of the new data
     * @param offset where to start copying from
     * @param length how much to copy
     * @see #setChannelFactory(SeekableByteChannelFactory)
     */
    @Override
    public void setData(@Nullable final byte[] newData, final int offset, final int length) {
<span class="fc" id="L462">        this.seekableByteChannelFactory = null;</span>
<span class="fc bfc" id="L463" title="All 4 branches covered.">        if (length &lt;= 0 || newData == null) {</span>
<span class="fc" id="L464">            this.theData = new byte[0];</span>
        } else {
<span class="fc" id="L466">            this.theData = new byte[length];</span>
<span class="fc" id="L467">            System.arraycopy(newData, offset, this.theData, 0, length);</span>
        }
<span class="fc" id="L469">    }</span>

    /**
     * Checks if the data is defined with a non-zero length.
     * 
     * @return if data is undefined or zero length.
     */
    @Override
    public boolean hasContent() throws IOException {
<span class="fc bfc" id="L478" title="All 2 branches covered.">        return getChannelSize() &gt; 0;</span>
    }

    /**
     * Convenience method to get the size of the channel or byte array providing access to the data.
     * 
     * @return the channel size
     */
    @Override
    @SuppressWarnings(&quot;UnnecessaryDefaultInEnumSwitch&quot;)
    public long getChannelSize() throws IOException {
<span class="fc bfc" id="L489" title="All 4 branches covered.">        switch (getDataState()) {</span>
            case BYTE_ARRAY_AND_CHANNEL:
<span class="fc" id="L491">                throw new IllegalStateException(String.format(INVALID_STATE_MSG, shortName()));</span>
            case BYTE_ARRAY_ONLY:
<span class="fc" id="L493">                return ArrayUtils.getLength(theData);</span>
            case CHANNEL_ONLY:
<span class="fc" id="L495">                try (SeekableByteChannel sbc = this.seekableByteChannelFactory.create()) {</span>
<span class="fc" id="L496">                    return sbc.size();</span>
                }
            case NO_DATA:
            default:
<span class="fc" id="L500">                return 0;</span>
        }
    }

    /**
     * Fetch the size of the payload. Prefer to use: {@link #getChannelSize}
     * 
     * @return the length of theData, or the size of the seekable byte channel up to
     *         {@link BaseDataObject#MAX_BYTE_ARRAY_SIZE}.
     */
    @Override
    @SuppressWarnings(&quot;UnnecessaryDefaultInEnumSwitch&quot;)
    public int dataLength() {
<span class="fc bfc" id="L513" title="All 4 branches covered.">        switch (getDataState()) {</span>
            case BYTE_ARRAY_AND_CHANNEL:
<span class="fc" id="L515">                throw new IllegalStateException(String.format(INVALID_STATE_MSG, shortName()));</span>
            case BYTE_ARRAY_ONLY:
<span class="fc" id="L517">                return ArrayUtils.getLength(theData);</span>
            case CHANNEL_ONLY:
                try {
<span class="fc" id="L520">                    return (int) Math.min(getChannelSize(), MAX_BYTE_ARRAY_SIZE);</span>
<span class="fc" id="L521">                } catch (final IOException ioe) {</span>
<span class="fc" id="L522">                    logger.error(&quot;Couldn't get size of channel on object {}&quot;, shortName(), ioe);</span>
<span class="fc" id="L523">                    return 0;</span>
                }
            case NO_DATA:
            default:
<span class="fc" id="L527">                return 0;</span>
        }
    }

    @Override
    public String shortName() {
<span class="fc" id="L533">        return this.shortName;</span>
    }

    /**
     * Construct the shortname
     */
    private String makeShortName() {
        /*
         * using the file object works for most cases. It fails on the unix side if it is given a valid Windows path.
         */
        // File file = new File( theFileName );
        // return file.getName();
        // so..... we'll have to perform the check ourselves ARRRRRRRRRGH!!!!
<span class="fc" id="L546">        final int unixPathIndex = this.theFileName.lastIndexOf(&quot;/&quot;);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (unixPathIndex &gt;= 0) {</span>
<span class="fc" id="L548">            return this.theFileName.substring(unixPathIndex + 1);</span>
        }
        // check for windows path
<span class="fc" id="L551">        final int windowsPathIndex = this.theFileName.lastIndexOf(&quot;\\&quot;);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        if (windowsPathIndex &gt;= 0) {</span>
<span class="fc" id="L553">            return this.theFileName.substring(windowsPathIndex + 1);</span>
        }

<span class="fc" id="L556">        return this.theFileName;</span>
    }

    @Override
    public String getFilename() {
<span class="fc" id="L561">        return this.theFileName;</span>
    }

    @Override
    public String currentForm() {
<span class="fc" id="L566">        return currentFormAt(0);</span>
    }

    @Override
    public String currentFormAt(final int i) {
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (i &lt; this.currentForm.size()) {</span>
<span class="fc" id="L572">            return this.currentForm.get(i);</span>
        }
<span class="fc" id="L574">        return &quot;&quot;;</span>
    }

    @Override
    public int searchCurrentForm(final String value) {
<span class="fc" id="L579">        return this.currentForm.indexOf(value);</span>
    }

    @Nullable
    @Override
    public String searchCurrentForm(final Collection&lt;String&gt; values) {
<span class="fc bfc" id="L585" title="All 2 branches covered.">        for (final String value : values) {</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">            if (this.currentForm.contains(value)) {</span>
<span class="fc" id="L587">                return value;</span>
            }
<span class="fc" id="L589">        }</span>
<span class="fc" id="L590">        return null;</span>
    }

    @Override
    public int currentFormSize() {
<span class="fc" id="L595">        return this.currentForm.size();</span>
    }

    @Override
    public void replaceCurrentForm(@Nullable final String form) {
<span class="fc" id="L600">        this.currentForm.clear();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (form != null) {</span>
<span class="fc" id="L602">            pushCurrentForm(form);</span>
        }
<span class="fc" id="L604">    }</span>

    /**
     * Remove a form from the head of the list
     *
     * @return The value that was removed, or {@code null} if the list was empty.
     */
    @Nullable
    @Override
    public String popCurrentForm() {
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (this.currentForm.isEmpty()) {</span>
<span class="fc" id="L615">            return null;</span>
        } else {
<span class="fc" id="L617">            return this.currentForm.remove(0);</span>
        }
    }

    @Override
    public int deleteCurrentForm(final String form) {
<span class="fc" id="L623">        int count = 0;</span>

<span class="pc bpc" id="L625" title="1 of 4 branches missed.">        if (this.currentForm == null || this.currentForm.isEmpty()) {</span>
<span class="fc" id="L626">            return count;</span>
        }

        // Remove all matching
<span class="fc bfc" id="L630" title="All 2 branches covered.">        for (final Iterator&lt;String&gt; i = this.currentForm.iterator(); i.hasNext();) {</span>
<span class="fc" id="L631">            final String val = i.next();</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">            if (val.equals(form)) {</span>
<span class="fc" id="L633">                i.remove();</span>
<span class="fc" id="L634">                count++;</span>
            }
<span class="fc" id="L636">        }</span>
<span class="fc" id="L637">        return count;</span>
    }

    @Override
    public int deleteCurrentFormAt(final int i) {
        // Make sure its a legal position.
<span class="fc bfc" id="L643" title="All 4 branches covered.">        if ((i &gt;= 0) &amp;&amp; (i &lt; this.currentForm.size())) {</span>
<span class="fc" id="L644">            this.currentForm.remove(i);</span>
        }
<span class="fc" id="L646">        return this.currentForm.size();</span>
    }

    @Override
    public int addCurrentFormAt(final int i, final String newForm) {
<span class="fc bfc" id="L651" title="All 2 branches covered.">        if (newForm == null) {</span>
<span class="fc" id="L652">            throw new IllegalArgumentException(&quot;caller attempted to add a null form value at position &quot; + i);</span>
        }

<span class="fc" id="L655">        checkForAndLogDuplicates(newForm, &quot;addCurrentFormAt&quot;);</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (i &lt; this.currentForm.size()) {</span>
<span class="fc" id="L657">            this.currentForm.add(i, newForm);</span>
        } else {
<span class="fc" id="L659">            this.currentForm.add(newForm);</span>
        }
<span class="fc" id="L661">        return this.currentForm.size();</span>
    }

    @Override
    public int enqueueCurrentForm(final String newForm) {
<span class="fc bfc" id="L666" title="All 2 branches covered.">        if (newForm == null) {</span>
<span class="fc" id="L667">            throw new IllegalArgumentException(&quot;caller attempted to enqueue a null form value&quot;);</span>
        }

<span class="fc" id="L670">        checkForAndLogDuplicates(newForm, &quot;enqueueCurrentForm&quot;);</span>
<span class="fc" id="L671">        this.currentForm.add(newForm);</span>
<span class="fc" id="L672">        return this.currentForm.size();</span>
    }

    @Override
    public int pushCurrentForm(final String newForm) {
<span class="fc bfc" id="L677" title="All 2 branches covered.">        if (newForm == null) {</span>
<span class="fc" id="L678">            throw new IllegalArgumentException(&quot;caller attempted to push a null form value&quot;);</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        } else if (!PayloadUtil.isValidForm(newForm)) {</span>
            // If there is a key separator in the form, then throw an error log as this will cause issues in routing
<span class="fc" id="L681">            logger.error(&quot;INVALID FORM: The form can only contain a-z, A-Z, 0-9, '-', '_', '()', '/', '+'. Given form: {}&quot;, newForm);</span>
        }

<span class="fc" id="L684">        checkForAndLogDuplicates(newForm, &quot;pushCurrentForm&quot;);</span>
<span class="fc" id="L685">        return addCurrentFormAt(0, newForm);</span>
    }

    @Override
    public void setCurrentForm(final String newForm) {
<span class="fc" id="L690">        setCurrentForm(newForm, false);</span>
<span class="fc" id="L691">    }</span>

    @Override
    public void setCurrentForm(final String newForm, final boolean clearAllForms) {
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (StringUtils.isBlank(newForm)) {</span>
<span class="fc" id="L696">            throw new IllegalArgumentException(&quot;caller attempted to set the current form to a null value&quot;);</span>
        }

<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (clearAllForms) {</span>
<span class="fc" id="L700">            replaceCurrentForm(newForm);</span>
        } else {
<span class="fc" id="L702">            popCurrentForm();</span>
<span class="fc" id="L703">            pushCurrentForm(newForm);</span>
        }
<span class="fc" id="L705">    }</span>


    @Override
    public List&lt;String&gt; getAllCurrentForms() {
<span class="fc" id="L710">        return new ArrayList&lt;&gt;(this.currentForm);</span>
    }

    @Override
    public void pullFormToTop(final String curForm) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">        if (this.currentForm.size() &gt; 1) {</span>
            // Delete it
<span class="fc" id="L717">            final int count = deleteCurrentForm(curForm);</span>

            // If deleted, add it back on top
<span class="fc bfc" id="L720" title="All 2 branches covered.">            if (count &gt; 0) {</span>
<span class="fc" id="L721">                this.currentForm.add(0, curForm);</span>
            }
        }
<span class="fc" id="L724">    }</span>

    private void checkForAndLogDuplicates(String newForm, String method) {
<span class="fc bfc" id="L727" title="All 2 branches covered.">        if (currentForm.contains(newForm)) {</span>
<span class="fc" id="L728">            logger.info(&quot;Duplicate form {} being added through BaseDataObject.{}&quot;, newForm, method);</span>
        }
<span class="fc" id="L730">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L734">        final StringBuilder myOutput = new StringBuilder();</span>
<span class="fc" id="L735">        final String ls = System.getProperty(&quot;line.separator&quot;);</span>

<span class="fc" id="L737">        myOutput.append(ls);</span>
<span class="fc" id="L738">        myOutput.append(&quot;   currentForms: &quot;).append(getAllCurrentForms()).append(ls);</span>
<span class="fc" id="L739">        myOutput.append(&quot;   &quot;).append(history);</span>

<span class="fc" id="L741">        return myOutput.toString();</span>
    }

    @Override
    public String printMeta() {
<span class="fc" id="L746">        return PayloadUtil.printFormattedMetadata(this);</span>
    }

    @Override
    public void addProcessingError(final String err) {
<span class="fc bfc" id="L751" title="All 2 branches covered.">        if (this.procError == null) {</span>
<span class="fc" id="L752">            this.procError = new StringBuilder();</span>
        }
<span class="fc" id="L754">        this.procError.append(err).append(&quot;\n&quot;);</span>
<span class="fc" id="L755">    }</span>

    @Override
    public String getProcessingError() {
<span class="fc" id="L759">        String s = null;</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if (this.procError != null) {</span>
<span class="fc" id="L761">            s = this.procError.toString();</span>
        }
<span class="fc" id="L763">        return s;</span>
    }

    @Override
    public TransformHistory getTransformHistory() {
<span class="fc" id="L768">        return new TransformHistory(history);</span>
    }

    @Override
    public List&lt;String&gt; transformHistory() {
<span class="fc" id="L773">        return transformHistory(false);</span>
    }

    @Override
    public List&lt;String&gt; transformHistory(boolean includeCoordinated) {
<span class="fc" id="L778">        return history.get(includeCoordinated);</span>
    }

    @Override
    public void clearTransformHistory() {
<span class="fc" id="L783">        this.history.clear();</span>
<span class="fc" id="L784">    }</span>

    @Override
    public void appendTransformHistory(final String key) {
<span class="fc" id="L788">        appendTransformHistory(key, false);</span>
<span class="fc" id="L789">    }</span>

    @Override
    public void appendTransformHistory(final String key, boolean coordinated) {
<span class="fc" id="L793">        this.history.append(key, coordinated);</span>
<span class="fc" id="L794">    }</span>

    @Override
    public void setHistory(TransformHistory newHistory) {
<span class="fc" id="L798">        this.history.set(newHistory);</span>
<span class="fc" id="L799">    }</span>

    @Override
    public String whereAmI() {
<span class="fc" id="L803">        String host = null;</span>
        try {
<span class="fc" id="L805">            host = InetAddress.getLocalHost().getCanonicalHostName();</span>
<span class="nc" id="L806">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L807">            host = &quot;FAILED&quot;;</span>
<span class="fc" id="L808">        }</span>
<span class="fc" id="L809">        return host;</span>
    }

    @Nullable
    @Override
    public DirectoryEntry getLastPlaceVisited() {
<span class="fc" id="L815">        TransformHistory.History entry = history.lastVisit();</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        return entry == null ? null : new DirectoryEntry(entry.getKey());</span>
    }

    @Nullable
    @Override
    public DirectoryEntry getPenultimatePlaceVisited() {
<span class="fc" id="L822">        TransformHistory.History entry = history.penultimateVisit();</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">        return entry == null ? null : new DirectoryEntry(entry.getKey());</span>
    }

    @Override
    public boolean hasVisited(final String pattern) {
<span class="fc" id="L828">        return history.hasVisited(pattern);</span>
    }

    @Override
    public boolean beforeStart() {
<span class="fc" id="L833">        return history.beforeStart();</span>
    }

    @Override
    public void clearParameters() {
<span class="fc" id="L838">        this.parameters.clear();</span>
<span class="fc" id="L839">    }</span>

    @Override
    public boolean hasParameter(final String key) {
<span class="fc" id="L843">        return this.parameters.containsKey(key);</span>
    }

    @Override
    public void setParameters(final Map&lt;? extends String, ? extends Object&gt; map) {
<span class="fc" id="L848">        this.parameters.clear();</span>
<span class="fc" id="L849">        putParameters(map);</span>
<span class="fc" id="L850">    }</span>

    @Override
    public void setParameter(final String key, final Object val) {
<span class="fc" id="L854">        deleteParameter(key);</span>
<span class="fc" id="L855">        putParameter(key, val);</span>
<span class="fc" id="L856">    }</span>

    @Override
    public void putParameter(final String key, final Object val) {
<span class="fc" id="L860">        this.parameters.removeAll(key);</span>

<span class="fc bfc" id="L862" title="All 2 branches covered.">        if (val instanceof Iterable) {</span>
<span class="fc" id="L863">            this.parameters.putAll(key, (Iterable&lt;?&gt;) val);</span>
        } else {
<span class="fc" id="L865">            this.parameters.put(key, val);</span>
        }
<span class="fc" id="L867">    }</span>

    /**
     * Put a collection of parameters into the metadata map, keeping both old and new values
     *
     * @param m the map of new parameters
     */
    @Override
    public void putParameters(final Map&lt;? extends String, ? extends Object&gt; m) {
<span class="fc" id="L876">        putParameters(m, MergePolicy.KEEP_ALL);</span>
<span class="fc" id="L877">    }</span>

    /**
     * Merge in new parameters using the specified policy to determine whether to keep all values, unique values, or prefer
     * existing values
     *
     * @param m map of new parameters
     * @param policy the merge policy
     */
    @Override
    public void putParameters(final Map&lt;? extends String, ? extends Object&gt; m, final MergePolicy policy) {
<span class="fc bfc" id="L888" title="All 2 branches covered.">        for (final Map.Entry&lt;? extends String, ? extends Object&gt; entry : m.entrySet()) {</span>
<span class="fc" id="L889">            final String name = entry.getKey();</span>

<span class="fc bfc" id="L891" title="All 4 branches covered.">            if ((policy == MergePolicy.KEEP_EXISTING) &amp;&amp; this.parameters.containsKey(name)) {</span>
<span class="fc" id="L892">                continue;</span>
            }

<span class="fc" id="L895">            final Object value = entry.getValue();</span>

<span class="fc bfc" id="L897" title="All 2 branches covered.">            if (policy == MergePolicy.DROP_EXISTING) {</span>
                // store the provided value for this key, discarding any previously-stored value
<span class="fc" id="L899">                setParameter(name, value);</span>
<span class="fc" id="L900">                continue;</span>
            }

<span class="fc bfc" id="L903" title="All 2 branches covered.">            if (value instanceof Iterable) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">                for (final Object v : (Iterable&lt;?&gt;) value) {</span>
<span class="fc bfc" id="L905" title="All 4 branches covered.">                    if (policy == MergePolicy.KEEP_ALL || policy == MergePolicy.KEEP_EXISTING) {</span>
<span class="fc" id="L906">                        this.parameters.put(name, v);</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">                    } else if (policy == MergePolicy.DISTINCT) {</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">                        if (!this.parameters.containsEntry(name, v)) {</span>
<span class="fc" id="L909">                            this.parameters.put(name, v);</span>
                        }
                    } else {
<span class="nc" id="L912">                        throw new IllegalStateException(&quot;Unhandled parameter merge policy &quot; + policy + &quot; for &quot; + name);</span>
                    }
<span class="fc" id="L914">                }</span>
            } else {
<span class="fc bfc" id="L916" title="All 4 branches covered.">                if (policy == MergePolicy.KEEP_ALL || policy == MergePolicy.KEEP_EXISTING) {</span>
<span class="fc" id="L917">                    this.parameters.put(name, value);</span>
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">                } else if (policy == MergePolicy.DISTINCT) {</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">                    if (!this.parameters.containsEntry(name, value)) {</span>
<span class="fc" id="L920">                        this.parameters.put(name, value);</span>
                    }
                } else {
<span class="nc" id="L923">                    throw new IllegalStateException(&quot;Unhandled parameter merge policy &quot; + policy + &quot; for &quot; + name);</span>
                }
            }
<span class="fc" id="L926">        }</span>
<span class="fc" id="L927">    }</span>


    /**
     * Put a collection of parameters into the metadata map, adding only distinct k/v pairs
     *
     * @param m the map of new parameters
     */
    @Override
    public void putUniqueParameters(final Map&lt;? extends String, ? extends Object&gt; m) {
<span class="fc" id="L937">        putParameters(m, MergePolicy.DISTINCT);</span>
<span class="fc" id="L938">    }</span>

    /**
     * Merge in parameters keeping existing keys unchanged
     *
     * @param m map of new parameters to consider
     */
    @Override
    public void mergeParameters(final Map&lt;? extends String, ? extends Object&gt; m) {
<span class="fc" id="L947">        putParameters(m, MergePolicy.KEEP_EXISTING);</span>
<span class="fc" id="L948">    }</span>

    @Nullable
    @Override
    public List&lt;Object&gt; getParameter(final String key) {
        // Try remapping
<span class="fc" id="L954">        List&lt;Object&gt; v = this.parameters.get(key);</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (CollectionUtils.isEmpty(v)) {</span>
<span class="fc" id="L956">            return null;</span>
        }
<span class="fc" id="L958">        return v;</span>
    }

    @Override
    public void appendParameter(final String key, final CharSequence value) {
<span class="fc" id="L963">        this.parameters.put(key, value);</span>
<span class="fc" id="L964">    }</span>

    @Override
    public void appendParameter(final String key, final Iterable&lt;? extends CharSequence&gt; values) {
<span class="fc" id="L968">        this.parameters.putAll(key, values);</span>
<span class="fc" id="L969">    }</span>

    /**
     * Append data to the specified metadata element if it doesn't already exist If you expect to append a lot if things
     * this way, this method might not have the performance characteristics that you expect. You can build a set and
     * externally and append the values after they are uniqued.
     *
     * @param key name of the metadata element
     * @param value the value to append
     * @return true if the item is added, false if it already exists
     */
    @Override
    public boolean appendUniqueParameter(final String key, final CharSequence value) {
<span class="fc bfc" id="L982" title="All 2 branches covered.">        if (this.parameters.containsEntry(key, value)) {</span>
<span class="fc" id="L983">            return false;</span>
        }

<span class="fc" id="L986">        this.parameters.put(key, value);</span>
<span class="fc" id="L987">        return true;</span>
    }

    @Nullable
    @Override
    public String getParameterAsString(final String key) {
<span class="fc" id="L993">        final var obj = getParameterAsStrings(key);</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (obj.size() &gt; 1) {</span>
<span class="fc" id="L995">            logger.warn(&quot;Multiple values for parameter, parameter:{}, number of values:{}&quot;, key, obj.size());</span>
<span class="fc" id="L996">            return getParameterAsConcatString(key);</span>
        }
<span class="fc" id="L998">        return obj.stream().findFirst().orElse(null);</span>
    }

    /**
     * Retrieve all the metadata elements of this object This method returns possibly mapped metadata element names
     *
     * @return map of metadata elements
     */
    @Override
    public Map&lt;String, Collection&lt;Object&gt;&gt; getParameters() {
<span class="fc" id="L1008">        return this.parameters.asMap();</span>
    }

    /**
     * Get a processed represenation of the parameters for external use
     */
    @Override
    public Map&lt;String, String&gt; getCookedParameters() {
<span class="fc" id="L1016">        final Map&lt;String, String&gt; ext = new TreeMap&lt;&gt;();</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        for (final String key : this.parameters.keySet()) {</span>
<span class="fc" id="L1018">            ext.put(key.toString(), getStringParameter(key));</span>
<span class="fc" id="L1019">        }</span>
<span class="fc" id="L1020">        return ext;</span>
    }

    @Override
    public Set&lt;String&gt; getParameterKeys() {
<span class="fc" id="L1025">        return this.parameters.keySet();</span>
    }

    @Override
    public List&lt;Object&gt; deleteParameter(final String key) {
<span class="fc" id="L1030">        return this.parameters.removeAll(key);</span>
    }

    @Override
    public void setNumChildren(final int num) {
<span class="fc" id="L1035">        this.numChildren = num;</span>
<span class="fc" id="L1036">    }</span>

    @Override
    public void setNumSiblings(final int num) {
<span class="fc" id="L1040">        this.numSiblings = num;</span>
<span class="fc" id="L1041">    }</span>

    @Override
    public void setBirthOrder(final int num) {
<span class="fc" id="L1045">        this.birthOrder = num;</span>
<span class="fc" id="L1046">    }</span>

    @Override
    public int getNumChildren() {
<span class="fc" id="L1050">        return this.numChildren;</span>
    }

    @Override
    public int getNumSiblings() {
<span class="fc" id="L1055">        return this.numSiblings;</span>
    }

    @Override
    public int getBirthOrder() {
<span class="fc" id="L1060">        return this.birthOrder;</span>
    }

    /**
     * Return a reference to the header byte array. WARNING: this implementation returns the actual array directly, no copy
     * is made so the caller must be aware that modifications to the returned array are live.
     *
     * @return byte array of header information or null if none
     */
    @Override
    public byte[] header() {
<span class="fc" id="L1071">        return this.header;</span>
    }

    @Override
    @Deprecated
    public ByteBuffer headerBuffer() {
<span class="fc" id="L1077">        return ByteBuffer.wrap(header());</span>
    }

    /**
     * Return a reference to the footer byte array. WARNING: this implementation returns the actual array directly, no copy
     * is made so the caller must be aware that modifications to the returned array are live.
     *
     * @return byte array of footer data or null if none
     */
    @Override
    public byte[] footer() {
<span class="fc" id="L1088">        return this.footer;</span>
    }


    @Override
    @Deprecated
    public ByteBuffer footerBuffer() {
<span class="fc" id="L1095">        return ByteBuffer.wrap(footer());</span>
    }

    @Override
    @Deprecated
    public ByteBuffer dataBuffer() {
<span class="fc" id="L1101">        return ByteBuffer.wrap(data());</span>
    }

    @Override
    public String getFontEncoding() {
<span class="fc" id="L1106">        return this.fontEncoding;</span>
    }

    @Override
    public void setFontEncoding(final String fe) {
<span class="fc" id="L1111">        this.fontEncoding = fe;</span>
<span class="fc" id="L1112">    }</span>

    private static final String FILETYPE = &quot;FILETYPE&quot;;

    /**
     * Put the FILETYPE parameter, null to clear
     *
     * @param v the value to store or null
     */
    @Override
    public void setFileType(@Nullable final String v) {
<span class="fc" id="L1123">        deleteParameter(FILETYPE);</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">        if (v != null) {</span>
<span class="fc" id="L1125">            setParameter(FILETYPE, v);</span>
        }
<span class="fc" id="L1127">    }</span>

    @Override
    @Deprecated
    public boolean setFileTypeIfEmpty(final String v, final String[] empties) {
<span class="fc bfc" id="L1132" title="All 2 branches covered.">        if (isFileTypeEmpty(empties)) {</span>
<span class="fc" id="L1133">            setFileType(v);</span>
<span class="fc" id="L1134">            return true;</span>
        }
<span class="fc" id="L1136">        return false;</span>
    }

    @Override
    public boolean setFileTypeIfEmpty(final String v) {
<span class="fc" id="L1141">        return setFileTypeIfEmpty(v, this.emptyFileTypes);</span>
    }

    @Override
    public boolean isFileTypeEmpty() {
<span class="fc" id="L1146">        return isFileTypeEmpty(this.emptyFileTypes);</span>
    }

    /**
     * Return true if the file type is null or in one of the specified set of empties
     *
     * @param empties a list of types that count as empty
     */
    protected boolean isFileTypeEmpty(@Nullable final String[] empties) {
<span class="fc" id="L1155">        final String s = getFileType();</span>

<span class="fc bfc" id="L1157" title="All 2 branches covered.">        if (StringUtils.isEmpty(s)) {</span>
<span class="fc" id="L1158">            return true;</span>
        }

<span class="fc bfc" id="L1161" title="All 2 branches covered.">        if (s.endsWith(Form.SUFFIXES_UNWRAPPED)) {</span>
<span class="fc" id="L1162">            return true;</span>
        }

<span class="pc bpc" id="L1165" title="1 of 4 branches missed.">        for (int i = 0; empties != null &amp;&amp; i &lt; empties.length; i++) {</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">            if (s.equals(empties[i])) {</span>
<span class="fc" id="L1167">                return true;</span>
            }
        }
<span class="fc" id="L1170">        return false;</span>
    }

    @Override
    public String getFileType() {
<span class="fc" id="L1175">        return getStringParameter(FILETYPE);</span>
    }

    @Override
    public int getNumAlternateViews() {
<span class="fc" id="L1180">        return this.multipartAlternative.size();</span>
    }

    /**
     * Return a specified multipart alternative view of the data WARNING: this implementation returns the actual array
     * directly, no copy is made so the caller must be aware that modifications to the returned array are live.
     *
     * @param s the name of the view to retrieve
     * @return byte array of alternate view data or null if none
     */
    @Override
    public byte[] getAlternateView(final String s) {
<span class="fc" id="L1192">        return this.multipartAlternative.get(s);</span>
    }

    @Override
    public void appendAlternateView(final String name, final byte[] data) {
<span class="fc" id="L1197">        appendAlternateView(name, data, 0, data.length);</span>
<span class="fc" id="L1198">    }</span>

    @Override
    public void appendAlternateView(final String name, final byte[] data, final int offset, final int length) {
<span class="fc" id="L1202">        final byte[] av = getAlternateView(name);</span>
<span class="fc bfc" id="L1203" title="All 2 branches covered.">        if (av != null) {</span>
<span class="fc" id="L1204">            addAlternateView(name, ByteUtil.glue(av, 0, av.length - 1, data, offset, offset + length - 1));</span>
        } else {
<span class="fc" id="L1206">            addAlternateView(name, data, offset, length);</span>
        }
<span class="fc" id="L1208">    }</span>

    /**
     * Return a specified multipart alternative view of the data in a buffer
     *
     * @param s the name of the view to retrieve
     * @return buffer of alternate view data or null if none
     */
    @Nullable
    @Override
    @Deprecated
    public ByteBuffer getAlternateViewBuffer(final String s) {
<span class="fc" id="L1220">        final byte[] viewdata = getAlternateView(s);</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">        if (viewdata == null) {</span>
<span class="fc" id="L1222">            return null;</span>
        }
<span class="fc" id="L1224">        return ByteBuffer.wrap(viewdata);</span>
    }

    /**
     * Add a multipart alternative view of the data WARNING: this implementation returns the actual array directly, no copy
     * is made so the caller must be aware that modifications to the returned array are live.
     *
     * @param name the name of the new view
     * @param data the byte array of data for the view
     */
    @Override
    public void addAlternateView(final String name, @Nullable final byte[] data) {
<span class="fc bfc" id="L1236" title="All 2 branches covered.">        if (data == null) {</span>
<span class="fc" id="L1237">            this.multipartAlternative.remove(name);</span>
        } else {
<span class="fc" id="L1239">            this.multipartAlternative.put(name, data);</span>
        }
<span class="fc" id="L1241">    }</span>

    @Override
    public void addAlternateView(final String name, @Nullable final byte[] data, final int offset, final int length) {
<span class="pc bpc" id="L1245" title="2 of 4 branches missed.">        if (data == null || length &lt;= 0) {</span>
<span class="nc" id="L1246">            this.multipartAlternative.remove(name);</span>
        } else {
<span class="fc" id="L1248">            final byte[] mpa = new byte[length];</span>
<span class="fc" id="L1249">            System.arraycopy(data, offset, mpa, 0, length);</span>
<span class="fc" id="L1250">            this.multipartAlternative.put(name, mpa);</span>
        }
<span class="fc" id="L1252">    }</span>

    /**
     * {@inheritDoc}
     *
     * @return an ordered set of alternate view names
     */
    @Override
    public Set&lt;String&gt; getAlternateViewNames() {
<span class="fc" id="L1261">        return new TreeSet&lt;&gt;(this.multipartAlternative.keySet());</span>
    }

    /**
     * Get the alternate view map. WARNING: this implementation returns the actual map directly, no copy is made so the
     * caller must be aware that modifications to the returned map are live.
     *
     * @return an map of alternate views ordered by name, key = String, value = byte[]
     */
    @Override
    public Map&lt;String, byte[]&gt; getAlternateViews() {
<span class="fc" id="L1272">        return this.multipartAlternative;</span>
    }

    @Override
    public boolean isBroken() {
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        return this.brokenDocument != null;</span>
    }

    @Override
    public void setBroken(@Nullable final String v) {
<span class="fc bfc" id="L1282" title="All 2 branches covered.">        if (v == null) {</span>
<span class="fc" id="L1283">            this.brokenDocument = null;</span>
<span class="fc" id="L1284">            return;</span>
        }

<span class="fc bfc" id="L1287" title="All 2 branches covered.">        if (this.brokenDocument == null) {</span>
<span class="fc" id="L1288">            this.brokenDocument = new StringBuilder();</span>
<span class="fc" id="L1289">            this.brokenDocument.append(v);</span>
        } else {
<span class="fc" id="L1291">            this.brokenDocument.append(&quot;, &quot;).append(v);</span>
        }
<span class="fc" id="L1293">    }</span>

    @Nullable
    @Override
    public String getBroken() {
<span class="fc bfc" id="L1298" title="All 2 branches covered.">        if (this.brokenDocument == null) {</span>
<span class="fc" id="L1299">            return null;</span>
        }
<span class="fc" id="L1301">        return this.brokenDocument.toString();</span>
    }

    @Override
    public void setClassification(final String classification) {
<span class="fc" id="L1306">        this.classification = classification;</span>
<span class="fc" id="L1307">    }</span>

    @Override
    public String getClassification() {
<span class="fc" id="L1311">        return this.classification;</span>
    }

    @Override
    public int getPriority() {
<span class="fc" id="L1316">        return this.priority;</span>
    }

    @Override
    public void setPriority(final int priority) {
<span class="fc" id="L1321">        this.priority = priority;</span>
<span class="fc" id="L1322">    }</span>

    /**
     * Clone this payload
     */
    @Deprecated
    @Override
    public IBaseDataObject clone() throws CloneNotSupportedException {
<span class="fc" id="L1330">        final BaseDataObject c = (BaseDataObject) super.clone();</span>
<span class="pc bpc" id="L1331" title="1 of 4 branches missed.">        if ((this.theData != null) &amp;&amp; (this.theData.length &gt; 0)) {</span>
<span class="fc" id="L1332">            c.setData(this.theData, 0, this.theData.length);</span>
        }

<span class="fc bfc" id="L1335" title="All 2 branches covered.">        if (this.seekableByteChannelFactory != null) {</span>
<span class="fc" id="L1336">            c.setChannelFactory(this.seekableByteChannelFactory);</span>
        }

<span class="fc" id="L1339">        c.currentForm = new ArrayList&lt;&gt;(this.currentForm);</span>
<span class="fc" id="L1340">        c.history = new TransformHistory(this.history);</span>
<span class="fc" id="L1341">        c.multipartAlternative = new HashMap&lt;&gt;(this.multipartAlternative);</span>
<span class="fc" id="L1342">        c.priority = this.priority;</span>
<span class="fc" id="L1343">        c.creationTimestamp = this.creationTimestamp;</span>

<span class="pc bpc" id="L1345" title="1 of 4 branches missed.">        if ((this.extractedRecords != null) &amp;&amp; !this.extractedRecords.isEmpty()) {</span>
<span class="fc" id="L1346">            c.clearExtractedRecords(); // remove super.clone copy</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">            for (final IBaseDataObject r : this.extractedRecords) {</span>
<span class="fc" id="L1348">                c.addExtractedRecord(r.clone());</span>
<span class="fc" id="L1349">            }</span>
        }
        // This creates a deep copy Guava style
<span class="fc" id="L1352">        c.parameters = LinkedListMultimap.create(this.parameters);</span>

<span class="fc" id="L1354">        return c;</span>
    }

    @Override
    public Instant getCreationTimestamp() {
<span class="fc" id="L1359">        return this.creationTimestamp;</span>
    }

    /**
     * The creation timestamp is part of the provenance of the event represented by this instance. It is normally set from
     * the constructor
     *
     * @param creationTimestamp when this item was created
     */
    @Override
    public void setCreationTimestamp(final Instant creationTimestamp) {
<span class="fc bfc" id="L1370" title="All 2 branches covered.">        if (creationTimestamp == null) {</span>
<span class="fc" id="L1371">            throw new IllegalArgumentException(&quot;Timestamp must not be null&quot;);</span>
        }

<span class="fc" id="L1374">        this.creationTimestamp = creationTimestamp;</span>
<span class="fc" id="L1375">    }</span>

    @Override
    public List&lt;IBaseDataObject&gt; getExtractedRecords() {
<span class="fc" id="L1379">        return this.extractedRecords;</span>
    }

    @Override
    public void setExtractedRecords(final List&lt;? extends IBaseDataObject&gt; records) {
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        if (records == null) {</span>
<span class="fc" id="L1385">            throw new IllegalArgumentException(&quot;Record list must not be null&quot;);</span>
        }

<span class="fc bfc" id="L1388" title="All 2 branches covered.">        for (final IBaseDataObject r : records) {</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">            if (r == null) {</span>
<span class="fc" id="L1390">                throw new IllegalArgumentException(&quot;No added record may be null&quot;);</span>
            }
<span class="fc" id="L1392">        }</span>

<span class="fc" id="L1394">        this.extractedRecords = new ArrayList&lt;&gt;(records);</span>
<span class="fc" id="L1395">    }</span>

    @Override
    public void addExtractedRecord(final IBaseDataObject record) {
<span class="fc bfc" id="L1399" title="All 2 branches covered.">        if (record == null) {</span>
<span class="fc" id="L1400">            throw new IllegalArgumentException(&quot;Added record must not be null&quot;);</span>
        }

<span class="fc bfc" id="L1403" title="All 2 branches covered.">        if (this.extractedRecords == null) {</span>
<span class="fc" id="L1404">            this.extractedRecords = new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L1407">        this.extractedRecords.add(record);</span>
<span class="fc" id="L1408">    }</span>

    @Override
    public void addExtractedRecords(final List&lt;? extends IBaseDataObject&gt; records) {
<span class="fc bfc" id="L1412" title="All 2 branches covered.">        if (records == null) {</span>
<span class="fc" id="L1413">            throw new IllegalArgumentException(&quot;ExtractedRecord list must not be null&quot;);</span>
        }

<span class="fc bfc" id="L1416" title="All 2 branches covered.">        for (final IBaseDataObject r : records) {</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">            if (r == null) {</span>
<span class="fc" id="L1418">                throw new IllegalArgumentException(&quot;No ExctractedRecord item may be null&quot;);</span>
            }
<span class="fc" id="L1420">        }</span>

<span class="fc bfc" id="L1422" title="All 2 branches covered.">        if (this.extractedRecords == null) {</span>
<span class="fc" id="L1423">            this.extractedRecords = new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L1426">        this.extractedRecords.addAll(records);</span>
<span class="fc" id="L1427">    }</span>

    @Override
    public boolean hasExtractedRecords() {
<span class="fc bfc" id="L1431" title="All 4 branches covered.">        return (this.extractedRecords != null) &amp;&amp; !this.extractedRecords.isEmpty();</span>
    }

    @Override
    public void clearExtractedRecords() {
<span class="fc" id="L1436">        this.extractedRecords = null;</span>
<span class="fc" id="L1437">    }</span>

    @Override
    public int getExtractedRecordCount() {
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">        return (this.extractedRecords == null) ? 0 : this.extractedRecords.size();</span>
    }

    @Override
    public UUID getInternalId() {
<span class="fc" id="L1446">        return this.internalId;</span>
    }

    @Override
    public boolean isOutputable() {
<span class="fc" id="L1451">        return outputable;</span>
    }

    @Override
    public void setOutputable(boolean outputable) {
<span class="fc" id="L1456">        this.outputable = outputable;</span>
<span class="fc" id="L1457">    }</span>

    @Override
    public String getId() {
<span class="fc" id="L1461">        return id;</span>
    }

    @Override
    public void setId(String id) {
<span class="fc" id="L1466">        this.id = id;</span>
<span class="fc" id="L1467">    }</span>

    @Override
    public String getWorkBundleId() {
<span class="fc" id="L1471">        return workBundleId;</span>
    }

    @Override
    public void setWorkBundleId(String workBundleId) {
<span class="fc" id="L1476">        this.workBundleId = workBundleId;</span>
<span class="fc" id="L1477">    }</span>

    @Override
    public String getTransactionId() {
<span class="fc" id="L1481">        return transactionId;</span>
    }

    @Override
    public void setTransactionId(String transactionId) {
<span class="fc" id="L1486">        this.transactionId = transactionId;</span>
<span class="fc" id="L1487">    }</span>

    @Override
    public IBaseDataObject getTld() {
<span class="fc" id="L1491">        return tld;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>