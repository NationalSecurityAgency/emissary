<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AgentPool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.pool</a> &gt; <span class="el_source">AgentPool.java</span></div><h1>AgentPool.java</h1><pre class="source lang-java linenums">package emissary.pool;

import emissary.core.IMobileAgent;
import emissary.core.Namespace;
import emissary.core.NamespaceException;

import jakarta.annotation.Nullable;
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;

/**
 * Extends the GenericObjectPool to hold MobileAgents, each on it's own thread.
 */
public class AgentPool extends GenericObjectPool&lt;IMobileAgent&gt; {

    private static final int MAX_CALCULATED_AGENT_COUNT = 50;
    private static final int BYTES_IN_GIGABYTES = 1073741824;

    /**
     * The default name by which we register into the namespace
     */
    protected static final String DEFAULT_NAMESPACE_NAME = &quot;AgentPool&quot;;

    /**
     * Super class has private access on factory, so save here
     */
    protected MobileAgentFactory factory;

    /**
     * Our logger
     */
<span class="fc" id="L35">    protected static final Logger logger = LoggerFactory.getLogger(AgentPool.class);</span>

    /**
     * The name used by this pool
     */
    protected String namespaceName;

    private final int initialPoolSize;

    /**
     * Compute the default size for the pool
     * 
     * @param maxMemoryInBytes System max memory used in calculating pool size
     * @param poolSizeOverride User set property for pool size
     */
    protected static int computePoolSize(final long maxMemoryInBytes, @Nullable final Integer poolSizeOverride) {

        // Override based on property
<span class="fc bfc" id="L53" title="All 4 branches covered.">        if (poolSizeOverride != null &amp;&amp; poolSizeOverride &gt; 0) {</span>
<span class="fc" id="L54">            logger.debug(&quot;Default pool size from properties {}&quot;, poolSizeOverride);</span>
<span class="fc" id="L55">            return poolSizeOverride;</span>
        }
        // Check that maxMemoryInBytes is a valid argument
<span class="fc bfc" id="L58" title="All 2 branches covered.">        if (maxMemoryInBytes &lt;= 0) {</span>
<span class="fc" id="L59">            throw new IllegalArgumentException(&quot;Must be greater then zero.&quot;);</span>
        }

        // 15 if less than 1 Gb
        // 20 for first Gb, +5 for each additional Gb, no more then 50 when calculated
<span class="fc" id="L64">        int size = (((int) (maxMemoryInBytes / BYTES_IN_GIGABYTES) - 1) * 5) + 20;</span>
<span class="fc" id="L65">        size = Math.min(size, MAX_CALCULATED_AGENT_COUNT);</span>
<span class="fc" id="L66">        logger.debug(&quot;Computed default pool size of {}&quot;, size);</span>

<span class="fc" id="L68">        return size;</span>
    }

    /**
     * Compute the default size for the pool
     */
    public static int computePoolSize() {
<span class="fc" id="L75">        final Integer poolSizeProperty = Integer.getInteger(&quot;agent.poolsize&quot;, null);</span>
<span class="fc" id="L76">        final long maxMemoryInBytes = Runtime.getRuntime().maxMemory();</span>
<span class="fc" id="L77">        return computePoolSize(maxMemoryInBytes, poolSizeProperty);</span>
    }

    /**
     * Create and configure the pool using the default name and size
     * 
     * @param factory pool object producer
     */
    public AgentPool(MobileAgentFactory factory) {
<span class="fc" id="L86">        this(factory, AgentPool.computePoolSize(), DEFAULT_NAMESPACE_NAME);</span>
<span class="fc" id="L87">    }</span>

    /**
     * Create and configure the pool using the default name
     * 
     * @param maxActive max pool size
     * @param factory pool object producer
     */
    public AgentPool(MobileAgentFactory factory, int maxActive) {
<span class="fc" id="L96">        this(factory, maxActive, DEFAULT_NAMESPACE_NAME);</span>
<span class="fc" id="L97">    }</span>


    /**
     * Create and configure the pool using the specified name
     * 
     * @param factory pool object producer
     * @param maxActive max pool size
     * @param name name of the pool in the namespace
     */
    public AgentPool(MobileAgentFactory factory, int maxActive, String name) {
<span class="fc" id="L108">        super(factory);</span>
<span class="fc" id="L109">        this.factory = factory;</span>
<span class="fc" id="L110">        initialPoolSize = maxActive;</span>
<span class="fc" id="L111">        configurePool(name);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Configure the commons pool stuff based on our requirements
     * 
     * @param name name of the pool in the namespace
     */
    protected void configurePool(String name) {
<span class="fc" id="L120">        namespaceName = name;</span>

        // Set blocking policy
<span class="fc" id="L123">        setBlockWhenExhausted(true);</span>

        // Set maximum wait time when blocking on exhausted pool
<span class="fc" id="L126">        setMaxWait(Duration.ofMinutes(50));</span>

<span class="fc" id="L128">        logger.debug(&quot;Configuring AgentPool to use {} agents&quot;, initialPoolSize);</span>

<span class="fc" id="L130">        setMaxTotal(initialPoolSize);</span>
<span class="fc" id="L131">        setMinIdle(initialPoolSize);</span>
<span class="fc" id="L132">        setMaxIdle(initialPoolSize);</span>

<span class="fc" id="L134">        bindPool();</span>
<span class="fc" id="L135">        fillPool();</span>
<span class="fc" id="L136">    }</span>

    /**
     * Ensure the pool is full
     */
    protected void fillPool() {
<span class="fc" id="L142">        int level = getMaxTotal();</span>
        // fill in the pool
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (int i = 0; i &lt; level; i++) {</span>
            try {
<span class="fc" id="L146">                addObject();</span>
<span class="nc" id="L147">            } catch (Exception e) {</span>
<span class="nc" id="L148">                logger.error(&quot;Cannot fill AgentPool&quot;, e);</span>
<span class="fc" id="L149">            }</span>
        }
<span class="fc" id="L151">    }</span>

    /**
     * Reset the factory. Pool will be emptied and refilled
     * 
     * @param factory the new factory
     */
    public void resetFactory(MobileAgentFactory factory) {
        // Ideally we will need to drop and recreate the entire pool
        // in order to get around this deprecated method, but that has
        // impact on the global namespace, most weirdly for the caller
        // of this method since the reference they hold is obsoleted by
        // making this call
<span class="nc" id="L164">        this.factory = factory;</span>
<span class="nc" id="L165">        emptyPool();</span>
<span class="nc" id="L166">        fillPool();</span>
<span class="nc" id="L167">    }</span>

    /**
     * Bind the pool into the namespace
     */
    protected void bindPool() {
        // register this pool in the namespace
<span class="fc" id="L174">        Namespace.bind(namespaceName, this);</span>
<span class="fc" id="L175">    }</span>

    /**
     * Get the name used to register this pool
     */
    public String getPoolName() {
<span class="fc" id="L181">        return namespaceName;</span>
    }

    /**
     * Get an agent from the pool
     */
    public IMobileAgent borrowAgent() throws Exception {
        try {
<span class="fc" id="L189">            IMobileAgent a = borrowObject();</span>
<span class="fc" id="L190">            logger.trace(&quot;POOL borrow active={}&quot;, getNumActive());</span>
<span class="fc" id="L191">            return a;</span>
<span class="nc" id="L192">        } catch (Exception e) {</span>
<span class="nc" id="L193">            logger.info(&quot;AgentPool.borrowAgent did not work, stats={}&quot;, this);</span>
<span class="nc" id="L194">            throw e;</span>
        }
    }

    /*
     * Get the total current agents in the pool
     */
    public synchronized int getCurrentPoolSize() {
<span class="fc" id="L202">        return getNumIdle() + getNumActive();</span>
    }

    protected void emptyPool() {
<span class="fc" id="L206">        int numberKilled = 0;</span>
<span class="fc" id="L207">        int numberToKill = getCurrentPoolSize();</span>
<span class="fc" id="L208">        long waitTil = System.currentTimeMillis() + (30 * 60 * 1000); // 30 min</span>
<span class="fc" id="L209">        logger.debug(&quot;Going to kill {} agents&quot;, numberToKill);</span>
        try {
<span class="fc bfc" id="L211" title="All 2 branches covered.">            while (getCurrentPoolSize() != 0) {</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">                if (System.currentTimeMillis() &gt; waitTil) {</span>
<span class="nc" id="L213">                    throw new InterruptedException(&quot;Too long, tired of waiting. Some MobileAgents are going to die poorly&quot;);</span>
                }

<span class="fc" id="L216">                logger.debug(&quot;Emptying pool, {} active, {} idle&quot;, getNumActive(), getNumIdle());</span>
<span class="fc" id="L217">                int currentIdle = getNumIdle();</span>
<span class="fc" id="L218">                int killedThisRound = 0;</span>
<span class="fc" id="L219">                setMaxIdle(0); // so the returnAgent call below destroys the agent</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                for (int i = 0; i &lt; currentIdle; i++) {</span>
                    IMobileAgent a;
                    try {
<span class="fc" id="L223">                        a = borrowAgent();</span>
<span class="nc" id="L224">                    } catch (Exception e) {</span>
<span class="nc" id="L225">                        logger.error(&quot;Error trying to borrowAgent&quot;, e);</span>
<span class="nc" id="L226">                        continue;</span>
<span class="fc" id="L227">                    }</span>

<span class="fc" id="L229">                    a.killAgent();</span>
<span class="fc" id="L230">                    numberKilled++;</span>
<span class="fc" id="L231">                    killedThisRound++;</span>

                    try {
                        // destroys the object, needed to decrement the numIdle
<span class="fc" id="L235">                        returnAgent(a);</span>
<span class="nc" id="L236">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L237">                        logger.error(&quot;Error trying to returnAgent: {}&quot;, a.getName(), e);</span>
<span class="fc" id="L238">                    }</span>
                }
<span class="fc" id="L240">                logger.debug(&quot;Killed {} agents this round, {} total killed&quot;, killedThisRound, numberKilled);</span>
                // give some space for working agents to be returned
<span class="fc" id="L242">                setMaxIdle(numberToKill - numberKilled);</span>
<span class="fc" id="L243">                Thread.sleep(5000);</span>
<span class="fc" id="L244">            }</span>
<span class="fc" id="L245">            logger.info(&quot;Pool is now empty&quot;);</span>
<span class="nc" id="L246">        } catch (InterruptedException e) {</span>
<span class="nc" id="L247">            logger.error(&quot;emptyPool interrupted&quot;, e);</span>
<span class="nc" id="L248">            Thread.currentThread().interrupt();</span>
        } finally {
<span class="fc" id="L250">            setMaxIdle(0); // just in case</span>
        }
<span class="fc" id="L252">    }</span>

    /**
     * Gracefully close down all agents and unbind the pool
     */
    @Override
    public void close() {
<span class="fc" id="L259">        logger.info(&quot;Closing the agent pool&quot;);</span>
<span class="fc" id="L260">        setMaxTotal(0);</span>
<span class="fc" id="L261">        emptyPool();</span>
<span class="fc" id="L262">        super.close();</span>
<span class="fc" id="L263">        Namespace.unbind(getPoolName());</span>
<span class="fc" id="L264">        logger.info(&quot;Done closing the agent pool&quot;);</span>
<span class="fc" id="L265">    }</span>

    /**
     * Forcibly stop all agents and unbind the pool
     */
    public void kill() {
<span class="nc" id="L271">        logger.info(&quot;Killing the agent pool&quot;);</span>
<span class="nc" id="L272">        super.close();</span>
<span class="nc" id="L273">        Namespace.unbind(getPoolName());</span>
<span class="nc" id="L274">        logger.info(&quot;Done killing the agent pool&quot;);</span>
<span class="nc" id="L275">    }</span>

    /**
     * Return an agent to the pool
     */
    public void returnAgent(IMobileAgent agent) {
<span class="fc" id="L281">        logger.trace(&quot;Returning {}&quot;, agent.getName());</span>
<span class="fc" id="L282">        returnObject(agent);</span>
<span class="fc" id="L283">        logger.trace(&quot;POOL return active={}&quot;, getNumActive());</span>
<span class="fc" id="L284">    }</span>

    /**
     * Return the default named agent pool instance from the namespace
     */
    public static AgentPool lookup() throws NamespaceException {
<span class="fc" id="L290">        return (AgentPool) Namespace.lookup(DEFAULT_NAMESPACE_NAME);</span>
    }

    /**
     * Return the specified agent pool instance from the Namespace
     */
    public static AgentPool lookup(String name) throws NamespaceException {
<span class="nc" id="L297">        return (AgentPool) Namespace.lookup(name);</span>
    }

    /**
     * To string for lightweight reporting
     */
    @Override
    public synchronized String toString() {
<span class="nc" id="L305">        return &quot;Poolsize active/idle = &quot; + getNumActive() + &quot;/&quot; + getNumIdle() + &quot; - &quot; + getPoolName();</span>
    }

    /**
     * Get the name of the class being used from the factory
     * 
     * @return class name for the agents
     */
    public String getClassName() {
<span class="nc" id="L314">        return factory.getClassString();</span>
    }

    /**
     * Try to predict whether a borrow will block/grow the pool
     */
    public boolean isAgentAvailable() {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        return getNumIdle() &gt; 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>