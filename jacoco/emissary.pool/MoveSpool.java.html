<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MoveSpool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.pool</a> &gt; <span class="el_source">MoveSpool.java</span></div><h1>MoveSpool.java</h1><pre class="source lang-java linenums">package emissary.pool;

import emissary.core.IMobileAgent;
import emissary.core.Namespace;
import emissary.core.NamespaceException;
import emissary.directory.DirectoryEntry;
import emissary.directory.IDirectoryPlace;
import emissary.directory.KeyManipulator;
import emissary.place.IServiceProviderPlace;
import emissary.util.PayloadUtil;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Provide a storage area for incoming &quot;moveTo(here)&quot; payloads so that the http transfer can become more asnychronous.
 * This class provides a FIFO for payloads that are arriving and a thread that will put them into agents from the pool
 * as agents become available
 */

public class MoveSpool implements Runnable {

    // Our logger
<span class="fc" id="L31">    private static final Logger logger = LoggerFactory.getLogger(MoveSpool.class);</span>

    // The payload FIFO
<span class="fc" id="L34">    protected final Deque&lt;SpoolItem&gt; spool = new ArrayDeque&lt;&gt;();</span>

    // Reference to the agent pool
    protected AgentPool pool;

    // The thread that stuffs payloads into pool agents
    Thread watcher;

    // thread quit control
<span class="fc" id="L43">    boolean timeToQuit = false;</span>

    // How we want to be registerd in the namespace
    public static final String NAMESPACE_NAME = &quot;ArrivalSpool&quot;;

    // Stats on how many moves and for what types arrived here
<span class="fc" id="L49">    public final Map&lt;String, Integer&gt; moveCountMap = new HashMap&lt;&gt;();</span>

    // Stats collection
<span class="fc" id="L52">    private int highWaterMark = 0;</span>
    @SuppressWarnings(&quot;NonFinalStaticField&quot;)
<span class="fc" id="L54">    private static long lookupCount = 0;</span>
<span class="fc" id="L55">    private long enqueCount = 0;</span>
<span class="fc" id="L56">    private long dequeCount = 0;</span>

    // Cached ref to my local directory
<span class="fc" id="L59">    @Nullable</span>
    IDirectoryPlace localDirectory = null;

    // Methods for using the spool to dispatch
<span class="nc" id="L63">    public enum Method {</span>
<span class="nc" id="L64">        ARRIVE, GO</span>
    }

    /**
     * Make one and bind it in the namespace
     */
<span class="fc" id="L70">    public MoveSpool() {</span>
<span class="fc" id="L71">        configure();</span>

        // register this pool in the namespace
<span class="fc" id="L74">        Namespace.bind(NAMESPACE_NAME, this);</span>
<span class="fc" id="L75">    }</span>

    /**
     * Configure stuff
     */
    @SuppressWarnings(&quot;ThreadPriorityCheck&quot;)
    private void configure() {
        // Get the agent pool
<span class="fc" id="L83">        resetPool();</span>

        // start the watcher thread
<span class="fc" id="L86">        watcher = new Thread(this, &quot;MoveSpool&quot;);</span>
<span class="fc" id="L87">        watcher.setPriority(Thread.MAX_PRIORITY - 2);</span>
<span class="fc" id="L88">        watcher.setDaemon(true);</span>
<span class="fc" id="L89">        watcher.start();</span>
<span class="fc" id="L90">    }</span>

    public void resetPool() {
        // grab the default pool
        try {
<span class="fc" id="L95">            pool = AgentPool.lookup();</span>
<span class="fc" id="L96">            logger.debug(&quot;Found the AgentPool on MoveSpool#resetPool&quot;);</span>
<span class="nc" id="L97">        } catch (NamespaceException nex) {</span>
<span class="nc" id="L98">            logger.error(&quot;Unable to find agent pool, &quot; + &quot;please create the agent pool before creating the MoveSpool&quot;);</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">    }</span>

    /**
     * Shut down the spooling thread and clear out any remaining payloads.
     */
    public void quit() {
<span class="nc" id="L106">        logger.warn(&quot;Purging the spool...&quot;);</span>
<span class="nc" id="L107">        synchronized (spool) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (!spool.isEmpty()) {</span>
<span class="nc" id="L109">                spool.clear();</span>
            }
<span class="nc" id="L111">            spool.notifyAll();</span>
<span class="nc" id="L112">        }</span>
<span class="nc" id="L113">        timeToQuit = true;</span>
<span class="nc" id="L114">        Namespace.unbind(NAMESPACE_NAME);</span>
<span class="nc" id="L115">        logger.info(&quot;Done stopping the move spool&quot;);</span>
<span class="nc" id="L116">    }</span>

    /**
     * Get a reference to the local directory on this machine
     *
     * @return a reference to the local directory from the namespace
     */
    private IDirectoryPlace getLocalDirectory() {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (localDirectory == null) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            for (String key : Namespace.keySet()) {</span>
                try {
<span class="nc" id="L127">                    Object value = Namespace.lookup(key);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                    if (value instanceof IDirectoryPlace) {</span>
<span class="nc" id="L129">                        localDirectory = (IDirectoryPlace) value;</span>
<span class="nc" id="L130">                        break;</span>
                    }
<span class="nc" id="L132">                } catch (NamespaceException ex) {</span>
<span class="nc" id="L133">                    logger.info(&quot;Problem in namespace&quot;, ex);</span>
<span class="nc" id="L134">                }</span>
<span class="nc" id="L135">            }</span>
        }
<span class="nc" id="L137">        return localDirectory;</span>
    }

    /**
     * Run the thread to watch the spool
     */
    @Override
    @SuppressWarnings(&quot;ThreadPriorityCheck&quot;)
    public void run() {
<span class="fc" id="L146">        int consecutiveSendCounter = 0;</span>

        // Run until we are told to quit
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        while (!timeToQuit) {</span>
            // Check the spool for work to be done
<span class="fc" id="L151">            int sz = 0;</span>
<span class="fc" id="L152">            synchronized (spool) {</span>
<span class="fc" id="L153">                sz = spool.size();</span>
<span class="fc" id="L154">            }</span>

<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (sz == 0) {</span>
                // No payloads to look at. Sleep a while
<span class="fc" id="L158">                consecutiveSendCounter = 0;</span>
                try {
<span class="fc" id="L160">                    logger.debug(&quot;Nothing in spool, time to wait...&quot;);</span>
<span class="fc" id="L161">                    Thread.yield();</span>
<span class="fc" id="L162">                    synchronized (spool) {</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">                        if (spool.isEmpty()) {</span>
<span class="nc" id="L164">                            spool.wait(60000);</span>
                        }
<span class="nc" id="L166">                    }</span>
<span class="nc" id="L167">                } catch (InterruptedException ignore) {</span>
<span class="nc" id="L168">                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L169">                }</span>
<span class="nc" id="L170">                continue;</span>
            }

            // Get an agent and a sool item
<span class="nc" id="L174">            IMobileAgent agent = null;</span>
<span class="nc" id="L175">            SpoolItem item = null;</span>
<span class="nc" id="L176">            String itemName = null;</span>

            try {
                // This may block for the max time the
                // pool is configured to use if no
                // agents available
<span class="nc" id="L182">                agent = pool.borrowAgent();</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                if (agent == null) {</span>
<span class="nc" id="L184">                    logger.debug(&quot;Got a null agent from pool!&quot;);</span>
                    continue;
                }

                // Get the oldest payload from the spool
<span class="nc" id="L189">                item = removeFirstPayload();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (item == null) {</span>
<span class="nc" id="L191">                    logger.debug(&quot;Got a null item from move spool!&quot;);</span>
<span class="nc" id="L192">                    pool.returnAgent(agent);</span>
                    continue;
                }

                // We have both an agent and a spool item
                // so hook em up and send it on the way
<span class="nc" id="L198">                itemName = PayloadUtil.getName(item.getPayload());</span>

<span class="nc" id="L200">                logger.debug(&quot;Handing over &quot; + itemName + &quot; to an agent, method=&quot; + item.getMethod());</span>

<span class="nc bnc" id="L202" title="All 2 branches missed.">                if (item.getMethod() == Method.GO) {</span>
<span class="nc" id="L203">                    IServiceProviderPlace place = item.getPlace();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                    if (place == null) {</span>
<span class="nc" id="L205">                        place = getLocalDirectory();</span>
                    }

<span class="nc" id="L208">                    Object payload = item.getPayload();</span>
<span class="nc" id="L209">                    agent.go(payload, place);</span>
<span class="nc" id="L210">                    consecutiveSendCounter++;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                } else if (item.getMethod() == Method.ARRIVE) {</span>
<span class="nc" id="L212">                    agent.arrive(item.getPayload(), item.getPlace(), item.getErrorCount(), item.getItineraryItems());</span>
<span class="nc" id="L213">                    consecutiveSendCounter++;</span>
                } else {
<span class="nc" id="L215">                    logger.error(&quot;Illegal spooler method specified &quot; + item.getMethod() + &quot;, payload=&quot; + item.getPayload()</span>
                            + &quot; will be irretreivably lost&quot;);
                }

<span class="nc bnc" id="L219" title="All 2 branches missed.">                if (consecutiveSendCounter % 10 == 0) {</span>
<span class="nc" id="L220">                    logger.debug(&quot;Sent 10 consecutive entries, &quot; + &quot;time to yield the MoveSpool&quot;);</span>
<span class="nc" id="L221">                    Thread.yield();</span>
                }
<span class="nc" id="L223">            } catch (Throwable t) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                if (agent != null) {</span>
<span class="nc" id="L225">                    logger.error(&quot;Unable to start agent, payload &quot; + itemName + &quot; is irretrievably lost&quot;, t);</span>
                    try {
<span class="nc" id="L227">                        pool.returnAgent(agent);</span>
<span class="nc" id="L228">                    } catch (RuntimeException ex) {</span>
<span class="nc" id="L229">                        logger.error(&quot;Unable to return agent to the pool&quot;, ex);</span>
<span class="nc" id="L230">                    }</span>
                } else {
<span class="nc" id="L232">                    logger.debug(&quot;Cannot get agent from pool, trying again&quot;, t);</span>
                }
            } finally {
                // hold no references to this stuff
<span class="nc" id="L236">                agent = null;</span>
<span class="nc" id="L237">                item = null;</span>
            }
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">    }</span>

    /**
     * Remove the oldest payload item on the spool
     *
     * @return SpoolItem from the spool
     */
    protected SpoolItem removeFirstPayload() {
<span class="nc" id="L248">        SpoolItem s = null;</span>
<span class="nc" id="L249">        synchronized (spool) {</span>
            // Do some stats
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (spool.size() &gt; highWaterMark) {</span>
<span class="nc" id="L252">                highWaterMark = spool.size();</span>
            }

<span class="nc" id="L255">            s = spool.removeFirst();</span>
<span class="nc" id="L256">            dequeCount++;</span>
<span class="nc" id="L257">        }</span>
<span class="nc" id="L258">        return s;</span>
    }

    /**
     * Add an item to the spool for sending. Can be the result of a sprout or a new item being ingested into the system. The
     * arrivalPlace is null so we call MobileAgent.go rather than MobileAgent.arrive
     *
     * @param payload the dataObject or Collection to save
     * @return number of items on the queue
     */
    public int send(Object payload) {
<span class="nc" id="L269">        return enqueue(Method.GO, payload, null, 0, (List&lt;DirectoryEntry&gt;) null);</span>
    }

    /**
     * Add an item to the spool for sending. Can be the result of a sprout or a new item being ingested into the system. We
     * call MobileAgent.go rather than MobileAgent.arrive
     *
     * @param payload the dataObject or Collection to save
     * @param place the sending or sprouting place reference
     * @return number of items on the queue
     */
    public int send(Object payload, IServiceProviderPlace place) {
<span class="nc" id="L281">        return enqueue(Method.GO, payload, place, 0, (List&lt;DirectoryEntry&gt;) null);</span>
    }

    /**
     * Add an arriving payload and associated state transfer info to the spool Calls MobileAgent.arrive in this case
     *
     * @param payload the data object or Collection to save
     * @param place IServiceProviderPlace ref for the agent to visit
     * @param errorCount state from the transferred MobileAgent
     * @param itineraryItems state from the transferred MobileAgent
     * @return number of items in the queue
     */
    public int arrive(Object payload, IServiceProviderPlace place, int errorCount, List&lt;DirectoryEntry&gt; itineraryItems) {
<span class="nc" id="L294">        return enqueue(Method.ARRIVE, payload, place, errorCount, itineraryItems);</span>
    }

    /**
     * Add an item to the spool. When an agent becomes available it is assigned to this payload in turn. We call
     * MobileAgent.go or MobileAgent.arrive depending on the Method requested
     *
     * @param method ARRIVE or GO
     * @param payload the data object or Collection to save
     * @param place IServiceProviderPlace ref for the agent to visit, possibly null
     * @param errorCount state from the transferred MobileAgent or null for GO
     * @param itineraryItems state from the transferred MobileAgent or empty for GO
     * @return number of items on the queue
     */
    protected int enqueue(Method method, Object payload, @Nullable IServiceProviderPlace place, int errorCount,
            @Nullable List&lt;DirectoryEntry&gt; itineraryItems) {

<span class="nc" id="L311">        String itemName = PayloadUtil.getName(payload);</span>
<span class="nc" id="L312">        logger.debug(&quot;Enqueue item &quot; + itemName + &quot; for place &quot; + place + &quot;, method=&quot; + method);</span>
<span class="nc" id="L313">        SpoolItem s = new SpoolItem(method, payload, place, errorCount, itineraryItems);</span>
<span class="nc" id="L314">        int size = 0;</span>

<span class="nc" id="L316">        synchronized (spool) {</span>
<span class="nc" id="L317">            spool.addLast(s);</span>
<span class="nc" id="L318">            enqueCount++;</span>
<span class="nc" id="L319">            size = spool.size();</span>
<span class="nc" id="L320">            spool.notifyAll();</span>
<span class="nc" id="L321">        }</span>

        // Collect the stats
<span class="nc" id="L324">        synchronized (moveCountMap) {</span>
<span class="nc" id="L325">            String serviceName = s.getServiceName();</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (moveCountMap.containsKey(serviceName)) {</span>
<span class="nc" id="L327">                Integer count = moveCountMap.get(serviceName);</span>
<span class="nc" id="L328">                moveCountMap.put(serviceName, Integer.valueOf(count.intValue() + 1));</span>
<span class="nc" id="L329">            } else {</span>
<span class="nc" id="L330">                moveCountMap.put(serviceName, Integer.valueOf(1));</span>
            }
<span class="nc" id="L332">        }</span>

<span class="nc" id="L334">        logger.debug(&quot;Done enqueue of &quot; + itemName + &quot;, size=&quot; + size);</span>
<span class="nc" id="L335">        return size;</span>
    }


    /**
     * Look up the instance in the namespace
     */
    public static MoveSpool lookup() throws NamespaceException {
<span class="nc" id="L343">        lookupCount++;</span>
<span class="nc" id="L344">        return (MoveSpool) Namespace.lookup(NAMESPACE_NAME);</span>
    }

    /**
     * Provide a copy of the map for stats gathering applications. This map shows how many items of each type have arrived
     * on this node
     */
    public Map&lt;String, Integer&gt; getMoveCountMap() {
<span class="nc" id="L352">        synchronized (moveCountMap) {</span>
<span class="nc" id="L353">            return new HashMap&lt;&gt;(moveCountMap);</span>
        }
    }

    /**
     * Provide statistics in string form
     *
     * @return list of types and counts that have spooled here
     */
    public String getStatPairs() {
<span class="nc" id="L363">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L364">        sb.append(&quot;{&quot;);</span>
<span class="nc" id="L365">        synchronized (moveCountMap) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            for (String key : moveCountMap.keySet()) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                if (sb.length() &gt; 1) {</span>
<span class="nc" id="L368">                    sb.append(&quot;,&quot;);</span>
                }
<span class="nc" id="L370">                sb.append(key).append(&quot;=&quot;).append(moveCountMap.get(key));</span>
<span class="nc" id="L371">            }</span>
<span class="nc" id="L372">        }</span>
<span class="nc" id="L373">        sb.append(&quot;}&quot;);</span>
<span class="nc" id="L374">        return sb.toString();</span>
    }


    /**
     * To String for the namespace display
     */
    @Override
    public String toString() {
        // Spool size is deliberately not synchronized
<span class="nc" id="L384">        return &quot;MoveSpool current/high &quot; + spool.size() + &quot;/&quot; + highWaterMark + &quot;, en/dequeue &quot; + enqueCount + &quot;/&quot; + dequeCount + &quot;, serviceNames=&quot;</span>
<span class="nc" id="L385">                + getStatPairs();</span>
    }

    /**
     * Non-public encapsulation of what we need to hold on the spool
     */
    protected static class SpoolItem {

        final Method method;
        final Object payload;
        final IServiceProviderPlace place;
        final int errorCount;
        final List&lt;DirectoryEntry&gt; itineraryItems;

<span class="nc" id="L399">        public SpoolItem(Method method, Object payload, IServiceProviderPlace place, int errorCount, List&lt;DirectoryEntry&gt; itineraryItems) {</span>
<span class="nc" id="L400">            this.method = method;</span>
<span class="nc" id="L401">            this.payload = payload;</span>
<span class="nc" id="L402">            this.place = place;</span>
<span class="nc" id="L403">            this.errorCount = errorCount;</span>
<span class="nc" id="L404">            this.itineraryItems = itineraryItems;</span>
<span class="nc" id="L405">        }</span>

        /**
         * Get the payload
         */
        public Object getPayload() {
<span class="nc" id="L411">            return payload;</span>
        }

        /**
         * Get the place
         */
        public IServiceProviderPlace getPlace() {
<span class="nc" id="L418">            return place;</span>
        }

        /**
         * Get the error count
         */
        public int getErrorCount() {
<span class="nc" id="L425">            return errorCount;</span>
        }

        /**
         * Get serviceName from place key
         *
         * @return string service name from key
         */
        public String getServiceName() {
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (place != null) {</span>
<span class="nc" id="L435">                return KeyManipulator.getServiceName(place.getKey());</span>
            }
<span class="nc" id="L437">            return &quot;sprout&quot;;</span>
        }

        /**
         * Get the list of itinerary items
         *
         * @return List of DirectoryEntry
         */
        public List&lt;DirectoryEntry&gt; getItineraryItems() {
<span class="nc" id="L446">            return itineraryItems;</span>
        }

        /**
         * Get the spool method
         */
        public Method getMethod() {
<span class="nc" id="L453">            return method;</span>
        }
    }

    /**
     * Get the lookupCount
     *
     * @return the lookupCount
     */
    public static long getLookupCount() {
<span class="nc" id="L463">        return lookupCount;</span>
    }

    /**
     * Get the dequeCount
     *
     * @return the dequeCount
     */
    public long getDequeCount() {
<span class="nc" id="L472">        return dequeCount;</span>
    }

    /**
     * Get the enqueCount
     *
     * @return the enqueCount
     */
    public long getEnqueCount() {
<span class="nc" id="L481">        return enqueCount;</span>
    }

    /**
     * Get the highWaterMark
     *
     * @return the highWaterMark
     */
    public int getHighWaterMark() {
<span class="nc" id="L490">        return highWaterMark;</span>
    }

    public int getCurrentSpoolSize() {
<span class="nc" id="L494">        return spool.size();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>