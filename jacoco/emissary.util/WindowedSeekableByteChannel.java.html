<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WindowedSeekableByteChannel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">WindowedSeekableByteChannel.java</span></div><h1>WindowedSeekableByteChannel.java</h1><pre class="source lang-java linenums">package emissary.util;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.SeekableByteChannel;

/**
 * This class provides a seekable channel for a portion, or window, within the provided ReadableByteChannel. The
 * underlying window size is configured on instantiation. If you intend to move the positions for stateful processing,
 * you should provide a buffer size, &lt;code&gt;buffsize&lt;/code&gt;, greater than the maximum amount you wish to operate against
 * at any one time.
 *
 * &lt;p&gt;
 * This implementation should be able to hold a maximum window of ~4GB. This implementation uses on heap buffers so be
 * wary of using Integer.MAX_VALUE as that can cause and OOME.
 */
public class WindowedSeekableByteChannel implements SeekableByteChannel {
<span class="fc" id="L25">    private static final Logger logger = LoggerFactory.getLogger(WindowedSeekableByteChannel.class);</span>

    /**
     * The input source
     */
    private final ReadableByteChannel in;

    /**
     * estimated length. We have to estimate because we are buffering into a window and may not be at the end. We read ahead
     * to keep buffers full, but there can be additional data.
     */
    long estimatedLength;

    /**
     * The earliest position we can move to. Essentially, position of the underlying Channel that is at position 0 of buff1
     */
    long minposition;

    /* Maximum amount of data allowed in memory */
    // long maxwindow;

    /** flag if we've reached the end of the underlying channel */
    private boolean endofchannel;

    /**
     * Internal buffers for windowed content
     */
    @Nullable
    private ByteBuffer buff1;
    @Nullable
    private ByteBuffer buff2;

    /**
     * Creates a new instance and populates buffers with data.
     */
<span class="fc" id="L60">    public WindowedSeekableByteChannel(final ReadableByteChannel in, final int buffsize) throws IOException {</span>

<span class="fc" id="L62">        logger.debug(&quot;WindowSeekableByteChannel created with buffer size = {}&quot;, buffsize);</span>

<span class="pc bpc" id="L64" title="1 of 4 branches missed.">        if ((in == null) || !in.isOpen()) {</span>
<span class="fc" id="L65">            throw new IllegalArgumentException(&quot;Channel must be open and not null:&quot;);</span>
        }

<span class="fc" id="L68">        this.in = in;</span>
<span class="fc" id="L69">        int capacity = buffsize / 2;</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if ((buffsize % 2) == 1) {</span>
<span class="fc" id="L71">            capacity++;</span>
        }

<span class="fc" id="L74">        this.buff1 = ByteBuffer.allocate(capacity);</span>
<span class="fc" id="L75">        readIntoBuffer(this.buff1);</span>
        // only fill buff2 if there's more to read. otherwise save heap
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (!this.endofchannel) {</span>
<span class="fc" id="L78">            this.buff2 = ByteBuffer.allocate(capacity);</span>
<span class="fc" id="L79">            readIntoBuffer(this.buff2);</span>
        } else {
<span class="fc" id="L81">            this.buff2 = ByteBuffer.allocate(0);</span>
        }
<span class="fc" id="L83">    }</span>

    /**
     * If necessary, will move data in the window to make room for additional data from the channel.
     */
    private void realignBuffers() throws IOException {
<span class="fc" id="L89">        logger.debug(&quot;realignBuffers() called: buf1 = {}, buf2 = {}&quot;, buff1, buff2);</span>

<span class="fc" id="L91">        final int qtr = this.buff1.capacity() / 2;</span>
<span class="fc bfc" id="L92" title="All 4 branches covered.">        if (this.endofchannel || (this.buff2.remaining() &gt; qtr)) {</span>
<span class="fc" id="L93">            logger.debug(&quot;after early return from realignBuffers(): buf1 = {}, buf2 = {}&quot;, buff1, buff2);</span>
<span class="fc" id="L94">            return;</span>
        }
        // keep track of our position
<span class="fc" id="L97">        final long offset = (long) this.buff1.position() + this.buff2.position();</span>
<span class="fc" id="L98">        this.buff1.position(qtr);</span>
        // push them forward
<span class="fc" id="L100">        this.buff1.compact();</span>

        // read from the beginning of the buffer
<span class="fc" id="L103">        this.buff2.rewind();</span>

<span class="fc" id="L105">        logger.debug(&quot;realignBuffers() called prior to fillDst: buf1 = {}, buf2 = {}&quot;, buff1, buff2);</span>

<span class="fc" id="L107">        filldst(this.buff2, this.buff1);</span>
        // chuck the bytes read into buff1

<span class="fc" id="L110">        logger.debug(&quot;realignBuffers() called prior prior to buff2 compact: buf1 = {}, buf2 = {}&quot;, buff1, buff2);</span>

<span class="fc" id="L112">        this.buff2.compact();</span>

<span class="fc" id="L114">        logger.debug(&quot;realignBuffers() called prior to readIntoBuffer: buf1 = {}, buf2 = {}&quot;, buff1, buff2);</span>
<span class="fc" id="L115">        readIntoBuffer(this.buff2);</span>
        // update the offset
<span class="fc" id="L117">        this.minposition += qtr;</span>
        // reset our location
<span class="fc" id="L119">        setOffset(offset - qtr);</span>

<span class="fc" id="L121">        logger.debug(&quot;after realignBuffers(): buf1 = {}, buf2 = {}&quot;, buff1, buff2);</span>

<span class="fc" id="L123">    }</span>

    /**
     * Determine if there are bytes available to be read.
     *
     * @return true if either buffer has data remaining or we have not reached the end of channel.
     */
    private boolean bytesAvailable() {
<span class="fc bfc" id="L131" title="All 6 branches covered.">        return this.buff1.remaining() &gt; 0 || this.buff2.remaining() &gt; 0 || !this.endofchannel;</span>
    }

    /**
     * Attempt to read data from the open channel into the buffer provided.
     * &lt;p&gt;
     * After this call completes, we have either filled the buffer -or- have reached the end of data in the input channel.
     * The buffer will have its position set to 0, and limit set to the end of the data read, which may be equal to the size
     * of the buffer.
     * &lt;p&gt;
     * Has the side effect of raising the endofchannel flag if we have exhausted the bytes in the input channel. Updates the
     * estimatedLength with the number of bytes read.
     *
     * @param buf the destination buffer.
     * @return the number of bytes read into the buffer.
     */
    private int readIntoBuffer(final ByteBuffer buf) throws IOException {
<span class="fc" id="L148">        logger.debug(&quot;readIntoBuffer() called: {}&quot;, buf);</span>

<span class="fc" id="L150">        final int rem = buf.remaining();</span>
<span class="fc" id="L151">        int read = 0;</span>
<span class="fc bfc" id="L152" title="All 4 branches covered.">        while ((read != -1) &amp;&amp; (buf.remaining() &gt; 0)) {</span>
<span class="fc" id="L153">            read = this.in.read(buf);</span>
        }
<span class="fc bfc" id="L155" title="All 2 branches covered.">        this.endofchannel = (read == -1);</span>
        // total amount read in case we hit EOS
<span class="fc" id="L157">        final int totalRead = rem - buf.remaining();</span>
<span class="fc" id="L158">        this.estimatedLength += totalRead;</span>
<span class="fc" id="L159">        buf.flip();</span>
<span class="fc" id="L160">        return totalRead;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see java.nio.channels.Channel#isOpen()
     */
    @Override
    public boolean isOpen() {
<span class="fc" id="L170">        return this.in.isOpen();</span>
    }

    /**
     * Closes underlying Channel and releases buffers. Further calls to this instance will result in unspecified behavior.
     *
     * @see java.nio.channels.Channel#close()
     */
    @Override
    public void close() throws IOException {
<span class="fc" id="L180">        this.in.close();</span>
<span class="fc" id="L181">        this.buff1 = null;</span>
<span class="fc" id="L182">        this.buff2 = null;</span>
<span class="fc" id="L183">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see java.nio.channels.SeekableByteChannel#read(ByteBuffer)
     */
    @Override
    public int read(final ByteBuffer dst) throws IOException {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (!this.isOpen()) {</span>
<span class="fc" id="L193">            throw new ClosedChannelException();</span>
        }

<span class="pc bpc" id="L196" title="1 of 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L197">            throw new IllegalArgumentException(&quot;Destination ByteBuffer cannot be null&quot;);</span>
        }

        // we have nothing left to read and have consumed both buffers fully.
<span class="fc bfc" id="L201" title="All 4 branches covered.">        if (this.endofchannel &amp;&amp; (this.buff1.remaining() + this.buff2.remaining() == 0)) {</span>
<span class="fc" id="L202">            return -1;</span>
        }

        // no more room in the target buffer, but we might have more to read.
        // - do we want to possibly throw an exception here?
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (dst.remaining() == 0) {</span>
<span class="nc" id="L208">            return 0;</span>
        }

<span class="fc" id="L211">        final int maxWrite = dst.remaining();</span>

<span class="fc bfc" id="L213" title="All 4 branches covered.">        while (dst.hasRemaining() &amp;&amp; bytesAvailable()) {</span>
            // filling buffers
<span class="fc" id="L215">            realignBuffers();</span>
<span class="fc" id="L216">            filldst(this.buff1, dst);</span>
<span class="fc" id="L217">            filldst(this.buff2, dst);</span>
        }
<span class="fc" id="L219">        final int bytesRead = maxWrite - dst.remaining();</span>
<span class="fc bfc" id="L220" title="All 4 branches covered.">        return (this.endofchannel &amp;&amp; bytesRead == 0) ? -1 : bytesRead;</span>
    }

    /*
     * Safely fill a destination buffer avoiding a buffer overflow if necessary. &lt;p&gt; Copies byte from src to dest. The
     * number of bytes copied is the minimum of the amount of space remaining in the destination buffer
     */
    private static void filldst(final ByteBuffer src, final ByteBuffer dst) {
<span class="fc bfc" id="L228" title="All 4 branches covered.">        while (src.hasRemaining() &amp;&amp; dst.hasRemaining()) {</span>
<span class="fc" id="L229">            final int origLimit = src.limit();</span>
            // avoid buffer overflow
<span class="fc bfc" id="L231" title="All 2 branches covered.">            final int limit = (src.remaining() &gt; dst.remaining()) ? (src.position() + dst.remaining()) : origLimit;</span>
<span class="fc" id="L232">            src.limit(limit);</span>
<span class="fc" id="L233">            dst.put(src);</span>
            // set it back
<span class="fc" id="L235">            src.limit(origLimit);</span>
<span class="fc" id="L236">        }</span>
<span class="fc" id="L237">    }</span>

    /**
     * {@inheritDoc}
     *
     * @see java.nio.channels.SeekableByteChannel#position()
     */
    @Override
    public long position() throws IOException {
<span class="fc" id="L246">        return this.minposition + this.buff1.position() + this.buff2.position();</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see java.nio.channels.SeekableByteChannel#position(long)
     */
    @Override
    public SeekableByteChannel position(final long newPosition) throws IOException {
        // if data hasn't been read in, we'll have to do it below and see if it's available
<span class="pc bpc" id="L257" title="3 of 4 branches missed.">        if (this.endofchannel &amp;&amp; (newPosition &gt; this.estimatedLength)) {</span>
<span class="nc" id="L258">            throw new EOFException(&quot;Position is beyond EOF&quot;);</span>
        }

<span class="fc" id="L261">        long tgtPosition = newPosition - this.minposition;</span>
        // see if we can move there
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (tgtPosition &lt; 0) {</span>
<span class="fc" id="L264">            throw new IllegalStateException(&quot;Cannot move to &quot; + newPosition + &quot; in the stream. Minimum position is &quot; + this.minposition);</span>
        }

<span class="fc bfc" id="L267" title="All 4 branches covered.">        while (!setOffset(tgtPosition) &amp;&amp; !this.endofchannel) {</span>
<span class="fc" id="L268">            realignBuffers();</span>
<span class="fc" id="L269">            tgtPosition = newPosition - this.minposition;</span>
        }
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (newPosition &gt; this.estimatedLength) {</span>
<span class="fc" id="L272">            throw new EOFException(&quot;Position is beyond EOF&quot;);</span>
        }
<span class="fc" id="L274">        return this;</span>
    }

    /**
     * attempts to set position to specified offset in underlying buffers
     */
    private boolean setOffset(final long tgtOffset) {
<span class="fc" id="L281">        logger.debug(&quot;setOffset() called tgtOffset = {}, buff1 = {}, buff2 = {}&quot;, tgtOffset, buff1, buff2);</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (tgtOffset &lt;= this.buff1.limit()) {</span>
<span class="fc" id="L284">            this.buff1.position((int) tgtOffset);</span>
<span class="fc" id="L285">            this.buff2.position(0);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        } else if (tgtOffset &lt;= (this.buff1.limit() + this.buff2.limit())) {</span>
<span class="fc" id="L287">            this.buff1.position(this.buff1.limit());</span>
<span class="fc" id="L288">            this.buff2.position((int) (tgtOffset - this.buff1.capacity()));</span>
        } else {
<span class="fc" id="L290">            this.buff1.position(this.buff1.limit());</span>
<span class="fc" id="L291">            this.buff2.position(this.buff2.limit());</span>
<span class="fc" id="L292">            return false;</span>
        }
<span class="fc" id="L294">        return true;</span>
    }

    /**
     * Returns the minimum position we can go to in the backing Channel. This is based on the current window mapped into the
     * backing store.
     *
     * @return the minimum allowed position in the channel
     */
    public long getMinPosition() {
<span class="fc" id="L304">        return this.minposition;</span>
    }

    /**
     * Returns the maximum position we can go to in the backing Channel. This is based on the current window mapped into the
     * backing store.
     *
     * @return the maximum allowed position in the channel
     */
    public long getMaxPosition() {
<span class="fc" id="L314">        return this.minposition + this.buff1.limit() + this.buff2.limit();</span>
    }

    /**
     * A potential size for the underlying Channel. This value can change as we read additional data into the buffer.
     * Eventually, this number should reflect the true size assuming no underlying exceptions.
     *
     * @return an estimated length of the underlying channel
     */
    @Override
    public long size() throws IOException {
<span class="fc" id="L325">        return this.estimatedLength;</span>
    }

    /**
     * This is a read only implementation.
     *
     * @param size The truncation size.
     * @return throws ex
     * @throws IOException If there is some I/O problem.
     * @throws UnsupportedOperationException If the operation is not supported.
     * @see java.nio.channels.SeekableByteChannel#truncate(long)
     */
    @Override
    public SeekableByteChannel truncate(final long size) throws IOException {
<span class="fc" id="L339">        throw new UnsupportedOperationException(&quot;This implementation does not allow mutations to the underlying channel&quot;);</span>
    }

    /**
     * Unsupported in this implementation. This could be modified in the future to allow in memory writes.
     *
     * @param source The bytes to write.
     * @return throws ex
     * @throws IOException If there is some I/O problem.
     * @throws UnsupportedOperationException If the operation is not supported.
     * @see java.nio.channels.SeekableByteChannel#write(ByteBuffer)
     */
    @Override
    public int write(final ByteBuffer source) throws IOException {
<span class="fc" id="L353">        throw new UnsupportedOperationException(&quot;This is a readonly implementation&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>