<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeFormatParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">DateTimeFormatParser.java</span></div><h1>DateTimeFormatParser.java</h1><pre class="source lang-java linenums">package emissary.util;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;

import jakarta.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

/**
 * Class for Parsing Dates using DateTimeFormatter. Attempts to parse a date of an unknown format with a predefined set
 * of formats.
 */
public class DateTimeFormatParser {

<span class="fc" id="L31">    protected static final List&lt;DateTimeFormatter&gt; dateTimeZoneFormats = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L32">    protected static final List&lt;DateTimeFormatter&gt; dateTimeOffsetFormats = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L33">    protected static final List&lt;DateTimeFormatter&gt; dateTimeFormats = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">    protected static final List&lt;DateTimeFormatter&gt; dateFormats = new ArrayList&lt;&gt;();</span>
    @SuppressWarnings(&quot;NonFinalStaticField&quot;)
    protected static ZoneId zone;

    private static final String DATE_TIME_ZONE_FORMAT = &quot;DATE_TIME_ZONE_FORMAT&quot;;
    private static final String DATE_TIME_OFFSET_FORMAT = &quot;DATE_TIME_OFFSET_FORMAT&quot;;
    private static final String DATE_TIME_FORMAT = &quot;DATE_TIME_FORMAT&quot;;
    private static final String DATE_FORMAT = &quot;DATE_FORMAT&quot;;

<span class="fc" id="L43">    protected static final Logger logger = LoggerFactory.getLogger(DateTimeFormatParser.class);</span>

    static {
<span class="fc" id="L46">        configure();</span>
<span class="fc" id="L47">    }</span>

    private DateTimeFormatParser() {}

    protected static void configure() {

        Configurator configG;
        try {
<span class="fc" id="L55">            configG = ConfigUtil.getConfigInfo(DateTimeFormatParser.class);</span>
<span class="nc" id="L56">        } catch (IOException e) {</span>
<span class="nc" id="L57">            logger.error(&quot;Cannot open default config file&quot;, e);</span>
<span class="nc" id="L58">            return;</span>
<span class="fc" id="L59">        }</span>
        try {
<span class="fc" id="L61">            zone = ZoneId.of(configG.findStringEntry(&quot;TIME_ZONE&quot;));</span>
<span class="nc" id="L62">        } catch (RuntimeException e) {</span>
<span class="nc" id="L63">            logger.error(&quot;There was an issue reading the time zone from the config file&quot;);</span>
<span class="nc" id="L64">            return;</span>
<span class="fc" id="L65">        }</span>

<span class="fc" id="L67">        loadDateTimeEntries(configG, DATE_TIME_ZONE_FORMAT, dateTimeZoneFormats);</span>
<span class="fc" id="L68">        loadDateTimeEntries(configG, DATE_TIME_OFFSET_FORMAT, dateTimeOffsetFormats);</span>
<span class="fc" id="L69">        loadDateTimeEntries(configG, DATE_TIME_FORMAT, dateTimeFormats);</span>
<span class="fc" id="L70">        loadDateTimeEntries(configG, DATE_FORMAT, dateFormats);</span>
<span class="fc" id="L71">    }</span>

    /**
     * Helper function to read the date time formats from the config file, parse them, and store them in the appropriate
     * DateTimeFormatter list for use later
     *
     * @param configG the Configurator object to load entries from
     * @param entryType the label that used in the config file for the category of format. This separates out the different
     *        formats that need to be parsed differently
     * @param dateFormats the list of DateTimeFormatter objects that corresponds to the appropriate format
     */
    private static void loadDateTimeEntries(Configurator configG, String entryType, List&lt;DateTimeFormatter&gt; dateFormats) {
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (final String dateFormatEntry : configG.findEntries(entryType)) {</span>
            try {
<span class="fc" id="L85">                DateTimeFormatter initialDtf =</span>
<span class="fc" id="L86">                        new DateTimeFormatterBuilder().parseCaseInsensitive().appendPattern(dateFormatEntry).toFormatter();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">                if (entryType.equals(DATE_TIME_ZONE_FORMAT)) {</span>
<span class="fc" id="L88">                    initialDtf = initialDtf.withZone(zone);</span>
                }
<span class="fc" id="L90">                final DateTimeFormatter dtf = initialDtf;</span>
<span class="fc" id="L91">                dateFormats.add(dtf);</span>
<span class="nc" id="L92">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L93">                logger.debug(&quot;{} entry '{}' cannot be parsed&quot;, entryType, dateFormatEntry, ex);</span>
<span class="fc" id="L94">            }</span>
<span class="fc" id="L95">        }</span>
<span class="fc" id="L96">        logger.debug(&quot;Loaded {} {} entries&quot;, dateTimeZoneFormats.size(), entryType);</span>
<span class="fc" id="L97">    }</span>

    /**
     * Cleans up the date string by removing certain characters before attempting to parse it
     * 
     * @param dateString the date string
     * @return the cleaned date string
     */
    private static String cleanDate(String dateString) {
        // Take it apart and stick it back together to
        // get rid of multiple contiguous spaces
<span class="fc" id="L108">        String cleanedDateString = dateString.replaceAll(&quot;\t+&quot;, &quot; &quot;); // tabs</span>
<span class="fc" id="L109">        cleanedDateString = cleanedDateString.replaceAll(&quot;[ ]+&quot;, &quot; &quot;); // multiple spaces</span>
<span class="fc" id="L110">        cleanedDateString = cleanedDateString.replaceAll(&quot;=0D$&quot;, &quot;&quot;); // common qp'ified ending</span>

<span class="fc" id="L112">        return cleanedDateString;</span>
    }

    /**
     * Parse an RFC-822 Date or one of the thousands of variants make a quick attempt to normalize the timezone information
     * and get the timestamp in GMT. Should change to pass in a default from the U124 header
     *
     * @param dateString the string date from the RFC 822 Date header
     * @param supplyDefaultOnBad when true use current date if sentDate cannot be parsed
     * @return the GMT time of the event or NOW if it cannot be parsed, or null if supplyDefaultOnBad is false
     */
    @Nullable
    public static LocalDateTime parseDate(final String dateString, final boolean supplyDefaultOnBad) {

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (StringUtils.isNotEmpty(dateString)) {</span>
<span class="fc" id="L127">            String cleanedDateString = cleanDate(dateString);</span>

<span class="fc" id="L129">            List&lt;Function&lt;String, LocalDateTime&gt;&gt; methodList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L130">            methodList.add(date -&gt; tryParseWithDateTimeZoneFormats(date));</span>
<span class="fc" id="L131">            methodList.add(date -&gt; tryParseWithDateTimeOffsetFormats(date));</span>
<span class="fc" id="L132">            methodList.add(date -&gt; tryParseWithDateTimeFormats(date));</span>
<span class="fc" id="L133">            methodList.add(date -&gt; tryParseWithDateFormats(date));</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">            for (Function&lt;String, LocalDateTime&gt; method : methodList) {</span>
<span class="fc" id="L136">                LocalDateTime date = method.apply(cleanedDateString);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                if (date != null) {</span>
<span class="fc" id="L138">                    return date;</span>
                }
<span class="fc" id="L140">            }</span>

            try {
<span class="nc" id="L143">                return Instant.from(DateTimeFormatter.ISO_INSTANT.parse(cleanedDateString)).atZone(zone).toLocalDateTime();</span>
<span class="fc" id="L144">            } catch (DateTimeParseException ignored) {</span>
                // ignore
            }

            // If none of these methods worked, use the default if required
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (supplyDefaultOnBad) {</span>
<span class="nc" id="L150">                return LocalDateTime.now(ZoneId.systemDefault());</span>
            }
        }
<span class="fc" id="L153">        return null;</span>
    }


    /**
     * Attempt to parse the string dateString with one of the ZonedDateTime patterns
     *
     * @param dateString the string to attempt to format
     * @return the LocalDateTime object if a formatter worked, or null otherwise
     */
    @Nullable
    private static LocalDateTime tryParseWithDateTimeZoneFormats(final String dateString) {
        // formats with a time zone
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (final DateTimeFormatter dtf : dateTimeZoneFormats) {</span>
            try {
<span class="fc" id="L168">                ZonedDateTime zdt = ZonedDateTime.parse(dateString, dtf);</span>
<span class="fc" id="L169">                zdt = ZonedDateTime.ofInstant(zdt.toInstant(), zone);</span>
<span class="fc" id="L170">                return zdt.toLocalDateTime();</span>
<span class="fc" id="L171">            } catch (DateTimeParseException ignored) {</span>
                // ignore
            }
<span class="fc" id="L174">        }</span>
<span class="fc" id="L175">        return null;</span>
    }

    /**
     * Attempt to parse the string dateString with one of the LocalDateTime patterns
     *
     * @param dateString the string to attempt to format
     * @return the LocalDateTime object if a formatter worked, or null otherwise
     */
    @Nullable
    private static LocalDateTime tryParseWithDateTimeFormats(final String dateString) {
        // formats with a date and time and no zone/offset
<span class="fc bfc" id="L187" title="All 2 branches covered.">        for (final DateTimeFormatter dtf : dateTimeFormats) {</span>
            try {
<span class="fc" id="L189">                return LocalDateTime.parse(dateString, dtf);</span>
<span class="fc" id="L190">            } catch (DateTimeParseException ignored) {</span>
                // ignore
            }
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">        return null;</span>
    }

    /**
     * Attempt to parse the string dateString with one of the OffsetDateTime patterns
     *
     * @param dateString the string to attempt to format
     * @return the LocalDateTime object if a formatter worked, or null otherwise
     */
    @Nullable
    private static LocalDateTime tryParseWithDateTimeOffsetFormats(final String dateString) {
        // formats with a time zone offset
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (final DateTimeFormatter dtf : dateTimeOffsetFormats) {</span>
            try {
<span class="fc" id="L208">                OffsetDateTime odt = OffsetDateTime.parse(dateString, dtf);</span>
<span class="fc" id="L209">                return OffsetDateTime.ofInstant(odt.toInstant(), zone).toLocalDateTime();</span>
<span class="fc" id="L210">            } catch (DateTimeParseException ignored) {</span>
                // ignore
            }
<span class="fc" id="L213">        }</span>
<span class="fc" id="L214">        return null;</span>
    }

    /**
     * Attempt to parse the string dateString with one of the LocalDate patterns
     *
     * @param dateString the string to attempt to format
     * @return the LocalDateTime object if a formatter worked, or null otherwise
     */
    @Nullable
    private static LocalDateTime tryParseWithDateFormats(final String dateString) {
        // formats with a date but no time
<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (final DateTimeFormatter dtf : dateFormats) {</span>
            try {
<span class="fc" id="L228">                LocalDate d = LocalDate.parse(dateString, dtf);</span>
<span class="fc" id="L229">                return d.atStartOfDay();</span>
<span class="fc" id="L230">            } catch (DateTimeParseException ignored) {</span>
                // ignore
            }
<span class="fc" id="L233">        }</span>
<span class="fc" id="L234">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>