<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharsetUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">CharsetUtil.java</span></div><h1>CharsetUtil.java</h1><pre class="source lang-java linenums">package emissary.util;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;

/**
 * A collection of utilities for dealing with different character sets in Java. Mainly with the aim of getting to UTF-8.
 * The j* routines generally take Java CharSet names while the non j* routines take derived charset names.
 *
 * This class contains an interpretation in Java of the GPL method isUTF8, available in C from
 * http://billposer.org/Software/unidesc.html and the copied routine is called LegalUTF8P in Get_UTF32_From_UTF8i.c
 *
 * Copyright (C) 2003-2006 William J. Poser (billposer@alum.mit.edu)
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if not, write to the Free
 * Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA or go to the web page:
 * http://www.gnu.org/licenses/gpl.txt.
 *
 * =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 *
 * This class contains the Apache Licensed isUnicodeString which is from Jakarta POI http://jakarta.apache.org/poi
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to You under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
public class CharsetUtil {
<span class="fc" id="L46">    private static final int[] trailingBytesForUtF8 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5};

    @SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L54">    private static final long[] offsetsFromUtF8 = {0x00000000L, 0x00003080L, 0x000e2080L, 0x03c82080L, 0xfa082080L, 0x82082080L};</span>

    // Our logger
<span class="fc" id="L57">    private static final Logger logger = LoggerFactory.getLogger(CharsetUtil.class);</span>


    /**
     * Get an array of UTF-8 characters from the input bytes
     *
     * @param byteArray the input bytes
     * @param charSet &lt;em&gt;derived&lt;/em&gt; charSet of the input array
     * @param start index into input array to start copying
     * @param end index into input array to stop copying
     * @return array of UTF8 char
     */
    public static char[] getUtfCharArray(final byte[] byteArray, final String charSet, final int start, final int end) {
<span class="nc" id="L70">        String actualCharSet = charSet;</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (actualCharSet != null) {</span>
<span class="nc" id="L72">            final String jcs = JavaCharSet.get(actualCharSet);</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (jcs != null) {</span>
<span class="nc" id="L74">                actualCharSet = jcs;</span>
            }
        }
<span class="nc" id="L77">        return jGetUtfCharArray(byteArray, actualCharSet, start, end);</span>
    }

    /**
     * Get an array of UTF-8 characters from the input bytes
     *
     * @param byteArray the input bytes
     * @param charSet &lt;em&gt;JAVA&lt;/em&gt; charSet of the input array
     * @param start byte index into input array to start copying
     * @param end byte index into input array to stop copying
     * @return array of UTF8 char
     */
    public static char[] jGetUtfCharArray(final byte[] byteArray, @Nullable final String charSet, final int start, final int end) {
<span class="nc" id="L90">        char[] cbuffer = null;</span>

<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (byteArray != null) {</span>

            // Check start value
<span class="nc bnc" id="L95" title="All 4 branches missed.">            if (start &gt; byteArray.length || start &lt; 0) {</span>
<span class="nc" id="L96">                throw new ArrayIndexOutOfBoundsException(&quot;start : &quot; + start + &quot;, actual length &quot; + byteArray.length);</span>
            }

            // Check end value
            final int actualEnd;
<span class="nc bnc" id="L101" title="All 4 branches missed.">            if ((end == -1) || (end &gt; byteArray.length)) {</span>
<span class="nc" id="L102">                actualEnd = byteArray.length;</span>
            } else {
<span class="nc" id="L104">                actualEnd = end;</span>
            }

<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (actualEnd &lt;= start) {</span>
<span class="nc" id="L108">                throw new ArrayIndexOutOfBoundsException(&quot;start : &quot; + start + &quot;, end : &quot; + actualEnd + &quot;, actual length &quot; + byteArray.length);</span>
            }

            // Convert byteArray to UTF-8
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (charSet != null) {</span>
                try {
<span class="nc" id="L114">                    final String converted = new String(byteArray, start, actualEnd - start, charSet);</span>
<span class="nc" id="L115">                    cbuffer = converted.toCharArray();</span>
<span class="nc" id="L116">                } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L117">                    logger.warn(&quot;Unable to convert to &quot; + charSet);</span>
                    // Convert from Byte Array to Char Array...
<span class="nc" id="L119">                    cbuffer = byteToCharArray(byteArray, start, actualEnd);</span>
<span class="nc" id="L120">                }</span>
            } else {
                // Convert from Byte Array to Char Array...
<span class="nc" id="L123">                cbuffer = byteToCharArray(byteArray, start, actualEnd);</span>
            }
        }

<span class="nc" id="L127">        return cbuffer;</span>
    }

    /**
     * Get a string in the specified encoding from the input String
     */
    public static String getUtfString(final String s, final String charSet) {
        try {
<span class="nc" id="L135">            return new String(s.getBytes(StandardCharsets.ISO_8859_1), charSet);</span>
<span class="nc" id="L136">        } catch (UnsupportedEncodingException uue) {</span>
<span class="nc" id="L137">            logger.warn(&quot;Unable to convert to &quot; + charSet);</span>
        }
<span class="nc" id="L139">        return s;</span>
    }

    /**
     * Get a string in the specified encoding
     *
     * @param data input bytes
     * @param charSet the JAVA charset
     * @return JUCS2 string or null if error
     */
    @Nullable
    public static String getUtfString(final byte[] data, final String charSet) {
        try {
<span class="nc" id="L152">            return new String(data, charSet);</span>
<span class="nc" id="L153">        } catch (UnsupportedEncodingException uue) {</span>
<span class="nc" id="L154">            logger.warn(&quot;Unable to convert to &quot; + charSet);</span>
        }
<span class="nc" id="L156">        return null;</span>
    }

    /**
     * Convert bytes to chars using platform default encoding
     *
     * @param bArray the input data
     */
    public static char[] byteToCharArray(final byte[] bArray) {
<span class="nc" id="L165">        final String theContent = new String(bArray);</span>
<span class="nc" id="L166">        final char[] cArray = theContent.toCharArray();</span>
<span class="nc" id="L167">        return cArray;</span>
    }

    /**
     * Convert bytes to chars using platform default encoding with begin and end points
     *
     * @param bArray the input data
     * @param start byte index into input to start copy
     * @param end byte index into input to end copy or -1 for end
     */
    private static char[] byteToCharArray(final byte[] bArray, final int start, final int end) {
<span class="nc bnc" id="L178" title="All 4 branches missed.">        final int len = (end == -1 ? bArray.length : (bArray.length &lt; end) ? bArray.length : end) - start;</span>
<span class="nc" id="L179">        final char[] cArray = new char[len];</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (int j = start; j &lt; len; j++) {</span>
<span class="nc" id="L182">            cArray[j] = (char) (0xFF &amp; bArray[j]);</span>
        }
<span class="nc" id="L184">        return cArray;</span>
    }

    /**
     * test for ascii ness
     *
     * @param s string to test
     * @return true if string is ascii
     */
    public static boolean isAscii(final String s) {
        try {
<span class="fc" id="L195">            final int len = s.length();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L197">                final char c = s.charAt(i);</span>
<span class="pc bpc" id="L198" title="1 of 4 branches missed.">                if (c &lt;= 0 || c &gt; 127) {</span>
<span class="fc" id="L199">                    return false;</span>
                }
            }
<span class="nc" id="L202">        } catch (RuntimeException e) {</span>
<span class="nc" id="L203">            return false;</span>
<span class="fc" id="L204">        }</span>
<span class="fc" id="L205">        return true;</span>
    }

    /**
     * Do the bytes behind this string represent valid utf8?
     *
     * @param s string to test
     * @return true if string is utf8
     */
    public static boolean isUtf8(final String s) {
<span class="fc" id="L215">        return isUtf8(s.getBytes(StandardCharsets.UTF_8));</span>
    }

    /**
     * do these bytes represent a valid utf8 string?
     *
     * @param data the bytes to check
     * @return true if valid utf8
     */

    public static boolean isUtf8(final byte[] data) {
<span class="fc" id="L226">        return isUtf8(data, 0, data.length);</span>
    }

    /**
     * Check for valid utf8 data. Borrowed from the unidesc package (GPL) by Bill Poser, converted from C to Java. The check
     * runs from offs to dlen-1
     *
     * @param data the bytes to check for validity
     * @param offs beginning offset to check
     * @param dlen ending offset of the range
     * @return true if valid utf8
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public static boolean isUtf8(final byte[] data, final int offs, final int dlen) {
<span class="fc" id="L240">        int pos = offs;</span>
        int a;

<span class="fc bfc" id="L243" title="All 2 branches covered.">        while (pos &lt; dlen) {</span>
            try {
<span class="fc" id="L245">                final int val = data[pos] &amp; 0xff;</span>
<span class="fc" id="L246">                final int len = trailingBytesForUtF8[val] + 1;</span>
<span class="fc" id="L247">                int srcptr = pos + len;</span>

<span class="pc bpc" id="L249" title="2 of 5 branches missed.">                switch (len) {</span>
                    // everything falls through when true
                    case 4:
<span class="nc" id="L252">                        a = (data[--srcptr] &amp; 0xff);</span>
<span class="nc bnc" id="L253" title="All 4 branches missed.">                        if (a &lt; 0x80 || a &gt; 0xbf) {</span>
<span class="nc" id="L254">                            return false;</span>
                        }
                    case 3:
<span class="fc" id="L257">                        a = (data[--srcptr] &amp; 0xff);</span>
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">                        if (a &lt; 0x80 || a &gt; 0xbf) {</span>
<span class="nc" id="L259">                            return false;</span>
                        }
                    case 2:
<span class="fc" id="L262">                        a = (data[--srcptr] &amp; 0xff);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                        if (a &gt; 0xbf) {</span>
<span class="fc" id="L264">                            return false;</span>
                        }

<span class="pc bpc" id="L267" title="3 of 4 branches missed.">                        switch (val) {</span>
                            // no fall through in this one
                            case 0xe0:
<span class="nc bnc" id="L270" title="All 2 branches missed.">                                if (a &lt; 0xa0) {</span>
<span class="nc" id="L271">                                    return false;</span>
                                }
                                break;
                            case 0xf0:
<span class="nc bnc" id="L275" title="All 2 branches missed.">                                if (a &lt; 0x90) {</span>
<span class="nc" id="L276">                                    return false;</span>
                                }
                                break;
                            case 0xf4:
<span class="nc bnc" id="L280" title="All 2 branches missed.">                                if (a &gt; 0x8f) {</span>
<span class="nc" id="L281">                                    return false;</span>
                                }
                                break;
                            default:
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">                                if (a &lt; 0x80) {</span>
<span class="nc" id="L286">                                    return false;</span>
                                }
                        }
                    case 1:
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">                        if (val &gt;= 0x80 &amp;&amp; val &lt; 0xc0) {</span>
<span class="nc" id="L291">                            return false;</span>
                        }
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                        if (val &gt;= 0xf0) {</span>
<span class="nc" id="L294">                            return false;</span>
                        }
                        break;
                    default:
<span class="nc" id="L298">                        return false;</span>
                }
<span class="fc" id="L300">                pos += len;</span>
<span class="nc" id="L301">            } catch (ArrayIndexOutOfBoundsException x) {</span>
<span class="nc" id="L302">                logger.warn(&quot;ooops&quot;, x);</span>
<span class="nc" id="L303">                return false;</span>
<span class="fc" id="L304">            }</span>
        }
<span class="fc" id="L306">        return true;</span>
    }

    /**
     * See if string has multibyte chars (No longer based on org.apache.poi.util.StringUtil) It would be a bad idea to call
     * this with a very large string
     *
     * @param value string to test
     * @return true if string has at least one multibyte char
     */
    public static boolean hasMultibyte(@Nullable final String value) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L318">            return false;</span>
        }
<span class="fc" id="L320">        final int cpc = value.codePointCount(0, value.length());</span>
<span class="fc" id="L321">        final int bc = value.getBytes().length;</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        return cpc != bc;</span>
    }

    /** This class is not meant to be instantiated. */
    private CharsetUtil() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>