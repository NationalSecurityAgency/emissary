<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlexibleDateTimeParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">FlexibleDateTimeParser.java</span></div><h1>FlexibleDateTimeParser.java</h1><pre class="source lang-java linenums">package emissary.util;

import emissary.config.ConfigEntry;
import emissary.config.ConfigUtil;
import emissary.config.Configurator;

import jakarta.annotation.Nullable;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.time.temporal.TemporalAccessor;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.stream.Collectors.toList;

/**
 * Attempt to parse a date in an unknown format. This will loop through a set of configured formats and convert it into
 * a {@link ZonedDateTime}.
 * &lt;p&gt;
 * Other parsing libs:
 * &lt;p&gt;
 * Natty - It handled a good chunk of the formats but not all.
 */
public final class FlexibleDateTimeParser {

    /* Logger */
<span class="fc" id="L43">    private static final Logger logger = LoggerFactory.getLogger(FlexibleDateTimeParser.class);</span>

    /* Configuration Variables */
    private static final String CFG_FORMAT_MAIN = &quot;FORMAT_DATETIME_MAIN&quot;;
    private static final String CFG_FORMAT_EXTRA = &quot;FORMAT_DATETIME_EXTRA&quot;;
    private static final String CFG_TIMEZONE = &quot;TIMEZONE&quot;;
    private static final String CFG_REMOVE_REGEX = &quot;REMOVE_REGEX&quot;;
    private static final String CFG_EXTRA_TEXT_REMOVE_REGEX = &quot;EXTRA_TEXT_REMOVE_REGEX&quot;;
    private static final String DEFAULT_TIMEZONE = &quot;GMT&quot;;
    private static final String SPACE = &quot; &quot;;
    private static final String EMPTY = &quot;&quot;;

    /* Remove all tabs and extra spaces */
<span class="fc" id="L56">    private static final Pattern REPLACE = Pattern.compile(&quot;\t+|[ ]+&quot;, Pattern.DOTALL);</span>

    /*
     * Remove other junk -- anything in an html tag, all parenthesis and quotes, and any non-word characters at the
     * beginning or end
     */
    private static final Pattern remove;

    /*
     * This is our last ditch parsing effort if we failed to parse the string - remove all extra text after the numeric time
     * zone offset
     */
    private static final Pattern extraTextRemove;

    /* timezone - config var: TIMEZONE */
    private static final ZoneId timezone;

    /* date time formats - vars: FORMAT_DATETIME_MAIN */
    private static final List&lt;DateTimeFormatter&gt; dateFormatsMain;

    /* Extra date time formats - list to try if our main list has failed - vars: FORMAT_DATETIME_EXTRA */
    private static final List&lt;DateTimeFormatter&gt; dateFormatsExtra;

    /* init */
    static {
        try {
            // fire up the configurator
<span class="fc" id="L83">            Configurator configurator = ConfigUtil.getConfigInfo(FlexibleDateTimeParser.class);</span>
<span class="fc" id="L84">            timezone = setupTimezone(configurator.findStringEntry(CFG_TIMEZONE, DEFAULT_TIMEZONE));</span>

<span class="fc" id="L86">            List&lt;ConfigEntry&gt; configEntriesMain = configurator.findStringMatchEntries(CFG_FORMAT_MAIN);</span>
<span class="fc" id="L87">            dateFormatsMain = setupDateFormats(configEntriesMain, getConfigFormats(configEntriesMain));</span>

<span class="fc" id="L89">            List&lt;ConfigEntry&gt; configEntriesExtra = configurator.findStringMatchEntries(CFG_FORMAT_EXTRA);</span>
<span class="fc" id="L90">            dateFormatsExtra = setupDateFormats(configEntriesExtra, getConfigFormats(configEntriesExtra));</span>

<span class="fc" id="L92">            String removeRegex = configurator.findStringEntry(CFG_REMOVE_REGEX, &quot;&lt;.+?&gt;$|=0D$|\\(|\\)|\&quot;|\\[|]|\\W+$|^\\W+&quot;);</span>
<span class="fc" id="L93">            remove = Pattern.compile(removeRegex, Pattern.DOTALL);</span>

            // last ditch parsing effort if we failed to parse the string - remove all extra text after the numeric timezone offset
<span class="fc" id="L96">            String extraTextRemoveRegex = configurator.findStringEntry(CFG_EXTRA_TEXT_REMOVE_REGEX, &quot;((\\+|-)\\d{4}).*$&quot;);</span>
<span class="fc" id="L97">            extraTextRemove = Pattern.compile(extraTextRemoveRegex);</span>
<span class="nc" id="L98">        } catch (IOException e) {</span>
<span class="nc" id="L99">            throw new IllegalArgumentException(&quot;Could not configure parser!!&quot;, e);</span>
<span class="fc" id="L100">        }</span>
<span class="fc" id="L101">    }</span>

    /**
     * Get the default timezone id for the application
     *
     * @return the configured immutable and thread-safe zone id
     */
    public static ZoneId getTimezone() {
<span class="fc" id="L109">        return timezone;</span>
    }

    /**
     * Attempts to parse a string date using pre-configured patterns. Default not trying the extensive date/time format list
     *
     * @param dateString the string to parse
     * @return the parsed immutable and thread-safe zoned-date, or null if it failed to parse
     */
    public static ZonedDateTime parse(final String dateString) {
<span class="fc" id="L119">        return parse(dateString, false);</span>
    }

    /**
     * Attempts to parse a string date using pre-configured patterns
     *
     * @param dateString the string to parse
     * @param tryExtensiveParsing True if we want to try out complete list of date/time formats False if we only want to
     *        attempt the most common date/time formats
     * @return the parsed immutable and thread-safe zoned-date, or null if it failed to parse
     */
    public static ZonedDateTime parse(final String dateString, boolean tryExtensiveParsing) {
<span class="fc" id="L131">        ZonedDateTime zdt = parseToZonedDateTime(dateString, tryExtensiveParsing);</span>

<span class="fc bfc" id="L133" title="All 4 branches covered.">        if (zdt != null || !tryExtensiveParsing) {</span>
<span class="fc" id="L134">            return zdt;</span>
        } else {
            // if that all failed and we want to attempt extensive parsing, attempt the last ditch efforts we can try
<span class="fc" id="L137">            return lastDitchParsingEffort(dateString);</span>
        }
    }

    /**
     * Attempts to parse a string date
     *
     * @param dateString the string to parse
     * @param format the date/time formats to use
     * @return the parsed immutable and thread-safe zoned-date, or null if it failed to parse
     */
    public static ZonedDateTime parse(final String dateString, final DateTimeFormatter format) {
<span class="fc" id="L149">        return parse(dateString, Collections.singletonList(format));</span>
    }

    /**
     * Attempts to parse a string date
     *
     * @param dateString the string to parse
     * @param formats the date/time formats to use
     * @return the parsed immutable and thread-safe zoned-date, or null if it failed to parse
     */
    @Nullable
    public static ZonedDateTime parse(final String dateString, final List&lt;DateTimeFormatter&gt; formats) {
<span class="fc" id="L161">        String cleanedDateString = cleanDateString(dateString);</span>

<span class="fc bfc" id="L163" title="All 4 branches covered.">        if (StringUtils.isBlank(cleanedDateString) || CollectionUtils.isEmpty(formats)) {</span>
<span class="fc" id="L164">            return null;</span>
        }

<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (DateTimeFormatter formatter : formats) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if (formatter == null) {</span>
<span class="fc" id="L169">                continue;</span>
            }

            try {
                // try for a zoned date (has timezone), local date time (no time zone), or just a local date (no time)
<span class="fc" id="L174">                TemporalAccessor accessor =</span>
<span class="fc" id="L175">                        formatter.parseBest(cleanedDateString, ZonedDateTime::from, OffsetDateTime::from, LocalDateTime::from, LocalDate::from);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                if (accessor instanceof ZonedDateTime) {</span>
<span class="fc" id="L177">                    return (ZonedDateTime) accessor; // return the date time w/ timezone</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                } else if (accessor instanceof OffsetDateTime) {</span>
<span class="nc" id="L179">                    return ((OffsetDateTime) accessor).atZoneSameInstant(timezone);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                } else if (accessor instanceof LocalDateTime) {</span>
<span class="fc" id="L181">                    return ((LocalDateTime) accessor).atZone(timezone); // set the timezone</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">                } else if (accessor instanceof LocalDate) {</span>
<span class="fc" id="L183">                    return ((LocalDate) accessor).atStartOfDay(timezone); // add zeroed out time</span>
                }

<span class="fc" id="L186">            } catch (NullPointerException | IllegalArgumentException | DateTimeParseException e) {</span>
                // Ignore b/c failures are expected -&gt; set to trace otherwise will be noisy
<span class="fc" id="L188">                logger.trace(&quot;Error parsing date {} with format {}&quot;, dateString, formatter);</span>
<span class="nc" id="L189">            }</span>
<span class="fc" id="L190">        }</span>
<span class="fc" id="L191">        return null;</span>
    }

    /* Private Methods */

    /**
     * If all our formats failed to parse a date string, give it one last try to parse it. Look for a numeric offset (e.g.
     * +0000) and remove all text afterward. This should cover another set of cases where there is random text appended to
     * the end of the string, as well as removing invalid non-numeric time zone offsets while still picking up the numeric
     * offset Assumption - that tryExtensiveParsing is true - we should only get to this point if we want to try our best to
     * parse
     *
     * @param date The date string to parse
     * @return the ZonedDateTime object if removing text at the end was successful, or null otherwise
     */
    @Nullable
    static ZonedDateTime lastDitchParsingEffort(final String date) {

        // Attempt to remove all text after the numeric offset and try again - this should give us a valid date string
        // to work with
<span class="fc" id="L211">        Matcher matcher = extraTextRemove.matcher(date);</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (matcher.find()) {</span>
<span class="fc" id="L213">            String secondChanceDate = matcher.replaceAll(matcher.group(1));</span>
            // if we removed text, attempt to parse again to see if we are more successful this time
<span class="fc" id="L215">            return parseToZonedDateTime(secondChanceDate, true);</span>
        }
<span class="nc" id="L217">        return null;</span>
    }

    /**
     * Created to help against code duplication. Calls parse with the standard set of date formats, and then if that fails,
     * attempt the extra set of date formats if tryExtensiveParsing is set to true.
     *
     * @param dateString The string we are attempting to parse
     * @param tryExtensiveParsing Whether to use the extensive set of date formats
     * @return The ZonedDateTime object if our parsing was successful, or null if not
     */
    private static ZonedDateTime parseToZonedDateTime(final String dateString, boolean tryExtensiveParsing) {
<span class="fc" id="L229">        ZonedDateTime zdt = parse(dateString, dateFormatsMain);</span>

        // if we got a successful parse or we don't want to attempt &quot;extensive parsing&quot;, return here
<span class="fc bfc" id="L232" title="All 4 branches covered.">        if (!tryExtensiveParsing || zdt != null) {</span>
<span class="fc" id="L233">            return zdt;</span>
        }
<span class="fc" id="L235">        zdt = parse(dateString, dateFormatsExtra);</span>
<span class="fc" id="L236">        return zdt;</span>
    }

    /**
     * Get the timezone to use for parsing (needed for DateTimes that do not have timezone information)
     *
     * @param configTimezone timezone string [&quot;GMT&quot; or &quot;UTC&quot; or &quot;+0000&quot; or &quot;+00:00&quot; ...]
     * @return timezone
     */
    private static ZoneId setupTimezone(final String configTimezone) {
        try {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            if (StringUtils.isNotBlank(configTimezone)) {</span>
                // parse the timezone from the config
<span class="fc" id="L249">                return ZoneId.of(configTimezone);</span>
            }
<span class="nc" id="L251">        } catch (DateTimeException e) {</span>
<span class="nc" id="L252">            logger.error(&quot;Error parsing timezone {}, using default {}&quot;, configTimezone, timezone, e);</span>
<span class="nc" id="L253">        }</span>

<span class="nc" id="L255">        return ZoneId.of(DEFAULT_TIMEZONE);</span>
    }

    /**
     * Get the overrides for the default date formats
     *
     * @param configEntries the list of main override formats from the config file
     * @param dateTimeFormats the list of datetime formats
     * @return a list of {@link DateTimeFormatter}s
     */
    private static List&lt;DateTimeFormatter&gt; setupDateFormats(final List&lt;ConfigEntry&gt; configEntries, final List&lt;DateTimeFormatter&gt; dateTimeFormats) {
        List&lt;DateTimeFormatter&gt; dateFormats;
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (CollectionUtils.isNotEmpty(dateTimeFormats)) {</span>
<span class="fc" id="L268">            dateFormats = Collections.unmodifiableList(dateTimeFormats);</span>
<span class="fc" id="L269">            logger.debug(&quot;Created successfully. Created {} of {} formats from config&quot;, dateFormats.size(), configEntries.size());</span>
<span class="fc" id="L270">            return dateFormats;</span>
        } else {
<span class="nc" id="L272">            logger.error(&quot;Could not create with configured variables&quot;);</span>
<span class="nc" id="L273">            throw new IllegalArgumentException(&quot;No date/time formats configured!!&quot;);</span>
        }
    }

    /**
     * Loop through the date formats from the config file and create DateTimeFormatter objects
     *
     * @param configEntries the list of override formats from the config file
     * @return a list of {@link DateTimeFormatter}s
     */
    @Nullable
    private static List&lt;DateTimeFormatter&gt; getConfigFormats(final List&lt;ConfigEntry&gt; configEntries) {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (CollectionUtils.isEmpty(configEntries)) {</span>
<span class="nc" id="L286">            return null;</span>
        }
<span class="fc" id="L288">        return configEntries.stream().map(FlexibleDateTimeParser::getFormatter).filter(Objects::nonNull).collect(toList());</span>
    }

    /**
     * Create the DateTimeFormatter object
     *
     * @param entry format from the config file
     * @return {@link DateTimeFormatter} if the pattern is valid, null otherwise
     */
    @Nullable
    private static DateTimeFormatter getFormatter(ConfigEntry entry) {
        try {
<span class="fc" id="L300">            return new DateTimeFormatterBuilder().parseCaseInsensitive().appendPattern(entry.getValue()).toFormatter();</span>
<span class="nc" id="L301">        } catch (IllegalArgumentException e) {</span>
            // log the bad one and move on because there could be other possible patterns
<span class="nc" id="L303">            logger.error(&quot;Error parsing pattern [{}]: {}&quot;, entry.getValue(), e.getLocalizedMessage());</span>
        }
<span class="nc" id="L305">        return null;</span>
    }

    /**
     * Clean up the date string for processing (remove extra spaces, tabs, html, ...)
     *
     * @param date the date string to clean
     * @return the scrubbed date string
     */
    private static String cleanDateString(final String date) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (StringUtils.isBlank(date)) {</span>
<span class="fc" id="L316">            return date;</span>
        }

        // date strings over 100 characters are more than likely invalid
<span class="fc" id="L320">        String cleanedDateString = StringUtils.substring(date, 0, 100);</span>
<span class="fc" id="L321">        cleanedDateString = REPLACE.matcher(cleanedDateString).replaceAll(SPACE);</span>
<span class="fc" id="L322">        cleanedDateString = remove.matcher(cleanedDateString).replaceAll(EMPTY);</span>

<span class="fc" id="L324">        return StringUtils.trimToNull(cleanedDateString);</span>
    }

    /**
     * This class is not meant to be instantiated
     */
    private FlexibleDateTimeParser() {}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>