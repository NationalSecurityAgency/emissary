<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimeUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">TimeUtil.java</span></div><h1>TimeUtil.java</h1><pre class="source lang-java linenums">package emissary.util;

import jakarta.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.DateTimeException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAccessor;
import java.time.zone.ZoneRulesException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TimeUtil {

<span class="fc" id="L23">    private static final ZoneId GMT = ZoneId.of(&quot;GMT&quot;);</span>
<span class="fc" id="L24">    public static final DateTimeFormatter DATE_WITH_SLASHES = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd/HH/mm&quot;).withZone(GMT);</span>
<span class="fc" id="L25">    public static final DateTimeFormatter DATE_ISO_8601 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;).withZone(GMT);</span>
<span class="fc" id="L26">    public static final DateTimeFormatter DATE_FULL_ISO_8601 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd'T'HH:mm:ssX&quot;).withZone(GMT);</span>
<span class="fc" id="L27">    public static final DateTimeFormatter DATE_ORDINAL = DateTimeFormatter.ofPattern(&quot;yyyyDDD&quot;).withZone(GMT);</span>
<span class="fc" id="L28">    public static final DateTimeFormatter DATE_ISO_8601_SSS = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span>
<span class="fc" id="L29">    public static final DateTimeFormatter DATE_ORDINAL_WITH_TIME = DateTimeFormatter.ofPattern(&quot;yyyyDDDHHmmss&quot;);</span>
    private static final String ISO_8601_TIME_DATE_STRING = &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;;
    private static final String HEX_REGEX = &quot;^0x([0-9A-Fa-f]{8})([0-9A-Fa-f]{8})&quot;;
<span class="fc" id="L32">    private static final Pattern HEX_DATE_PATTERN = Pattern.compile(HEX_REGEX);</span>
    private static final int HEX_RADIX = 16;
<span class="fc" id="L34">    private static final LocalDateTime STARTING_DATE = LocalDateTime.parse(&quot;1900-01-01 00:00:00.000&quot;, DATE_ISO_8601_SSS);</span>
<span class="fc" id="L35">    private static final Logger logger = LoggerFactory.getLogger(TimeUtil.class);</span>

    /**
     * Get the application configured timezone
     *
     * @return the timezone
     */
    public static ZoneId getTimezone() {
<span class="fc" id="L43">        return GMT;</span>
    }

    /**
     * Get current date/time formatted as specified
     *
     * @param format the specification
     * @param timeZone tz to use, defaults to GMT
     * @throws DateTimeException if the ID format is invalid
     * @throws ZoneRulesException if checking availability and the zone ID cannot be found
     * @throws IllegalArgumentException if the pattern is invalid
     */
    public static String getDate(final String format, @Nullable final String timeZone) {
<span class="fc bfc" id="L56" title="All 2 branches covered.">        ZoneId zoneId = timeZone == null ? GMT : ZoneId.of(timeZone);</span>
<span class="fc" id="L57">        return getDate(ZonedDateTime.now(zoneId), format, zoneId);</span>
    }

    /**
     * Given a date, format it with the given pattern
     *
     * @param date the date to format
     * @param format the date format
     * @param timeZone the time zone id
     * @return the formatted date
     * @throws DateTimeException if the ID format is invalid
     * @throws ZoneRulesException if checking availability and the zone ID cannot be found
     * @throws IllegalArgumentException if the pattern is invalid
     */
    @Nullable
    public static String getDate(@Nullable final TemporalAccessor date, final String format, @Nullable final ZoneId timeZone) {
<span class="fc bfc" id="L73" title="All 2 branches covered.">        if (date == null) {</span>
<span class="fc" id="L74">            return null;</span>
        }

<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (StringUtils.isEmpty(format)) {</span>
<span class="fc" id="L78">            throw new IllegalArgumentException(&quot;The date format cannot be empty!&quot;);</span>
        }

<span class="fc bfc" id="L81" title="All 2 branches covered.">        ZoneId zoneId = timeZone == null ? GMT : timeZone;</span>
<span class="fc" id="L82">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format).withZone(zoneId);</span>
<span class="fc" id="L83">        return formatter.format(date);</span>
    }

    /**
     * Get current date/time as a slash separated path component (yyyy-MM-dd/HH/mm)
     *
     * @return the formatted date in the form yyyy-MM-dd/HH/mm
     * @throws DateTimeException if an error occurs during formatting
     */
    public static String getCurrentDate() {
<span class="fc" id="L93">        return getDateAsPath(ZonedDateTime.now(GMT));</span>
    }

    /**
     * Get specified date/time as a slash separated path component (yyyy-MM-dd/HH/mm)
     *
     * @param date to format
     * @return the formatted date in the form yyyy-MM-dd/HH/mm
     * @throws DateTimeException if an error occurs during formatting
     */
    @Nullable
    public static String getDateAsPath(@Nullable final TemporalAccessor date) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L106">            return null;</span>
        }
<span class="fc" id="L108">        String dateStringDefault = DATE_WITH_SLASHES.format(date);</span>
<span class="fc" id="L109">        return dateStringDefault.substring(0, dateStringDefault.length() - 1) + &quot;0&quot;;</span>
    }

    /**
     * Get current date as yyyyjjj
     *
     * @return the formatted date in the form yyyyjjj
     * @throws DateTimeException if an error occurs during formatting
     */
    public static String getCurrentDateOrdinal() {
<span class="fc" id="L119">        return getDateOrdinal(ZonedDateTime.now(GMT));</span>
    }

    /**
     * Get current date as yyyyjjj
     *
     * @param date to format
     * @return the formatted date in the form yyyyjjj
     * @throws DateTimeException if an error occurs during formatting
     */
    @Nullable
    public static String getDateOrdinal(@Nullable TemporalAccessor date) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        return date == null ? null : DATE_ORDINAL.format(date);</span>
    }

    /**
     * Get current date/time as ISO-8601 string
     *
     * @return String in the format yyyy-MM-dd HH:mm:ss
     * @throws DateTimeException if an error occurs during formatting
     */
    @SuppressWarnings(&quot;MemberName&quot;)
    public static String getCurrentDateISO8601() {
<span class="nc" id="L142">        return getDateAsISO8601(ZonedDateTime.now(GMT));</span>
    }

    /**
     * Get specified time as ISO-8601 string
     *
     * @return String in the format yyyy-MM-dd HH:mm:ss
     * @throws DateTimeException if an error occurs during formatting
     */
    @SuppressWarnings(&quot;MemberName&quot;)
    public static String getDateAsISO8601(final long time) {
<span class="fc" id="L153">        return getDateAsISO8601(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), GMT));</span>
    }

    /**
     * Get specified date object as ISO-8601 string (yyyy-MM-dd HH:mm:ss)
     *
     * @param date to format
     * @return String in the format yyyy-MM-dd HH:mm:ss
     * @throws DateTimeException if an error occurs during formatting
     */
    @Nullable
    @SuppressWarnings(&quot;MemberName&quot;)
    public static String getDateAsISO8601(@Nullable final TemporalAccessor date) {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        return date == null ? null : DATE_ISO_8601.format(date);</span>
    }

    /**
     * Get current date/time as full ISO-8601 string yyyy-MM-dd'T'HH:mm:ss'Z'
     *
     * @return String in the format yyyy-MM-dd'T'HH:mm:ss'Z'
     * @throws DateTimeException if an error occurs during formatting
     */
    @SuppressWarnings(&quot;MemberName&quot;)
    public static String getCurrentDateFullISO8601() {
<span class="fc" id="L177">        return getDateAsFullISO8601(ZonedDateTime.now(GMT));</span>
    }

    /**
     * Get specified date object as a full ISO-8601 string (yyyy-MM-dd'T'HH:mm:ss'Z')
     *
     * @param date to format
     * @return the formatted date in yyyy-MM-dd'T'HH:mm:ss'Z'
     * @throws DateTimeException if an error occurs during formatting
     */
    @Nullable
    @SuppressWarnings(&quot;MemberName&quot;)
    public static String getDateAsFullISO8601(@Nullable final TemporalAccessor date) {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        return date == null ? null : DATE_FULL_ISO_8601.format(date);</span>
    }

    /**
     * Get Date object from ISO-8601 formatted string (&quot;yyyy-MM-dd HH:mm:ss&quot;)
     *
     * @param dateString the string representation of the date in the format yyyy-MM-dd HH:mm:ss
     * @return ZonedDateTime parsed from the string
     * @throws DateTimeParseException if string is not in the proper format
     *
     * @deprecated replaced by {@link FlexibleDateTimeParser#parse(String)}
     */
    @Nullable
    @Deprecated
    @SuppressWarnings(&quot;MemberName&quot;)
    public static ZonedDateTime getZonedDateFromISO8601(@Nullable final String dateString) {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        return dateString == null ? null : ZonedDateTime.parse(dateString, DATE_ISO_8601);</span>
    }

    /**
     * Parses hex date string into formatted string (&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;)
     *
     * @param hexDate hex string representation of the date
     * @return converted time in string format yyyy-MM-dd HH:mm:ss.SSS
     * @throws DateTimeParseException if could not parse date
     *
     */
    public static String convertHexDate(String hexDate) {
<span class="fc" id="L218">        Matcher m = HEX_DATE_PATTERN.matcher(hexDate);</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (m.find()) {</span>
<span class="fc" id="L221">            String dateHex = m.group(1);</span>
<span class="fc" id="L222">            String timeHex = m.group(2);</span>
<span class="fc" id="L223">            long daysToAdd = Long.parseLong(dateHex, HEX_RADIX);</span>
            // timeHex represents the number of ticks (1/300 of a second) since midnight
<span class="fc" id="L225">            long millisToAdd = Math.round(Long.parseLong(timeHex, HEX_RADIX) * 10 / 3.0);</span>

            LocalDateTime ldt;

            try {
<span class="fc" id="L230">                ldt = STARTING_DATE.plusDays(daysToAdd);</span>
<span class="fc" id="L231">                ldt = ldt.plus(millisToAdd, ChronoUnit.MILLIS);</span>
<span class="nc" id="L232">            } catch (DateTimeParseException ex) {</span>
<span class="nc" id="L233">                logger.debug(&quot;Could not parse date&quot;, ex);</span>
<span class="nc" id="L234">                throw ex;</span>
<span class="fc" id="L235">            }</span>

<span class="fc" id="L237">            return ldt.format(DATE_ISO_8601_SSS);</span>
        }

<span class="fc" id="L240">        String msg = String.format(&quot;Unexpected hexDate format '%s'&quot;, hexDate);</span>
<span class="fc" id="L241">        logger.debug(msg);</span>
<span class="fc" id="L242">        throw new IllegalArgumentException(msg);</span>
    }

    @SuppressWarnings(&quot;MemberName&quot;)
    public static String getISO8601DateFormatString() {
<span class="nc" id="L247">        return ISO_8601_TIME_DATE_STRING;</span>
    }

    public static String getDateOrdinalWithTime(final Instant d) {
<span class="fc" id="L251">        return DATE_ORDINAL_WITH_TIME.format(d.atZone(ZoneId.systemDefault()));</span>
    }

    /** This class is not meant to be instantiated. */
    private TimeUtil() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>