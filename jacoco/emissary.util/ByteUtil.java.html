<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">ByteUtil.java</span></div><h1>ByteUtil.java</h1><pre class="source lang-java linenums">package emissary.util;

import jakarta.annotation.Nullable;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;

/**
 * Common place for the logic to glue byte arrays back together. This is error-prone and shouldn't be thought about any
 * more than necessary
 */
public class ByteUtil {
    public static final byte ASCII_0 = '0';
    public static final byte ASCII_9 = '9';
    public static final byte ASCII_A_LC = 'a';
    public static final byte ASCII_B_LC = 'b';
    public static final byte ASCII_F_LC = 'f';
    public static final byte ASCII_Z_LC = 'z';
    public static final byte ASCII_A_UC = 'A';
    public static final byte ASCII_F_UC = 'F';
    public static final byte ASCII_Z_UC = 'Z';
    public static final byte ASCII_SLASH = '/';
    public static final byte ASCII_ESC = 0x1b;
    public static final byte ASCII_SP = 0x20;
    public static final byte ASCII_DEL = 0x7f;
    public static final String HEX = &quot;0123456789abcdefABCDEF&quot;;

    /**
     * Check if byte is hexadecimal
     *
     * @param b a byte
     * @return true if b is a hexadecimal
     */
    public static boolean isHexadecimal(byte b) {
<span class="fc bfc" id="L43" title="All 10 branches covered.">        return (b &gt;= ASCII_A_UC &amp;&amp; b &lt;= ASCII_F_UC) || (b &gt;= ASCII_A_LC &amp;&amp; b &lt;= ASCII_F_LC) || isDigit(b);</span>
    }

    /**
     * Check if all bytes in array are hexadecimal
     *
     * @param array a byte array
     * @return true if all bytes in array are hexadecimal
     */
    public static boolean isHexadecimal(byte[] array) {
<span class="fc bfc" id="L53" title="All 2 branches covered.">        for (byte b : array) {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">            if (!isHexadecimal(b)) {</span>
<span class="fc" id="L55">                return false;</span>
            }
        }
<span class="fc" id="L58">        return true;</span>
    }

    /**
     * Check if character is hexadecimal
     *
     * @param c a char
     * @return true if c is a hexadecimal
     */
    public static boolean isHexadecimal(char c) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        return HEX.indexOf(c) &gt; -1;</span>
    }

    /**
     * Check if all bytes are alphabetical
     *
     * @param array a byte array
     * @return true if all bytes in array are alpha
     */
    public static boolean isAlpha(byte[] array) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (byte b : array) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            if (!isAlpha(b)) {</span>
<span class="fc" id="L80">                return false;</span>
            }
        }
<span class="fc" id="L83">        return true;</span>
    }

    /**
     * Check if byte is alphabetical
     *
     * @param b a byte
     * @return true if b is alphabetical
     */
    public static boolean isAlpha(byte b) {
<span class="pc bpc" id="L93" title="2 of 8 branches missed.">        return (b &gt;= 'a' &amp;&amp; b &lt;= 'z') || (b &gt;= 'A' &amp;&amp; b &lt;= 'Z');</span>
    }

    /**
     * Check if byte is alphanumeric
     *
     * @param b a byte
     * @return true if b is alphanumeric
     */
    public static boolean isAlNum(byte b) {
<span class="fc bfc" id="L103" title="All 4 branches covered.">        return isAlpha(b) || isDigit(b);</span>
    }

    /**
     * Check if byte is a digit
     *
     * @param b a byte
     * @return true if b is a digit
     */
    public static boolean isDigit(byte b) {
        // check ascii value of b for digit-ness
<span class="fc bfc" id="L114" title="All 4 branches covered.">        return b &gt;= '0' &amp;&amp; b &lt;= '9';</span>
    }

    /**
     * Check if all bytes are digits
     *
     * @param array a byte array
     * @return true if all bytes in array are digits
     */
    public static boolean isDigit(byte[] array) {
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (byte b : array) {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (!isDigit(b)) {</span>
<span class="fc" id="L126">                return false;</span>
            }
        }
<span class="fc" id="L129">        return true;</span>
    }

    /**
     * Check if byte at position in array is a control or blank space byte
     *
     * @param b a byte array
     * @param pos a position in the byte array
     * @return true if byte at pos in array b is a control or blank space byte
     */
    public static boolean isControlOrBlankSpace(byte[] b, int pos) {
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">        if (b[pos] == ASCII_DEL || b[pos] &lt;= ASCII_SP) {</span>
<span class="fc" id="L141">            return true;</span>
        }
<span class="pc bpc" id="L143" title="5 of 6 branches missed.">        if (b[pos] == ASCII_B_LC &amp;&amp; pos &gt; 0 &amp;&amp; b[pos - 1] == ASCII_ESC) {</span>
<span class="nc" id="L144">            return true;</span>
        }

        // Check if the current pos is the first byte in a UTF-8 C1
        // control character (U+0080..U+009f).
<span class="fc" id="L149">        final int curr = b[pos] &amp; 0xff;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        final int next = (pos &lt; (b.length - 1)) ? (b[pos + 1] &amp; 0xff) : -1;</span>
<span class="pc bpc" id="L151" title="5 of 6 branches missed.">        if ((curr == 0xc2) &amp;&amp; (next &gt;= 0x80) &amp;&amp; (next &lt;= 0x9f)) {</span>
<span class="nc" id="L152">            return true;</span>
        }

        // Check if the current pos is the second byte in a UTF-8 C1
        // control character (U+0080..U+009f).
<span class="fc bfc" id="L157" title="All 2 branches covered.">        final int prev = (pos &gt; 0) ? (b[pos - 1] &amp; 0xff) : -1;</span>
<span class="pc bpc" id="L158" title="5 of 6 branches missed.">        return (prev == 0xc2) &amp;&amp; (curr &gt;= 0x80) &amp;&amp; (curr &lt;= 0x9f);</span>
    }

    /**
     * Glue two byte arrays together into one
     * 
     * @param a the first byte array
     * @param b the second byte array
     * @return the whole
     */
    public static byte[] glue(@Nullable byte[] a, @Nullable byte[] b) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (a == null) {</span>
<span class="fc" id="L170">            return b;</span>
        }
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (b == null) {</span>
<span class="fc" id="L173">            return a;</span>
        }
<span class="fc" id="L175">        return glue(a, 0, a.length - 1, b, 0, b.length - 1);</span>
    }

    /**
     * Glue three byte arrays together into one
     * 
     * @param a the first byte array
     * @param b the second byte array
     * @param c the third byte array
     * @return the whole
     */
    public static byte[] glue(@Nullable byte[] a, @Nullable byte[] b, @Nullable byte[] c) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (a == null) {</span>
<span class="fc" id="L188">            return glue(b, c);</span>
        }
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (b == null) {</span>
<span class="fc" id="L191">            return glue(a, c);</span>
        }
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (c == null) {</span>
<span class="fc" id="L194">            return glue(a, b);</span>
        }
<span class="fc" id="L196">        return glue(a, 0, a.length - 1, b, 0, b.length - 1, c, 0, c.length - 1);</span>
    }

    /**
     * Glue two byte arrays together into one
     * 
     * @param a the first byte array
     * @param astart starting position in a
     * @param aend ending position in a
     * @param b the second byte array
     * @param bstart starting position in b
     * @param bend ending position in b
     * @return the whole
     */
    @SuppressWarnings(&quot;InconsistentOverloads&quot;)
    public static byte[] glue(byte[] a, int astart, int aend, byte[] b, int bstart, int bend) {
<span class="fc" id="L212">        int alen = aend - astart + 1;</span>
<span class="fc" id="L213">        int blen = bend - bstart + 1;</span>

<span class="fc" id="L215">        byte[] rslt = new byte[alen + blen];</span>
<span class="fc" id="L216">        System.arraycopy(a, astart, rslt, 0, alen);</span>
<span class="fc" id="L217">        System.arraycopy(b, bstart, rslt, alen, blen);</span>
<span class="fc" id="L218">        return rslt;</span>
    }

    /**
     * Glue three byte arrays together into one
     * 
     * @param a the first byte array
     * @param astart starting position in a
     * @param aend ending position in a
     * @param b the second byte array
     * @param bstart starting position in b
     * @param bend ending position in b
     * @param c the third byte array
     * @param cstart starting position in c
     * @param cend ending position in c
     * @return the whole
     */
    @SuppressWarnings(&quot;InconsistentOverloads&quot;)
    public static byte[] glue(byte[] a, int astart, int aend, byte[] b, int bstart, int bend, byte[] c, int cstart, int cend) {
<span class="fc" id="L237">        int alen = aend - astart + 1;</span>
<span class="fc" id="L238">        int blen = bend - bstart + 1;</span>
<span class="fc" id="L239">        int clen = cend - cstart + 1;</span>

<span class="fc" id="L241">        byte[] rslt = new byte[alen + blen + clen];</span>
<span class="fc" id="L242">        System.arraycopy(a, astart, rslt, 0, alen);</span>
<span class="fc" id="L243">        System.arraycopy(b, bstart, rslt, alen, blen);</span>
<span class="fc" id="L244">        System.arraycopy(c, cstart, rslt, alen + blen, clen);</span>
<span class="fc" id="L245">        return rslt;</span>
    }

    /**
     * Split a byte array at the specified position
     * 
     * @param a the byte array
     * @param pos the split position (a[pos] goes to the second part)
     */
    public static List&lt;byte[]&gt; split(@Nullable byte[] a, int pos) {
<span class="fc" id="L255">        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L256" title="All 6 branches covered.">        if (a != null &amp;&amp; pos &gt; 0 &amp;&amp; pos &lt;= a.length) {</span>
<span class="fc" id="L257">            byte[] part1 = new byte[pos];</span>
<span class="fc" id="L258">            byte[] part2 = new byte[a.length - pos];</span>
<span class="fc" id="L259">            System.arraycopy(a, 0, part1, 0, pos);</span>
<span class="fc" id="L260">            System.arraycopy(a, pos, part2, 0, part2.length);</span>
<span class="fc" id="L261">            list.add(part1);</span>
<span class="fc" id="L262">            list.add(part2);</span>
<span class="fc" id="L263">        } else {</span>
            // Just give back the original
<span class="fc" id="L265">            list.add(a);</span>
        }
<span class="fc" id="L267">        return list;</span>
    }

    /**
     * Given a byte-array and a start offset, return a string of the bytes between the start position and a carriage return
     * byte. In essence, this is grabbing a line of input where the byte array is composed of several lines of input.
     * 
     * @param data The byte array of input data.
     * @param pos The initial start offset.
     * @return A string created from the bytes found from the start offset to the carriage return byte.
     */
    public static String grabLine(byte[] data, int pos) {
<span class="fc" id="L279">        String ret = null;</span>
<span class="fc" id="L280">        int eolnPos = -1;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (int i = pos; i &lt; data.length; i++) {</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (data[i] == '\n') {</span>
<span class="fc" id="L283">                eolnPos = i;</span>
<span class="fc" id="L284">                break;</span>
            }
        }
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (eolnPos != -1) {</span>
            // String up to the found \n pos
<span class="fc" id="L289">            ret = new String(data, pos, eolnPos - pos + 1);</span>
        } else {
            // String to end of buffer
<span class="fc" id="L292">            ret = new String(data, pos, data.length - pos);</span>
        }
<span class="fc" id="L294">        return ret;</span>
    }

    /**
     * Scans a byte array looking for non-printable values.
     * 
     * @param bytes the bytes to be scanned.
     * @return whether or not there were non-printable values.
     */
    public static boolean hasNonPrintableValues(final byte[] bytes) {
<span class="fc" id="L304">        boolean badCharacters = false;</span>

<span class="fc bfc" id="L306" title="All 2 branches covered.">        for (byte aByte : bytes) {</span>
<span class="pc bpc" id="L307" title="1 of 6 branches missed.">            if (aByte &lt; 9 || (aByte &gt; 13 &amp;&amp; aByte &lt; 32)) {</span>
<span class="fc" id="L308">                badCharacters = true;</span>
<span class="fc" id="L309">                break;</span>
            }
        }

<span class="fc" id="L313">        return badCharacters;</span>
    }

    /**
     * Creates a hex string of a sha256 hash for a byte[].
     * 
     * @param bytes to be hashed
     * @return the hex string of a sha256 hash of the bytes.
     */
    @Nullable
    public static String sha256Bytes(final byte[] bytes) {
        try {
<span class="fc" id="L325">            final MessageDigest md = MessageDigest.getInstance(&quot;SHA-256&quot;);</span>
<span class="fc" id="L326">            final byte[] hash = md.digest(bytes);</span>

<span class="fc" id="L328">            final StringBuilder hexString = new StringBuilder(2 * hash.length);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            for (byte b : hash) {</span>
<span class="fc" id="L330">                final String hex = Integer.toHexString(0xff &amp; b);</span>

<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (hex.length() == 1) {</span>
<span class="fc" id="L333">                    hexString.append('0');</span>
                }
<span class="fc" id="L335">                hexString.append(hex);</span>
            }
<span class="fc" id="L337">            return hexString.toString();</span>
<span class="nc" id="L338">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L339">            return null;</span>
        }
    }

    /**
     * Check if the bytes contains a non-indexable characters
     *
     * @param utf8Bytes the bytes to be scanned
     * @return whether there were non-indexable characters
     */
    public static boolean containsNonIndexableBytes(final byte[] utf8Bytes) {
        // Wrap the byte array in a ByteArrayInputStream
<span class="fc" id="L351">        final InputStream inputStream = new ByteArrayInputStream(utf8Bytes);</span>
<span class="fc" id="L352">        return containsNonIndexableBytes(inputStream);</span>
    }

    /**
     * Check if the input stream contains a non-indexable characters
     *
     * @param inputStream the input stream to be scanned
     * @return whether there were non-indexable characters
     */
    public static boolean containsNonIndexableBytes(final InputStream inputStream) {
        // Create an InputStreamReader to read the bytes as characters
<span class="fc" id="L363">        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {</span>
            int codePoint;
            // Use the read() method of the InputStreamReader to read code points. The read() method automatically handles
            // surrogate pairs, returning a single code point even for characters represented by multiple code units.
<span class="fc bfc" id="L367" title="All 2 branches covered.">            while ((codePoint = reader.read()) != -1) {</span>
                // Check if the code point is indexable
<span class="fc bfc" id="L369" title="All 2 branches covered.">                if (isNotIndexable(codePoint)) {</span>
<span class="fc" id="L370">                    return true;</span>
                }
            }
<span class="fc" id="L373">            return false;</span>
<span class="pc" id="L374">        } catch (IOException e) {</span>
<span class="nc" id="L375">            return true;</span>
        }
    }

    /**
     * Check if the code point is a control character or surrogate pair
     * &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_block&quot;&gt;Unicode Block&lt;/a&gt;
     * &lt;a href=&quot;https://www.unicode.org/charts/PDF/U0000.pdf&quot;&gt;U0000&lt;/a&gt;
     * &lt;a href=&quot;https://www.unicode.org/charts/PDF/U2000.pdf&quot;&gt;U2000&lt;/a&gt;
     * &lt;a href=&quot;https://www.unicode.org/charts/PDF/U3000.pdf&quot;&gt;U3000&lt;/a&gt;
     * &lt;a href=&quot;https://www.unicode.org/charts/PDF/UFE70.pdf&quot;&gt;UFE70&lt;/a&gt;
     * &lt;a href=&quot;https://www.unicode.org/charts/PDF/UFFF0.pdf&quot;&gt;UFFF0&lt;/a&gt;
     *
     * @param codepoint numerical value that maps to a specific character to check
     * @return if code-point is a valid text character
     */
    private static boolean isNotIndexable(final int codepoint) {
<span class="pc bpc" id="L392" title="4 of 30 branches missed.">        return ('\u0000' &lt;= codepoint &amp;&amp; codepoint &lt;= '\u0008')</span>
                || ('\u000E' &lt;= codepoint &amp;&amp; codepoint &lt;= '\u001F')
                || ('\u007F' &lt;= codepoint &amp;&amp; codepoint &lt;= '\u009F')
                || ('\u2000' &lt;= codepoint &amp;&amp; codepoint &lt;= '\u200F')
                || ('\u2028' &lt;= codepoint &amp;&amp; codepoint &lt;= '\u202F')
                || ('\u205F' &lt;= codepoint &amp;&amp; codepoint &lt;= '\u206F')
                || codepoint == '\u3000'
                || codepoint == '\uFEFF'
                || codepoint == '\uFFFD';
    }

    /** This class is not meant to be instantiated. */
    private ByteUtil() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>