<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServiceProviderPlace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.place</a> &gt; <span class="el_source">ServiceProviderPlace.java</span></div><h1>ServiceProviderPlace.java</h1><pre class="source lang-java linenums">package emissary.place;

import emissary.config.ConfigEntry;
import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.core.EmissaryException;
import emissary.core.Family;
import emissary.core.Form;
import emissary.core.HDMobileAgent;
import emissary.core.IBaseDataObject;
import emissary.core.MobileAgent;
import emissary.core.Namespace;
import emissary.core.NamespaceException;
import emissary.core.ResourceException;
import emissary.core.ResourceWatcher;
import emissary.directory.DirectoryEntry;
import emissary.directory.DirectoryPlace;
import emissary.directory.EmissaryNode;
import emissary.directory.IDirectoryPlace;
import emissary.directory.KeyManipulator;
import emissary.directory.WildcardEntry;
import emissary.kff.KffDataObjectHandler;
import emissary.log.MDCConstants;
import emissary.parser.SessionParser;
import emissary.server.EmissaryServer;
import emissary.server.mvc.adapters.DirectoryAdapter;
import emissary.util.JMXUtil;

import com.codahale.metrics.Timer;
import jakarta.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

import static emissary.core.constants.Configurations.PLACE_NAME;
import static emissary.core.constants.Configurations.PLACE_RESOURCE_LIMIT_MILLIS;
import static emissary.core.constants.Configurations.SERVICE_COST;
import static emissary.core.constants.Configurations.SERVICE_DESCRIPTION;
import static emissary.core.constants.Configurations.SERVICE_KEY;
import static emissary.core.constants.Configurations.SERVICE_NAME;
import static emissary.core.constants.Configurations.SERVICE_PROXY;
import static emissary.core.constants.Configurations.SERVICE_PROXY_DENY;
import static emissary.core.constants.Configurations.SERVICE_QUALITY;
import static emissary.core.constants.Configurations.SERVICE_TYPE;

/**
 * Concrete instances of ServiceProviderPlace can be created by the emissary.admin.PlaceStarter and registered with the
 * emissary.directory.IDirectoryPlace to make their respective services available and a specified cost and quality
 * throughout the system.
 */
public abstract class ServiceProviderPlace implements IServiceProviderPlace,
        ServiceProviderPlaceMBean {

    /**
     * Container for all configuration parameters read from the configuration file for this place. The net result is that
     * many name value pairs are loaded from one or more files. See ServiceConfigGuide for details.
     *
     * @see emissary.config.ServiceConfigGuide
     */
    @Nullable
    protected Configurator configG;

<span class="fc" id="L75">    protected final List&lt;String&gt; configLocs = new ArrayList&lt;&gt;();</span>

    /**
     * A &lt;i&gt;&lt;b&gt;local&lt;/b&gt;&lt;/i&gt; reference to the directory that this place resides in. Every JVM that contains 'places' must
     * have a local directory
     *
     * @see emissary.directory.DirectoryPlace
     */
    @Nullable
    protected String dirPlace;
<span class="fc" id="L85">    @Nullable</span>
    protected IDirectoryPlace localDirPlace = null;

    /**
     * set of keys for this place read from configG. Each of the values defined by
     * SERVICE_PROXY.SERCVICE_TYPE.SERVICE_NAME.PLACE_LOCATION$EXPENSE from the config file or KEY values from the config
     * file.
     */
<span class="fc" id="L93">    protected List&lt;String&gt; keys = new ArrayList&lt;&gt;();</span>

    /**
     * List of denied places in SERVICE_PROXY_DENY
     */
<span class="fc" id="L98">    protected List&lt;String&gt; denyList = new ArrayList&lt;&gt;();</span>

    // Items that are going to be deprecated, but here now to
    // make the transition easier, for compatibility
<span class="fc" id="L102">    @Nullable</span>
    protected String myKey = null;
<span class="fc" id="L104">    protected int serviceCost = -1;</span>
<span class="fc" id="L105">    protected int serviceQuality = -1;</span>
<span class="fc" id="L106">    @Nullable</span>
    protected String placeName = null;

    /**
     * Text description of what the place does, usually from config file
     */
    @Nullable
    protected String serviceDescription;

    protected String placeLocation;

    /**
     * Static context logger
     */
<span class="fc" id="L120">    protected static final Logger slogger = LoggerFactory.getLogger(ServiceProviderPlace.class);</span>

    /**
     * Dynamic context logger uses run-time classname as category
     */
    protected Logger logger;

    /**
     * Set up handler for rehashing
     */
<span class="fc" id="L130">    @Nullable</span>
    protected KffDataObjectHandler kff = null;

    private static final String DOT = &quot;.&quot;;
    private static final String UNUSED_PROXY = &quot;UNUSABLE-XyZZy&quot;;

    /**
     * These are used to track process vs processHD implementations to know whether one can proxy for the other one
     */
<span class="fc" id="L139">    protected boolean processMethodImplemented = false;</span>
<span class="fc" id="L140">    protected boolean heavyDutyMethodImplemented = false;</span>

    /**
     * Create a place and register it in the local directory. The default config must contain at least one SERVICE_KEY
     * element used to know where that is and how to name it. If the old style config with SERVICE_PROXY etc is used then
     * the PlaceName becomes the runtime class name of the instance without the package.
     */
    public ServiceProviderPlace() throws IOException {
<span class="fc" id="L148">        super();</span>
<span class="fc" id="L149">        String placeLocation = this.getClass().getSimpleName();</span>
<span class="fc" id="L150">        configG = loadConfigurator(placeLocation);</span>
<span class="fc" id="L151">        setupPlace(null, placeLocation);</span>
<span class="fc" id="L152">    }</span>

    /**
     * Create a place and register it at the location specified. The location key contains the name of the place which is
     * used to configure it. The local directory instance is found in the local Namespace.
     *
     * @param thePlaceLocation string name of our location
     */
    public ServiceProviderPlace(String thePlaceLocation) throws IOException {
<span class="fc" id="L161">        super();</span>
<span class="fc" id="L162">        configG = loadConfigurator(thePlaceLocation);</span>
<span class="fc" id="L163">        setupPlace(null, thePlaceLocation);</span>
<span class="fc" id="L164">    }</span>

    /**
     * Create the place the normal way
     *
     * @param configFile file name for config data
     * @param theDir string name of our directory
     * @param thePlaceLocation string name of our location
     */
    protected ServiceProviderPlace(String configFile, @Nullable String theDir, String thePlaceLocation) throws IOException {
<span class="fc" id="L174">        super();</span>
<span class="fc" id="L175">        configG = loadConfigurator(configFile, thePlaceLocation);</span>
<span class="fc" id="L176">        setupPlace(theDir, thePlaceLocation);</span>
<span class="fc" id="L177">    }</span>

    /**
     * Construct with config data from a stream
     *
     * @param configStream stream of config data
     * @param theDir string name of our directory
     * @param thePlaceLocation string name of our location
     */
    protected ServiceProviderPlace(InputStream configStream, @Nullable String theDir, String thePlaceLocation) throws IOException {
<span class="fc" id="L187">        super();</span>
<span class="fc" id="L188">        configG = loadConfigurator(configStream, thePlaceLocation);</span>
<span class="fc" id="L189">        setupPlace(theDir, thePlaceLocation);</span>
<span class="fc" id="L190">    }</span>

    /**
     * Construct with config data from a stream on the local directory
     *
     * @param configStream stream of config data
     */
    protected ServiceProviderPlace(InputStream configStream) throws IOException {
<span class="fc" id="L198">        super();</span>
<span class="fc" id="L199">        String placeLocation = this.getClass().getSimpleName();</span>
<span class="fc" id="L200">        configG = loadConfigurator(configStream, placeLocation);</span>
<span class="fc" id="L201">        setupPlace(null, placeLocation);</span>
<span class="fc" id="L202">    }</span>

    /**
     * Create the place with no directory
     *
     * @param configFile string name of config data file
     * @param placeLocation string name of our location
     */
    protected ServiceProviderPlace(String configFile, String placeLocation) throws IOException {
<span class="fc" id="L211">        this(configFile, null, placeLocation);</span>
<span class="fc" id="L212">    }</span>


    /**
     * Create the place with no directory
     *
     * @param configStream stream of config data
     * @param placeLocation string name of our location
     */
    protected ServiceProviderPlace(InputStream configStream, String placeLocation) throws IOException {
<span class="fc" id="L222">        this(configStream, null, placeLocation);</span>
<span class="fc" id="L223">    }</span>

    /**
     * Create the place based on another ServiceProviderPlace
     *
     * @param place the ServiceProviderRefreshablePlace to clone
     */
    protected ServiceProviderPlace(final ServiceProviderPlace place) {
<span class="fc" id="L231">        super();</span>
<span class="fc" id="L232">    }</span>

    /**
     * Load the configurator
     *
     * @param configStream the stream to use or null to autoconfigure
     * @param placeLocation string name of our location
     */
    protected Configurator loadConfigurator(@Nullable InputStream configStream, String placeLocation) throws IOException {
        // Read the configuration stream
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (configStream != null) {</span>
            // Use supplied stream
<span class="fc" id="L244">            return ConfigUtil.getConfigInfo(configStream);</span>
        }
<span class="fc" id="L246">        return loadConfigurator(placeLocation);</span>
    }

    /**
     * Load the configurator
     *
     * @param configFileName the file name to use or null to autoconfigure
     * @param placeLocation string name of our location
     */
    protected Configurator loadConfigurator(@Nullable String configFileName, String placeLocation) throws IOException {
        // Read the configuration stream
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (configFileName != null) {</span>
            // Use supplied stream
<span class="fc" id="L259">            return ConfigUtil.getConfigInfo(configFileName);</span>
        }
<span class="fc" id="L261">        return loadConfigurator(placeLocation);</span>
    }

    /**
     * Load the configurator, figuring out whence automatically
     *
     * @param placeLocation string name of our location
     */
    protected Configurator loadConfigurator(@Nullable String placeLocation) throws IOException {
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (placeLocation == null) {</span>
<span class="fc" id="L271">            placeLocation = this.getClass().getSimpleName();</span>
        }
<span class="fc" id="L273">        this.placeLocation = placeLocation;</span>
        // Extract config data stream name from place location
        // and try finding config info with and without the
        // package name of this class (in that order)
<span class="fc" id="L277">        String myPackage = this.getClass().getPackage().getName();</span>
        // Dont use KeyManipulator for this, only works when hostname/fqdn has dots
<span class="fc" id="L279">        int pos = placeLocation.lastIndexOf(&quot;/&quot;);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        String serviceClass = pos &gt; -1 ? placeLocation.substring(pos + 1) : placeLocation;</span>
<span class="fc" id="L281">        configLocs.add(myPackage + DOT + serviceClass + ConfigUtil.CONFIG_FILE_ENDING);</span>
<span class="fc" id="L282">        configLocs.add(serviceClass + ConfigUtil.CONFIG_FILE_ENDING);</span>
<span class="fc" id="L283">        return ConfigUtil.getConfigInfo(configLocs);</span>
    }

    /**
     * Help the constructor get the place running
     *
     * @param theDir key for the directory to use, if null will look up default name
     * @param placeLocation string name of our location
     */
    protected void setupPlace(@Nullable String theDir, String placeLocation) throws IOException {
<span class="fc" id="L293">        setupPlace(theDir, placeLocation, true);</span>
<span class="fc" id="L294">    }</span>

    /**
     * Help the constructor get the place running
     *
     * @param theDir key for the directory to use, if null will look up default name
     * @param placeLocation the location of the place
     * @param register register the newly constructed place with our directory
     */
    protected void setupPlace(@Nullable String theDir, String placeLocation, boolean register) throws IOException {

        // Customize the logger to the runtime class
<span class="fc" id="L306">        logger = LoggerFactory.getLogger(this.getClass());</span>

        // The order of the following initialization calls
        // is touchy. NPE all over if you mess up here.

<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (register) {</span>
            // Set ServicePlace config items
<span class="fc" id="L313">            configureServicePlace(placeLocation);</span>
        }

        // Backwards compatibility setup items
<span class="fc" id="L317">        DirectoryEntry firstentry = new DirectoryEntry(keys.get(0));</span>
<span class="fc" id="L318">        myKey = firstentry.getKey();</span>
<span class="fc" id="L319">        serviceCost = firstentry.getCost();</span>
<span class="fc" id="L320">        serviceQuality = firstentry.getQuality();</span>
<span class="fc" id="L321">        placeName = firstentry.getServiceLocation();</span>


        // configure directory references
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (!(this instanceof DirectoryPlace)) {</span>
<span class="fc" id="L326">            localizeDirectory(theDir);</span>
<span class="fc" id="L327">            logger.debug(&quot;Our localizedDirectory is {}&quot;, dirPlace);</span>
        } else {
<span class="fc" id="L329">            logger.debug(&quot;Not localizing directory since we are a directory&quot;);</span>
        }

        // Set up kff if we need it
<span class="fc bfc" id="L333" title="All 4 branches covered.">        if (this instanceof RehashingPlace || this instanceof MultiFileServerPlace) {</span>
<span class="fc" id="L334">            initKff();</span>
        }

        // Bind to the namespace before registering
        // our keys. This allows incoming traffic to find
        // us as soon as they see the keys
<span class="fc bfc" id="L340" title="All 2 branches covered.">        for (String key : keys) {</span>
<span class="fc" id="L341">            String bindKey = KeyManipulator.getServiceLocation(key);</span>
<span class="fc" id="L342">            logger.debug(&quot;Binding myself into the namespace as {}&quot;, bindKey);</span>
<span class="fc" id="L343">            Namespace.bind(bindKey, this);</span>
<span class="fc" id="L344">        }</span>

<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (register) {</span>
            // Register with the directory
<span class="fc" id="L348">            register();</span>
        }

        // register MBean with JMX
<span class="fc" id="L352">        JMXUtil.registerMBean(this);</span>

        // Verify and warn of incorrect process/processHeavyDuty implementation
<span class="fc" id="L355">        verifyProcessImplementationProvided();</span>
<span class="fc" id="L356">    }</span>

    /**
     * Get a local reference to the directory.
     *
     * @param theDir key for the directory to use, if null will look up default name
     * @return true if it worked
     */
    private boolean localizeDirectory(@Nullable String theDir) {
        // Get a local (non-proxy) copy of the directory if possible!
        // Looking up both if nothing is provided
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (theDir == null) {</span>
            try {
<span class="nc" id="L369">                localDirPlace = DirectoryPlace.lookup();</span>
<span class="nc" id="L370">                dirPlace = localDirPlace.toString();</span>
<span class="fc" id="L371">            } catch (EmissaryException ex) {</span>
<span class="pc bpc" id="L372" title="3 of 4 branches missed.">                if (EmissaryServer.getInstance().isServerRunning() &amp;&amp; !(this instanceof DirectoryPlace)) {</span>
<span class="nc" id="L373">                    logger.warn(&quot;Unable to find DirectoryPlace in local namespace&quot;, ex);</span>
<span class="nc" id="L374">                    return false;</span>
                }
<span class="pc" id="L376">            }</span>
        } else {
<span class="fc" id="L378">            dirPlace = theDir;</span>
<span class="fc" id="L379">            localDirPlace = null;</span>
            try {
<span class="fc" id="L381">                String myUrl = KeyManipulator.getServiceHostUrl(keys.get(0));</span>
<span class="fc" id="L382">                String dirUrl = KeyManipulator.getServiceHostUrl(dirPlace);</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                if (StringUtils.equals(dirUrl, myUrl)) {</span>
<span class="nc" id="L384">                    localDirPlace = (IDirectoryPlace) Namespace.lookup(KeyManipulator.getServiceLocation(theDir));</span>
                } else {
<span class="nc" id="L386">                    logger.debug(&quot;Not localizing directory since dirPlace {} is not equal to myUrl {}&quot;, dirPlace, myUrl);</span>
                }
<span class="fc" id="L388">            } catch (EmissaryException ex) {</span>
<span class="fc" id="L389">                logger.error(&quot;Exception attempting to get local reference to directory&quot;, ex);</span>
<span class="fc" id="L390">                return false;</span>
<span class="nc" id="L391">            }</span>
        }
<span class="fc" id="L393">        return true;</span>
    }

    /**
     * Initialize the Kff Handler with our policy settings
     */
    protected synchronized void initKff() {
<span class="fc" id="L400">        kff =</span>
                new KffDataObjectHandler(KffDataObjectHandler.TRUNCATE_KNOWN_DATA, KffDataObjectHandler.SET_FORM_WHEN_KNOWN,
                        KffDataObjectHandler.SET_FILE_TYPE);
<span class="fc" id="L403">    }</span>

    /**
     * Set the logger to use, allows easier mocking among other things
     *
     * @param l the logger instance to use
     */
    public void setLogger(Logger l) {
<span class="fc" id="L411">        this.logger = l;</span>
<span class="fc" id="L412">    }</span>

    /**
     * Return an encapsulation of our key and cost structure Only good for the top key on the list
     *
     * @return a DirectoryEntry for this place
     */
    @Override
    public DirectoryEntry getDirectoryEntry() {
<span class="fc" id="L421">        return new DirectoryEntry(keys.get(0), serviceDescription, serviceCost, serviceQuality);</span>
    }

    /**
     * Configuration items read here are:
     *
     * &lt;ul&gt;
     * &lt;li&gt;PLACE_NAME: place name portion of key, required&lt;/li&gt;
     * &lt;li&gt;SERVICE_NAME: service name portion of key, required&lt;/li&gt;
     * &lt;li&gt;SERVICE_TYPE: service type portion of key, required&lt;/li&gt;
     * &lt;li&gt;SERVICE_DESCRIPTION: description of place, required&lt;/li&gt;
     * &lt;li&gt;SERVICE_COST: cost of service provided, required&lt;/li&gt;
     * &lt;li&gt;SERVICE_QUALITY: quality of service provided, required&lt;/li&gt;
     * &lt;li&gt;SERVICE_PROXY: list of service proxy types for key&lt;/li&gt;
     * &lt;li&gt;SERVICE_KEY: full 4 part keys with expense&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param placeLocation the specified placeLocation or a full four part key to register with
     */
    protected void configureServicePlace(@Nullable String placeLocation) throws IOException {
<span class="fc" id="L441">        serviceDescription = configG.findStringEntry(SERVICE_DESCRIPTION);</span>
<span class="pc bpc" id="L442" title="1 of 4 branches missed.">        if (serviceDescription == null || serviceDescription.length() == 0) {</span>
<span class="fc" id="L443">            serviceDescription = &quot;Description not available&quot;;</span>
        }

<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (placeLocation == null) {</span>
<span class="fc" id="L447">            placeLocation = this.getClass().getSimpleName();</span>
        }

<span class="fc" id="L450">        String locationPart = placeLocation;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (KeyManipulator.isKeyComplete(placeLocation)) {</span>
<span class="fc" id="L452">            keys.add(placeLocation); // save as first in list</span>
<span class="fc" id="L453">            locationPart = KeyManipulator.getServiceLocation(placeLocation);</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        } else if (!placeLocation.contains(&quot;://&quot;)) {</span>
<span class="fc" id="L455">            EmissaryNode node = EmissaryServer.getInstance().getNode();</span>
<span class="fc" id="L456">            locationPart = &quot;http://&quot; + node.getNodeName() + &quot;:&quot; + node.getNodePort() + &quot;/&quot; + placeLocation;</span>
        }


        // Build keys the old fashioned way from parts specified in the config
<span class="fc" id="L461">        String placeName = configG.findStringEntry(PLACE_NAME);</span>
<span class="fc" id="L462">        String serviceName = configG.findStringEntry(SERVICE_NAME);</span>
<span class="fc" id="L463">        String serviceType = configG.findStringEntry(SERVICE_TYPE);</span>
<span class="fc" id="L464">        int serviceCost = configG.findIntEntry(SERVICE_COST, -1);</span>
<span class="fc" id="L465">        int serviceQuality = configG.findIntEntry(SERVICE_QUALITY, -1);</span>

        // Bah.
<span class="pc bpc" id="L468" title="1 of 4 branches missed.">        if (placeName != null &amp;&amp; placeName.length() == 0) {</span>
<span class="nc" id="L469">            placeName = null;</span>
        }
<span class="pc bpc" id="L471" title="1 of 4 branches missed.">        if (serviceName != null &amp;&amp; serviceName.length() == 0) {</span>
<span class="nc" id="L472">            serviceName = null;</span>
        }
<span class="pc bpc" id="L474" title="1 of 4 branches missed.">        if (serviceType != null &amp;&amp; serviceType.length() == 0) {</span>
<span class="nc" id="L475">            serviceType = null;</span>
        }

<span class="pc bpc" id="L478" title="2 of 10 branches missed.">        if (placeName != null &amp;&amp; serviceName != null &amp;&amp; serviceType != null &amp;&amp; serviceCost &gt; -1 &amp;&amp; serviceQuality &gt; -1) {</span>
            // pick up the proxies(save full 4-tuple keys!)
<span class="fc bfc" id="L480" title="All 2 branches covered.">            for (String sp : configG.findEntries(SERVICE_PROXY)) {</span>
<span class="fc" id="L481">                DirectoryEntry de = new DirectoryEntry(sp, serviceName, serviceType, locationPart, serviceDescription, serviceCost, serviceQuality);</span>
<span class="fc" id="L482">                keys.add(de.getFullKey());</span>
<span class="fc" id="L483">            }</span>
            // pick up the denied proxies(save full 4-tuple keys!)
<span class="fc bfc" id="L485" title="All 2 branches covered.">            for (String sp : configG.findEntries(SERVICE_PROXY_DENY)) {</span>
<span class="fc" id="L486">                DirectoryEntry de = new DirectoryEntry(sp, serviceName, serviceType, locationPart, serviceDescription, serviceCost, serviceQuality);</span>
<span class="fc" id="L487">                denyList.add(de.getDataType());</span>
<span class="fc" id="L488">            }</span>
        } else {
            // May be configured the new way, but warn if there is a mixture of
            // null and non-null items using the old-fashioned way. Perhaps the
            // user just missed one of them
<span class="fc" id="L493">            int nullCount = 0;</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (placeName == null) {</span>
<span class="fc" id="L495">                nullCount++;</span>
            }
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (serviceName == null) {</span>
<span class="fc" id="L498">                nullCount++;</span>
            }
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (serviceType == null) {</span>
<span class="fc" id="L501">                nullCount++;</span>
            }
<span class="fc bfc" id="L503" title="All 2 branches covered.">            if (serviceCost == -1) {</span>
<span class="fc" id="L504">                nullCount++;</span>
            }
<span class="fc bfc" id="L506" title="All 2 branches covered.">            if (serviceQuality == -1) {</span>
<span class="fc" id="L507">                nullCount++;</span>
            }

<span class="pc bpc" id="L510" title="1 of 4 branches missed.">            if (nullCount &gt; 0 &amp;&amp; nullCount &lt; 5) {</span>
<span class="fc" id="L511">                throw new IOException(</span>
                        &quot;Missing configuration items. Please check SERVICE_NAME, SERVICE_TYPE, PLACE_NAME, SERVICE_COST, SERVICE_QUALITY&quot;);

            }
        }

        // Now build any keys the new way
<span class="fc bfc" id="L518" title="All 2 branches covered.">        for (String k : configG.findEntries(SERVICE_KEY)) {</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (KeyManipulator.isKeyComplete(k)) {</span>
<span class="fc" id="L520">                keys.add(k);</span>
            } else {
<span class="fc" id="L522">                logger.warn(&quot;SERVICE_KEY '{}' is missing parts and cannot be used&quot;, k);</span>
            }
<span class="fc" id="L524">        }</span>

        // Make sure some keys were defined one way or the other
<span class="fc bfc" id="L527" title="All 2 branches covered.">        if (keys.isEmpty()) {</span>
<span class="fc" id="L528">            throw new IOException(&quot;NO keys were defined. Please configure at least one &quot;</span>
                    + &quot;SERVICE_KEY or SERVICE_NAME/SERVICE_TYPE/SERVICE_PROXY group&quot;);
        }
<span class="fc" id="L531">    }</span>

    /**
     * Delegate nextKey to our directory
     *
     * @param dataId key to entryMap in directory, dataType::serviceType
     * @param lastEntry place agent visited last, this is not stateless
     * @return List of DirectoryEntry with next places to go
     */
    @Override
    @Nullable
    public List&lt;DirectoryEntry&gt; nextKeys(final String dataId, final IBaseDataObject payload, final DirectoryEntry lastEntry) {
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (localDirPlace != null) {</span>
<span class="nc" id="L544">            return localDirPlace.nextKeys(dataId, payload, lastEntry);</span>
        }
<span class="fc" id="L546">        logger.error(&quot;No local directory in place {} with dir={}&quot;, keys.get(0), dirPlace);</span>
<span class="fc" id="L547">        return null;</span>
    }

    /**
     * The ServiceProviderPlace facade for visiting agents
     *
     * @param payload dataobject from a MobileAgent
     */
    @Override
    public void agentProcessCall(IBaseDataObject payload) throws ResourceException {
        try {
<span class="fc" id="L558">            process(payload);</span>
<span class="fc" id="L559">            rehash(payload);</span>
<span class="nc" id="L560">        } catch (ResourceException r) {</span>
<span class="nc" id="L561">            throw r;</span>
<span class="nc" id="L562">        } catch (RuntimeException e) {</span>
<span class="nc" id="L563">            logger.error(&quot;Place.process exception&quot;, e);</span>
<span class="fc" id="L564">        }</span>
<span class="fc" id="L565">    }</span>

    /**
     * &quot;HD&quot; agent calls this method when visiting the place. If you use emissary.core.MobileAgent this method is never
     * called. Should be overridden by concrete places that wish to process bulk data in a different manner than one payload
     * at a time.
     *
     * @param payloadList list of IBaseDataObject from an HDMobileAgent
     * @return list of IBaseDataObject &quot;sprouts&quot;
     */
    @Override
    public List&lt;IBaseDataObject&gt; agentProcessHeavyDuty(List&lt;IBaseDataObject&gt; payloadList) throws Exception {

<span class="fc" id="L578">        logger.debug(&quot;Entering agentProcessHeavyDuty with {} payload items&quot;, payloadList.size());</span>

<span class="fc" id="L580">        List&lt;IBaseDataObject&gt; list = new ArrayList&lt;&gt;();</span>

        // For each incoming payload object
<span class="fc bfc" id="L583" title="All 2 branches covered.">        for (IBaseDataObject dataObject : payloadList) {</span>
            try {
                // Process the payload item
<span class="fc" id="L586">                List&lt;IBaseDataObject&gt; l = agentProcessHeavyDuty(dataObject);</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                if (!l.isEmpty()) {</span>
<span class="nc" id="L588">                    dataObject.setNumChildren(dataObject.getNumChildren() + l.size());</span>
                }

                // Accumulate results in a list to return
<span class="fc" id="L592">                list.addAll(l);</span>
<span class="nc" id="L593">            } catch (Exception e) {</span>
<span class="nc" id="L594">                logger.error(&quot;Place.process exception&quot;, e);</span>
<span class="nc" id="L595">                dataObject.addProcessingError(&quot;agentProcessHD(&quot; + keys.get(0) + &quot;): &quot; + e);</span>
<span class="nc" id="L596">                dataObject.replaceCurrentForm(Form.ERROR);</span>
<span class="fc" id="L597">            }</span>
<span class="fc" id="L598">        }</span>

        // Some debug output
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            for (IBaseDataObject d : list) {</span>
<span class="nc" id="L603">                logger.debug(&quot;Returning child {} -&gt; {}&quot;, d.shortName(), d.getAllCurrentForms());</span>
<span class="nc" id="L604">            }</span>
        }

<span class="fc" id="L607">        return list;</span>
    }

    /**
     * &quot;HD&quot; method called only by HDMobileAgent for a single incoming payload
     *
     * @param payload data object to process
     * @return List of IBaseDataObject &quot;sprouts&quot;
     */
    @Override
    public List&lt;IBaseDataObject&gt; agentProcessHeavyDuty(IBaseDataObject payload) throws Exception {
<span class="fc" id="L618">        MDC.put(MDCConstants.SHORT_NAME, payload.shortName());</span>
<span class="fc" id="L619">        MDC.put(MDCConstants.SERVICE_LOCATION, this.getKey());</span>
        try {
<span class="fc" id="L621">            List&lt;IBaseDataObject&gt; l = processHeavyDuty(payload);</span>
<span class="fc" id="L622">            rehash(payload);</span>
<span class="fc" id="L623">            return l;</span>
<span class="nc" id="L624">        } catch (Exception e) {</span>
<span class="nc" id="L625">            logger.error(&quot;Place.process threw:&quot;, e);</span>
<span class="nc" id="L626">            throw e;</span>
        }
    }

    /**
     * Rehash the payload if this is a rehashing place
     *
     * @param payload the payload to evaluate and rehash
     */
    protected void rehash(@Nullable IBaseDataObject payload) {
        // Recompute hash if marker interface is enabled
<span class="pc bpc" id="L637" title="2 of 6 branches missed.">        if (this instanceof RehashingPlace &amp;&amp; kff != null &amp;&amp; payload != null) {</span>
<span class="fc" id="L638">            kff.hash(payload);</span>
<span class="fc" id="L639">            payload.setParameter(SessionParser.ORIG_DOC_SIZE_KEY, &quot;&quot; + payload.dataLength());</span>
        }
<span class="fc" id="L641">    }</span>


    /**
     * Convenience method to process a single payload when there is no expecation of decomposing any new payload objects
     * from what was provided
     */
    @Override
    public void process(IBaseDataObject payload) throws ResourceException {
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (heavyDutyMethodImplemented) {</span>
<span class="fc" id="L651">            List&lt;IBaseDataObject&gt; children = processHeavyDuty(payload);</span>
<span class="pc bpc" id="L652" title="2 of 4 branches missed.">            if (children != null &amp;&amp; !children.isEmpty()) {</span>
<span class="nc" id="L653">                logger.error(&quot;Sprouting is no longer supported, lost {} children&quot;, children.size());</span>
            }
<span class="fc" id="L655">        } else {</span>
<span class="nc" id="L656">            throw new IllegalStateException(&quot;Neither process nor processHeavyDuty appears to be implemented&quot;);</span>
        }
<span class="fc" id="L658">    }</span>

    /**
     * Process a payload and return a list of new items decomosed from it (or an empty list) What happens here and what is
     * ultimately expected depends on the workflow stage of the place registration, and the type of job it is expected to
     * do.
     *
     * @param payload the BaseDataObject to process
     * @return list of BaseDataObject that represent the children (if any)
     */
    @Override
    public List&lt;IBaseDataObject&gt; processHeavyDuty(IBaseDataObject payload) throws ResourceException {
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">        if (processMethodImplemented) {</span>
<span class="fc" id="L671">            process(payload);</span>
<span class="fc" id="L672">            return Collections.emptyList();</span>
        } else {
<span class="nc" id="L674">            throw new IllegalStateException(&quot;Neither process nor processHeavyDuty appears to be implemented&quot;);</span>
        }
    }

    /**
     * This method must be called during setup of the place to ensure that one of the two implementations is provided by the
     * declaring class.
     */
    protected void verifyProcessImplementationProvided() {

<span class="fc" id="L684">        Class&lt;?&gt; c = this.getClass();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">        while (!c.isAssignableFrom(ServiceProviderPlace.class)) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">            for (Method m : c.getDeclaredMethods()) {</span>
<span class="fc" id="L687">                String mname = m.getName();</span>
<span class="fc" id="L688">                String rname = m.getReturnType().getName();</span>
<span class="fc" id="L689">                Class&lt;?&gt;[] params = m.getParameterTypes();</span>

<span class="fc bfc" id="L691" title="All 4 branches covered.">                if (params.length == 1 &amp;&amp; params[0].isAssignableFrom(IBaseDataObject.class)) {</span>
<span class="pc bpc" id="L692" title="1 of 4 branches missed.">                    if (mname.equals(&quot;process&quot;) &amp;&amp; rname.equals(&quot;void&quot;)) {</span>
<span class="fc" id="L693">                        processMethodImplemented = true;</span>
<span class="pc bpc" id="L694" title="1 of 4 branches missed.">                    } else if (mname.equals(&quot;processHeavyDuty&quot;) &amp;&amp; rname.equals(List.class.getName())) {</span>
<span class="fc" id="L695">                        heavyDutyMethodImplemented = true;</span>
                    }
                }
            }

<span class="fc bfc" id="L700" title="All 4 branches covered.">            if (heavyDutyMethodImplemented || processMethodImplemented) {</span>
<span class="fc" id="L701">                logger.debug(&quot;Found enough process implementation at level {}&quot;, c.getName());</span>
<span class="fc" id="L702">                break;</span>
            } else {
<span class="fc" id="L704">                c = c.getSuperclass();</span>
            }
        }

<span class="fc bfc" id="L708" title="All 6 branches covered.">        if (!processMethodImplemented &amp;&amp; !heavyDutyMethodImplemented &amp;&amp; !(this instanceof AgentsNotSupportedPlace)) {</span>
<span class="fc" id="L709">            logger.error(&quot;It appears that neither process nor processHeavyDuty is implemented. &quot;</span>
                    + &quot;If that is incorrect you can directly set one of the corresponding &quot;
                    + &quot;boolean flags or override verifyProcessImplementationProvided or &quot;
                    + &quot;implement AgentsNotSupported to turn this message off&quot;);
        }
<span class="fc" id="L714">    }</span>

    /**
     * Convenience method a lot of places use. Removes all items from the current form stack that this place has proxies for
     *
     * @param d a data object whose current form will be expunged of my proxies
     * @return count of how many items removed
     */
    protected int nukeMyProxies(IBaseDataObject d) {
<span class="fc" id="L723">        List&lt;String&gt; nukem = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L724">        int sz = d.currentFormSize();</span>
<span class="fc" id="L725">        Set&lt;String&gt; serviceProxies = getProxies();</span>

<span class="fc bfc" id="L727" title="All 2 branches covered.">        if (serviceProxies.contains(&quot;*&quot;)) {</span>
<span class="fc" id="L728">            d.replaceCurrentForm(null); // clear it out</span>
<span class="fc" id="L729">            return sz;</span>
        }

        // listem
<span class="fc bfc" id="L733" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc" id="L734">            String form = d.currentFormAt(i);</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">            if (serviceProxies.contains(form)) {</span>
<span class="fc" id="L736">                nukem.add(form);</span>
            } else {
                // cardem
<span class="fc" id="L739">                WildcardEntry wc = new WildcardEntry(form);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">                if (!Collections.disjoint(wc.asSet(), serviceProxies)) {</span>
<span class="fc" id="L741">                    nukem.add(form);</span>
                }
            }
        }

        // nukem
<span class="fc bfc" id="L747" title="All 2 branches covered.">        for (String f : nukem) {</span>
<span class="fc" id="L748">            int pos = d.searchCurrentForm(f);</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">            if (pos != -1) {</span>
<span class="fc" id="L750">                d.deleteCurrentFormAt(pos);</span>
            }
<span class="fc" id="L752">        }</span>

<span class="fc" id="L754">        return nukem.size();</span>
    }

    /**
     * Return a set of the service proxies
     *
     * @return set of string values
     */
    @Override
    public Set&lt;String&gt; getProxies() {
<span class="fc" id="L764">        Set&lt;String&gt; s = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        for (String k : keys) {</span>
<span class="fc" id="L766">            s.add(KeyManipulator.getDataType(k));</span>
<span class="fc" id="L767">        }</span>
<span class="fc" id="L768">        s.remove(UNUSED_PROXY);</span>
<span class="fc" id="L769">        return s;</span>
    }

    /**
     * Get the keys that this place instance is registered with
     */
    @Override
    public Set&lt;String&gt; getKeys() {
<span class="fc" id="L777">        Set&lt;String&gt; s = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">        for (String k : keys) {</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            if (!k.startsWith(UNUSED_PROXY)) {</span>
<span class="fc" id="L780">                s.add(k);</span>
            }
<span class="fc" id="L782">        }</span>
<span class="fc" id="L783">        return s;</span>
    }

    /**
     * Return the first service proxy on the list
     *
     * @return SERVICE_PROXY value from first key on list
     */
    @Override
    public String getPrimaryProxy() {
<span class="fc" id="L793">        String s = KeyManipulator.getDataType(keys.get(0));</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (s.equals(UNUSED_PROXY)) {</span>
<span class="fc" id="L795">            s = &quot;&quot;;</span>
        }
<span class="fc" id="L797">        return s;</span>
    }


    /**
     * Key for string form
     */
    @Override
    public String toString() {
<span class="fc" id="L806">        return keys.get(0) + &quot;[&quot; + keys.size() + &quot;]&quot;;</span>
    }

    /**
     * Fulfill IServiceProviderPlace
     */
    @Override
    public String getKey() {
<span class="fc" id="L814">        return KeyManipulator.removeExpense(keys.get(0));</span>
    }

    /**
     * Add a service proxy to a running place. Duplicates are ignored.
     *
     * @param serviceProxy the new proxy string to add
     */
    @Override
    public void addServiceProxy(String serviceProxy) {
        // Add new one to the top key in the list
<span class="fc" id="L825">        DirectoryEntry de = new DirectoryEntry(keys.get(0));</span>
<span class="fc" id="L826">        boolean keyAdded = false;</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">        if (!de.getDataType().equals(serviceProxy)) {</span>
            // Clear out the placeholder
<span class="fc bfc" id="L829" title="All 2 branches covered.">            if (de.getDataType().equals(UNUSED_PROXY)) {</span>
<span class="fc" id="L830">                keys.remove(0);</span>
            }

<span class="fc" id="L833">            de.setDataType(serviceProxy);</span>

<span class="fc bfc" id="L835" title="All 2 branches covered.">            if (!keys.contains(de.getFullKey())) {</span>
<span class="fc" id="L836">                keys.add(de.getFullKey());</span>

                // Register the new proxy in the directory
<span class="fc" id="L839">                logger.debug(&quot;Registering new key {}&quot;, de.getKey());</span>
<span class="fc" id="L840">                register(de.getFullKey());</span>
<span class="fc" id="L841">                keyAdded = true;</span>
            }
        }

<span class="fc bfc" id="L845" title="All 2 branches covered.">        if (!keyAdded) {</span>
<span class="fc" id="L846">            logger.debug(&quot;Duplicate service proxy {} ignored&quot;, serviceProxy);</span>
        }
<span class="fc" id="L848">    }</span>

    /**
     * Add another key to the place
     *
     * @param key the key to add
     */
    @Override
    public void addKey(String key) {
<span class="fc bfc" id="L857" title="All 2 branches covered.">        if (KeyManipulator.isValid(key)) {</span>
<span class="fc" id="L858">            DirectoryEntry de = new DirectoryEntry(keys.get(0));</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">            if (de.getDataType().equals(UNUSED_PROXY)) {</span>
<span class="nc" id="L860">                keys.remove(0);</span>
            }

<span class="fc" id="L863">            logger.debug(&quot;Adding and registering new key {}&quot;, key);</span>
<span class="fc" id="L864">            keys.add(key);</span>
<span class="fc" id="L865">            register(key);</span>
<span class="fc" id="L866">        } else {</span>
<span class="fc" id="L867">            logger.warn(&quot;Invalid key cannot be added: {}&quot;, key);</span>
        }
<span class="fc" id="L869">    }</span>

    /**
     * Register a single service proxy key
     *
     * @param key the new key to register
     */
    protected void register(String key) {
<span class="fc" id="L877">        logger.debug(&quot;Registering key {}&quot;, key);</span>
        // Cannot register if we have no directory
        // If we are the directory, its no problem though
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        if (dirPlace == null) {</span>
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">            if (!(this instanceof IDirectoryPlace)) {</span>
<span class="fc" id="L882">                logger.debug(&quot;Directory is null: cannot register anything. Illegal configuration.&quot;);</span>
            }
<span class="fc" id="L884">            return;</span>
        }

        // Register place and all proxies by building up a list
        // of our interests to send to the directory
<span class="nc" id="L889">        List&lt;String&gt; keylist = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L890">        keylist.add(key);</span>
<span class="nc" id="L891">        registerWithDirectory(keylist);</span>
<span class="nc" id="L892">    }</span>

    /**
     * Register our interest in all of our serviceProxies Sends only one message to the directory to cover all service
     * proxies (a scalability issue for large systems)
     */
    protected void register() {
<span class="fc" id="L899">        logger.debug(&quot;Registering: {}&quot;, this);</span>

        // Cannot register if we have no directory
        // If we are the directory, its no problem though
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (dirPlace == null) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            if (!(this instanceof IDirectoryPlace)) {</span>
<span class="fc" id="L905">                logger.debug(&quot;Directory is null: cannot register anything. Illegal configuration.&quot;);</span>
            }
<span class="fc" id="L907">            return;</span>
        }

        // Register place and all proxies by building up a list
        // of our current interests to send to the directory
<span class="fc" id="L912">        registerWithDirectory(new ArrayList&lt;&gt;(keys));</span>
<span class="fc" id="L913">    }</span>

    /**
     * Register keys with the directory
     *
     * @param keylist the keys to register
     */
    protected void registerWithDirectory(List&lt;String&gt; keylist) {
        try {
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">            if (localDirPlace == null) {</span>
                // This should never happen, we require a local
                // directory on every JVM...
<span class="fc" id="L925">                logger.error(&quot;Key registration requires a DirectoryPlace in every Emissary Node&quot;);</span>
            } else {
<span class="nc" id="L927">                logger.debug(&quot;Registering my {} keys {}&quot;, keylist.size(), keylist);</span>
<span class="nc" id="L928">                localDirPlace.addPlaces(keylist);</span>
            }
<span class="nc" id="L930">        } catch (RuntimeException e) {</span>
<span class="nc" id="L931">            logger.warn(&quot;Register ERROR for keys {}&quot;, keylist, e);</span>
<span class="fc" id="L932">        }</span>
<span class="fc" id="L933">    }</span>


    /**
     * Deregister keys from the directory
     *
     * @param keys the keys to register
     */
    protected void deregisterFromDirectory(List&lt;String&gt; keys) {
        try {
<span class="pc bpc" id="L943" title="1 of 4 branches missed.">            if (localDirPlace == null &amp;&amp; dirPlace != null) {</span>
                // This should never happen, we require a local
                // directory on every JVM...
<span class="fc" id="L946">                logger.debug(&quot;Deregistering my {} proxies {} from remote dir {}&quot;, keys.size(), keys, dirPlace);</span>
<span class="fc" id="L947">                DirectoryAdapter da = new DirectoryAdapter();</span>
<span class="fc" id="L948">                da.outboundRemovePlaces(dirPlace, keys, false);</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">            } else if (localDirPlace != null) {</span>
<span class="nc" id="L950">                logger.debug(&quot;Deregistering my {} proxies {}&quot;, keys.size(), keys);</span>
<span class="nc" id="L951">                localDirPlace.removePlaces(keys);</span>
            }
<span class="nc" id="L953">        } catch (RuntimeException e) {</span>
<span class="nc" id="L954">            logger.warn(&quot;Deregister ERROR keys={}&quot;, keys, e);</span>
<span class="fc" id="L955">        }</span>
<span class="fc" id="L956">    }</span>

    /**
     * Remove a service proxy from the running place. Proxy strings not found registered will be ignored Will remove all
     * keys that match the supplied proxy
     *
     * @param serviceProxy the proxy string to remove
     */
    @Override
    public void removeServiceProxy(String serviceProxy) {
        // List of keys to deregister
<span class="fc" id="L967">        List&lt;String&gt; keylist = new ArrayList&lt;&gt;();</span>

        // nb. no enhanced for loop due to remove
<span class="fc bfc" id="L970" title="All 2 branches covered.">        for (Iterator&lt;String&gt; i = keys.iterator(); i.hasNext();) {</span>
<span class="fc" id="L971">            String k = i.next();</span>
<span class="fc" id="L972">            String kproxy = KeyManipulator.getDataType(k);</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">            if (kproxy.equals(serviceProxy)) {</span>
<span class="fc" id="L974">                keylist.add(KeyManipulator.removeExpense(k));</span>
<span class="fc" id="L975">                i.remove();</span>
            }
<span class="fc" id="L977">        }</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">        if (!keylist.isEmpty()) {</span>
<span class="fc" id="L979">            deregisterFromDirectory(keylist);</span>
        } else {
<span class="fc" id="L981">            logger.debug(&quot;Unknown service proxy {} ignored&quot;, serviceProxy);</span>
        }

        // Make sure we leave something on the keys list
<span class="pc bpc" id="L985" title="1 of 4 branches missed.">        if (keys.isEmpty() &amp;&amp; !keylist.isEmpty()) {</span>
<span class="fc" id="L986">            DirectoryEntry de = new DirectoryEntry(keylist.get(0));</span>
<span class="fc" id="L987">            de.setCost(serviceCost);</span>
<span class="fc" id="L988">            de.setQuality(serviceQuality);</span>
<span class="fc" id="L989">            de.setDataType(UNUSED_PROXY);</span>
<span class="fc" id="L990">            keys.add(de.getFullKey());</span>
        }
<span class="fc" id="L992">    }</span>

    /**
     * Remove and deregister a key
     *
     * @param key the full key (with expense) to deregister
     */
    @Override
    public void removeKey(String key) {
<span class="fc" id="L1001">        String keyWithOutExpense = KeyManipulator.removeExpense(key);</span>

<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (keys.remove(key)) {</span>
<span class="fc" id="L1004">            List&lt;String&gt; keylist = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1005">            keylist.add(keyWithOutExpense);</span>
<span class="fc" id="L1006">            deregisterFromDirectory(keylist);</span>

<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">            if (keys.isEmpty()) {</span>
<span class="fc" id="L1009">                DirectoryEntry de = new DirectoryEntry(key);</span>
<span class="fc" id="L1010">                de.setDataType(UNUSED_PROXY);</span>
<span class="fc" id="L1011">                keys.add(de.getFullKey());</span>
            }
<span class="fc" id="L1013">        } else {</span>
<span class="fc" id="L1014">            logger.debug(&quot;Key specified for removal not found: {}&quot;, key);</span>
        }
<span class="fc" id="L1016">    }</span>

    /**
     * Stop all threads if any. Can be overridden by, deregister from directory, and remove from the namespace. derived
     * classes if needed
     */
    @Override
    public void shutDown() {
<span class="fc" id="L1024">        logger.debug(&quot;Called shutDown()&quot;);</span>

        // Remove from directory a list of keys without expense
<span class="fc" id="L1027">        deregisterFromDirectory(keys.stream().map(KeyManipulator::removeExpense).collect(Collectors.toList()));</span>

        // Unbind from namespace
<span class="fc" id="L1030">        unbindFromNamespace();</span>
<span class="fc" id="L1031">    }</span>

    protected void unbindFromNamespace() {
<span class="fc" id="L1034">        keys.stream().map(KeyManipulator::getServiceLocation).forEach(Namespace::unbind);</span>
<span class="fc" id="L1035">    }</span>

    /**
     * Return the place name
     *
     * @return string key of this place
     */
    @Override
    public String getPlaceName() {
<span class="fc" id="L1044">        return KeyManipulator.getServiceClassname(keys.get(0));</span>
    }

    /**
     * Get custom resource limitation in millis if specified
     *
     * @return -2 if not specified, or long millis if specified
     */
    @Override
    public long getResourceLimitMillis() {
<span class="fc" id="L1054">        return configG.findLongEntry(PLACE_RESOURCE_LIMIT_MILLIS, -2L);</span>
    }

    /**
     * Get the agent that is currently responsible for this thread
     *
     * @return the live instance of the mobile agent thread
     */
    @Override
    public MobileAgent getAgent() throws NamespaceException {
<span class="fc" id="L1064">        return (MobileAgent) Namespace.lookup(Thread.currentThread().getName());</span>
    }

    @Override
    public List&lt;String&gt; getRunningConfig() {
<span class="fc" id="L1069">        List&lt;String&gt; runningConfigList = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        if (configG != null) {</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">            for (ConfigEntry c : configG.getEntries()) {</span>
<span class="fc" id="L1073">                runningConfigList.add(&quot;Key: &quot; + c.getKey() + &quot; Value: &quot; + c.getValue());</span>
<span class="fc" id="L1074">            }</span>
        }
<span class="fc" id="L1076">        return runningConfigList;</span>
    }

    @Override
    public String getPlaceStats() {
        ResourceWatcher resource;
        Timer placeStats;
<span class="fc" id="L1083">        String placeStatStr = &quot;UNAVAILABLE&quot;;</span>
        try {
<span class="nc" id="L1085">            resource = ResourceWatcher.lookup();</span>
<span class="nc" id="L1086">            String statsKey = getPlaceName();</span>
<span class="nc" id="L1087">            placeStats = resource.getStat(statsKey);</span>

<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (placeStats != null) {</span>
<span class="nc" id="L1090">                placeStatStr = placeStats.getSnapshot().toString();</span>
            }
<span class="fc" id="L1092">        } catch (NamespaceException ne) {</span>
<span class="fc" id="L1093">            logger.error(&quot;Exception occurred while trying to lookup resource&quot;, ne);</span>
<span class="nc" id="L1094">        }</span>
<span class="fc" id="L1095">        return placeStatStr;</span>
    }

    @Override
    public void dumpRunningConfig() {
<span class="fc" id="L1100">        logger.info(&quot;Dumping Running Config for {}:&quot;, placeName);</span>
<span class="fc" id="L1101">        logger.info(&quot;===============&quot;);</span>
<span class="fc" id="L1102">        logger.info(&quot;{}&quot;, getRunningConfig());</span>
<span class="fc" id="L1103">        logger.info(&quot;===============&quot;);</span>
<span class="fc" id="L1104">    }</span>

    @Override
    public void dumpPlaceStats() {
<span class="fc" id="L1108">        logger.info(&quot;Dumping Places Stats for {}:&quot;, placeName);</span>
<span class="fc" id="L1109">        logger.info(&quot;===============&quot;);</span>
<span class="fc" id="L1110">        logger.info(&quot;{}&quot;, getPlaceStats());</span>
<span class="fc" id="L1111">        logger.info(&quot;===============&quot;);</span>
<span class="fc" id="L1112">    }</span>

    /**
     * Leverage our insider knowledge of how emissary MobileAgents work in conjunction with the namespace to reach around
     * the back door of the system and get the TLD for the current payload You should only call this if
     * payload.shortName().indexOf(Family.SEP) &amp;gt; -1
     */
    @Nullable
    protected IBaseDataObject getTld() {
        try {
<span class="fc" id="L1122">            MobileAgent agent = getAgent();</span>

<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">            if (agent instanceof HDMobileAgent) {</span>
<span class="fc" id="L1125">                Object payload = ((HDMobileAgent) agent).getPayloadForTransport();</span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">                if (payload instanceof List) {</span>
<span class="fc" id="L1127">                    List&lt;?&gt; familyTree = (List&lt;?&gt;) payload;</span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">                    for (Object familyMember : familyTree) {</span>
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">                        if (familyMember instanceof IBaseDataObject) {</span>
<span class="fc" id="L1130">                            IBaseDataObject member = (IBaseDataObject) familyMember;</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                            if (!member.shortName().contains(Family.SEP)) {</span>
<span class="fc" id="L1132">                                return member;</span>
                            }
<span class="fc" id="L1134">                        } else {</span>
<span class="nc" id="L1135">                            logger.debug(&quot;Family members are not the right class - {}&quot;, familyMember.getClass().getName());</span>
                        }
<span class="fc" id="L1137">                    }</span>
<span class="nc" id="L1138">                } else {</span>
<span class="nc" id="L1139">                    logger.debug(&quot;Agent is transporting unknown data type - {}&quot;, payload.getClass().getName());</span>
                }
<span class="nc" id="L1141">            } else {</span>
<span class="nc" id="L1142">                logger.debug(&quot;System is operating with {} so there is no hope of getting the family tree&quot;, agent.getClass().getName());</span>
            }
<span class="nc" id="L1144">        } catch (Exception ex) {</span>
<span class="nc" id="L1145">            logger.debug(&quot;Could not get controlling agent&quot;, ex);</span>
<span class="nc" id="L1146">        }</span>

        // Nothing found?
<span class="nc" id="L1149">        return null;</span>
    }

    @Override
    public boolean isDenied(String s) {
<span class="fc" id="L1154">        return denyList.contains(s);</span>
    }

    /**
     * This method should return a list of all the parameters that a subclass Place will potentially modify (this includes
     * adding, removing, or changing the value of).
     *
     * Currently, this implementation in ServiceProviderPlace will return an empty List, but subclass implementers (i.e.
     * Place authors) are urged to override this method. Ultimately, this body of this method will be removed and it will
     * become abstract.
     *
     * @return a List&amp;lt;String&amp;gt; of all parameter names that a Place will add, remove, or change the value of
     */
    protected List&lt;String&gt; getParametersModified() {
<span class="nc" id="L1168">        return Collections.emptyList();</span>
    }

    /**
     * This method should return a list of all the alternate views that a subclass Place will potentially modify (this
     * includes adding, removing, or changing the value of).
     *
     * Currently, this implementation in ServiceProviderPlace will return an empty List, but subclass implementers (i.e.
     * Place authors) are urged to override this method. Ultimately, this body of this method will be removed and it will
     * become abstract.
     *
     * @return a List&amp;lt;String&amp;gt; of all alternate view names that a Place will add, remove, or change the value of
     */
    protected List&lt;String&gt; getAlternateViewsModified() {
<span class="nc" id="L1182">        return Collections.emptyList();</span>
    }

    /**
     * This method should return a list of all the output forms that a subclass Place will potentially output
     *
     * Currently, this implementation in ServiceProviderPlace will return an empty List, but subclass implementers (i.e.
     * Place authors) are urged to override this method. Ultimately, this body of this method will be removed and it will
     * become abstract.
     *
     * @return a List&amp;lt;String&amp;gt; of all output forms that a Place may output
     */
    protected List&lt;String&gt; getOutputForms() {
<span class="nc" id="L1195">        return Collections.emptyList();</span>
    }

    /**
     * This method should return a list of all the file types that a subclass Place will potentially output
     *
     * Currently, this implementation in ServiceProviderPlace will return an empty List, but subclass implementers (i.e.
     * Place authors) are urged to override this method. Ultimately, this body of this method will be removed and it will
     * become abstract.
     *
     * @return a List&amp;lt;String&amp;gt; of all file types that a Place may output
     */
    protected List&lt;String&gt; getFileTypes() {
<span class="nc" id="L1208">        return Collections.emptyList();</span>
    }

    /**
     * This method should return true if the Place may alter the IBaseDataObject data[] (i.e.PrimaryView) in any way, and
     * false otherwise
     *
     * @return true if the data[] member may be altered by the Place, false otherwise
     */
    protected boolean changesPrimaryView() {
<span class="nc" id="L1218">        return false;</span>
    }

    /**
     * This method should return true if the Place may create any &quot;extracted&quot; records, and false otherwise
     *
     * @return true if the Place may create &quot;extracted&quot; records, false otherwise
     */
    protected boolean createsExtractedRecords() {
<span class="nc" id="L1227">        return false;</span>
    }

    /**
     * This method should return true if the Place may sprout &quot;child&quot; IBaseDataObjects, and false otherwise
     *
     * @return true if the Place may sprout children, false otherwise
     */
    protected boolean sproutsChildren() {
<span class="nc" id="L1236">        return false;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>