<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultiFileUnixCommandPlace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.place</a> &gt; <span class="el_source">MultiFileUnixCommandPlace.java</span></div><h1>MultiFileUnixCommandPlace.java</h1><pre class="source lang-java linenums">package emissary.place;

import emissary.core.DataObjectFactory;
import emissary.core.Family;
import emissary.core.Form;
import emissary.core.IBaseDataObject;
import emissary.core.ResourceException;
import emissary.directory.KeyManipulator;
import emissary.kff.KffDataObjectHandler;
import emissary.util.shell.Executrix;
import emissary.util.shell.TempFileNames;

import jakarta.annotation.Nullable;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static emissary.core.constants.Parameters.DOCUMENT_TITLE;

public class MultiFileUnixCommandPlace extends MultiFileServerPlace implements IMultiFileUnixCommandPlace {
    protected boolean doSynchronized;
    protected List&lt;String&gt; newChildForms;
    @Nullable
    protected String newParentForm;
    protected String newErrorForm;
<span class="pc" id="L36">    protected boolean keepFilesDebug = false;</span>
<span class="pc" id="L37">    protected boolean nukeMyProxies = true;</span>
<span class="pc" id="L38">    protected boolean recurseSubDirs = true;</span>
<span class="pc" id="L39">    @Nullable</span>
    protected String apBinDir = null;
<span class="pc" id="L41">    @Nullable</span>
    protected List&lt;String&gt; binFiles = null;
<span class="pc" id="L43">    @Nullable</span>
    protected List&lt;String&gt; binFileExt = null;
<span class="pc" id="L45">    @Nullable</span>
    protected List&lt;String&gt; outDirs = null;
<span class="pc" id="L47">    protected String singleChildFiletype = Form.UNKNOWN;</span>
<span class="pc" id="L48">    protected boolean keepParentHashesForSingleChild = false;</span>
<span class="pc" id="L49">    protected boolean keepParentFiletypeForSingleChild = false;</span>
    protected static final String DEFAULT_NEW_PARENT_FORM = &quot;SAFE_HTML&quot;;
    protected static final String DEFAULT_NEW_CHILD_FORM = Form.UNKNOWN;
    protected static final String DEFAULT_NEW_ERROR_FORM = Form.ERROR;
<span class="pc" id="L53">    protected boolean setTitleToFile = true;</span>
<span class="pc" id="L54">    protected Map&lt;String, String&gt; fileTypesByExtension = new HashMap&lt;&gt;();</span>
<span class="pc" id="L55">    @Nullable</span>
    protected String contentFile = null;
    protected Executrix executrix;
    protected String logfilename;
<span class="pc" id="L59">    protected String charset = StandardCharsets.UTF_8.name();</span>
<span class="pc" id="L60">    protected boolean singleOutputAsChild = false;</span>
<span class="pc" id="L61">    protected boolean preserveParentData = false;</span>
    protected boolean ignoreEmptyFile;

<span class="pc" id="L64">    String placeDisplayName = &quot;Some Place&quot;;</span>

    public MultiFileUnixCommandPlace() throws IOException {
<span class="nc" id="L67">        super();</span>
<span class="nc" id="L68">        configurePlace();</span>
<span class="nc" id="L69">    }</span>

    public MultiFileUnixCommandPlace(InputStream configStream) throws IOException {
<span class="fc" id="L72">        super(configStream);</span>
<span class="fc" id="L73">        configurePlace();</span>
<span class="fc" id="L74">    }</span>

    /** Distributed constructor */
    public MultiFileUnixCommandPlace(String configInfo, String dir, String placeLoc) throws IOException {
<span class="nc" id="L78">        super(configInfo, dir, placeLoc);</span>
<span class="nc" id="L79">        configurePlace();</span>
<span class="nc" id="L80">    }</span>

    /** Test constructors */
    public MultiFileUnixCommandPlace(String configInfo) throws IOException {
<span class="nc" id="L84">        super(configInfo, &quot;FooPlace.foo.bar.com:8001&quot;);</span>
<span class="nc" id="L85">        configurePlace();</span>
<span class="nc" id="L86">    }</span>

    public MultiFileUnixCommandPlace(String configInfo, String loc) throws IOException {
<span class="nc" id="L89">        super(configInfo, loc);</span>
<span class="nc" id="L90">        configurePlace();</span>
<span class="nc" id="L91">    }</span>

    /**
     * Configure local special variables
     * &lt;ul&gt;
     * &lt;li&gt;CONTENT_FILE: file name to become new parent&lt;/li&gt;
     * &lt;li&gt;SYNCHRONIZED_PROCESS: decide whether to synchronize, default false&lt;/li&gt;
     * &lt;li&gt;NUKE_MY_PROXIES: remove all place proxies from incoming payload, default true&lt;/li&gt;
     * &lt;li&gt;KEEP_FILES_DEBUG: keep all files resulting from exec, default false&lt;/li&gt;
     * &lt;li&gt;RECURSE_SUBDIRS: when picking up results, default true&lt;/li&gt;
     * &lt;li&gt;AP_BIN_DIR: where to find executables&lt;/li&gt;
     * &lt;li&gt;OUT_DIRS: where output goes, default '.'&lt;/li&gt;
     * &lt;li&gt;BIN_EXTENSIONS: extension of files to skip when picking up results&lt;/li&gt;
     * &lt;li&gt;BIN_FILES: filenames to skip when picking up results&lt;/li&gt;
     * &lt;li&gt;NEW_ERROR_FORM: form for error result, default ERROR&lt;/li&gt;
     * &lt;li&gt;NEW_PARENT_FORM: form on parent for success, default UNKNOWN, can use '&amp;lt;null&amp;gt;'&lt;/li&gt;
     * &lt;li&gt;NEW_CHILD_FORM: new form on extracted data, default UNKNOWN&lt;/li&gt;
     * &lt;li&gt;SINGLE_CHILD_FILETYPE: file type for single child&lt;/li&gt;
     * &lt;li&gt;KEEP_PARENT_HASHES_FOR_SINGLE_CHILD: when single child is promoted determines if original parent hashes are kept
     * or not, default false&lt;/li&gt;
     * &lt;li&gt;KEEP_PARENT_FILETYPE_FOR_SINGLE_CHILD: when single child is promoted determines if original parent filetype is
     * kept or not, default false&lt;/li&gt;
     * &lt;li&gt;SET_TITLE_TO_FILENAME: whether to use filename in doc title, defaul true&lt;/li&gt;
     * &lt;li&gt;SERVICE_DISPLAY_NAME: pretty name for sprout message&lt;/li&gt;
     * &lt;li&gt;CUSTOM_FILE_TYPES: special mapping to set type by file extension&lt;/li&gt;
     * &lt;li&gt;LOG_FILE_NAME: name of output file to translate into logger commands, default: [servicename].log from key&lt;/li&gt;
     * &lt;li&gt;OUTPUT_CHARSET: charset of the process output, default UTF-8&lt;/li&gt;
     * &lt;li&gt;SINGLE_OUTPUT_AS_CHILD: If only one output file keep it as a child and do not replace the parent.&lt;/li&gt;
     * &lt;li&gt;PRESERVE_PARENT_DATA: Stops the parent from getting replaced by output data&lt;/li&gt;
     * &lt;li&gt;IGNORE_EMPTY_FILE: gives the option to save 0 length files, default true&lt;/li&gt;
     * &lt;/ul&gt;
     */
    @Override
    public void configurePlace() {
<span class="fc" id="L125">        executrix = new Executrix(configG);</span>
<span class="fc" id="L126">        contentFile = configG.findStringEntry(&quot;CONTENT_FILE&quot;, null);</span>
<span class="fc" id="L127">        doSynchronized = configG.findBooleanEntry(&quot;SYNCHRONIZED_PROCESS&quot;, false);</span>
<span class="fc" id="L128">        nukeMyProxies = configG.findBooleanEntry(&quot;NUKE_MY_PROXIES&quot;, true);</span>
<span class="fc" id="L129">        keepFilesDebug = configG.findBooleanEntry(&quot;KEEP_FILES_DEBUG&quot;, false);</span>
<span class="fc" id="L130">        recurseSubDirs = configG.findBooleanEntry(&quot;RECURSE_SUBDIRS&quot;, true);</span>
<span class="fc" id="L131">        apBinDir = configG.findStringEntry(&quot;AP_BIN_DIR&quot;, &quot;&quot;);</span>
<span class="fc" id="L132">        outDirs = configG.findEntries(&quot;OUT_DIRS&quot;, &quot;.&quot;);</span>
<span class="fc" id="L133">        charset = configG.findStringEntry(&quot;OUTPUT_CHARSET&quot;, charset);</span>

<span class="fc" id="L135">        binFileExt = configG.findEntries(&quot;BIN_EXTENSIONS&quot;);</span>
<span class="fc" id="L136">        binFiles = configG.findEntries(&quot;BIN_FILES&quot;);</span>

<span class="fc" id="L138">        newErrorForm = configG.findStringEntry(&quot;NEW_ERROR_FORM&quot;, DEFAULT_NEW_ERROR_FORM);</span>
<span class="fc" id="L139">        newParentForm = configG.findStringEntry(&quot;NEW_PARENT_FORM&quot;, DEFAULT_NEW_PARENT_FORM);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (newParentForm.equals(&quot;&lt;null&gt;&quot;)) {</span>
<span class="nc" id="L141">            newParentForm = null;</span>
        }
<span class="fc" id="L143">        newChildForms = configG.findEntries(&quot;NEW_CHILD_FORM&quot;, DEFAULT_NEW_CHILD_FORM);</span>
<span class="fc" id="L144">        singleChildFiletype = configG.findStringEntry(&quot;SINGLE_CHILD_FILETYPE&quot;, Form.UNKNOWN);</span>
<span class="fc" id="L145">        keepParentHashesForSingleChild = configG.findBooleanEntry(&quot;KEEP_PARENT_HASHES_FOR_SINGLE_CHILD&quot;, false);</span>
<span class="fc" id="L146">        keepParentFiletypeForSingleChild = configG.findBooleanEntry(&quot;KEEP_PARENT_FILETYPE_FOR_SINGLE_CHILD&quot;, false);</span>

<span class="fc" id="L148">        setTitleToFile = configG.findBooleanEntry(&quot;SET_TITLE_TO_FILENAME&quot;, true);</span>
<span class="fc" id="L149">        placeDisplayName = configG.findStringEntry(&quot;SERVICE_DISPLAY_NAME&quot;, placeName);</span>
<span class="fc" id="L150">        logfilename = configG.findStringEntry(&quot;LOG_FILE_NAME&quot;, KeyManipulator.getServiceName(keys.get(0)) + &quot;.log&quot;);</span>
<span class="fc" id="L151">        singleOutputAsChild = configG.findBooleanEntry(&quot;SINGLE_OUTPUT_AS_CHILD&quot;, singleOutputAsChild);</span>
<span class="fc" id="L152">        preserveParentData = configG.findBooleanEntry(&quot;PRESERVE_PARENT_DATA&quot;, preserveParentData);</span>
<span class="fc" id="L153">        ignoreEmptyFile = configG.findBooleanEntry(&quot;IGNORE_EMPTY_FILE&quot;, true);</span>

<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        for (String name : configG.findEntries(&quot;CUSTOM_FILE_TYPES&quot;)) {</span>
<span class="nc" id="L156">            String tmp = configG.findStringEntry(name + &quot;_EXT&quot;, null);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (tmp == null) {</span>
<span class="nc" id="L158">                logger.warn(&quot;Type missing for {}&quot;, name);</span>
<span class="nc" id="L159">                continue;</span>
            }
<span class="nc" id="L161">            fileTypesByExtension.put(tmp, name);</span>
<span class="nc" id="L162">        }</span>
<span class="fc" id="L163">    }</span>


    /**
     * get the log file name
     */
    public String getLogFileName() {
<span class="fc" id="L170">        return logfilename;</span>
    }

    /**
     * Set a custom executrix, allows easier mocking among other things
     * 
     * @param e the new executrix instance to use
     */
    public void setExecutrix(Executrix e) {
<span class="nc" id="L179">        executrix = e;</span>
<span class="nc" id="L180">    }</span>

    /**
     * Set the output type programatically
     */
    public void setStdOutputCommand() {
<span class="nc" id="L186">        executrix.setOutputStd();</span>
<span class="nc" id="L187">        logger.debug(&quot;Output type set to STD&quot;);</span>
<span class="nc" id="L188">    }</span>

    /**
     * Set the output type programatically
     */
    public void setFileOutputCommand() {
<span class="fc" id="L194">        executrix.setOutputFile();</span>
<span class="fc" id="L195">        logger.debug(&quot;Output type set to FILE&quot;);</span>
<span class="fc" id="L196">    }</span>


    /**
     * Log the messages found in the log file
     * 
     * @param tempDir the directory where the command executed
     */
    protected void logMessages(String tempDir) {
        // if there is a log file, read it and log the messages
        try {
<span class="fc" id="L207">            String lfn = tempDir + &quot;/&quot; + logfilename;</span>
<span class="fc" id="L208">            byte[] logdata = Executrix.readDataFromFile(lfn, true);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (logdata != null) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                for (String message : new String(logdata, charset).split(&quot;\n&quot;)) {</span>
<span class="fc" id="L211">                    logger.info(message);</span>
                }
            }
<span class="nc" id="L214">        } catch (Exception e) {</span>
<span class="nc" id="L215">            logger.debug(&quot;Error logging messages&quot;, e);</span>
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">    }</span>

    /**
     * Get list of things that were excreted from the process
     * 
     * @param tmpDir the process execution area
     * @param inputFileName name of input file so it can be skipped
     */
    protected List&lt;File&gt; getFileList(File tmpDir, String inputFileName) {
<span class="fc" id="L226">        List&lt;File&gt; outFiles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L227">        getFileList(tmpDir, inputFileName, outFiles);</span>
<span class="fc" id="L228">        return outFiles;</span>
    }

    /**
     * Get list of things that were excreted from the process by recursively walking the directory
     * 
     * @param tmpDir the process execution area
     * @param inputFileName name of input file so it can be skipped
     * @param outFiles list to which files that are found can be added
     */
    protected void getFileList(File tmpDir, String inputFileName, List&lt;File&gt; outFiles) {
        // Recursive call to walk the subtree of output files/dirs
<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (int d = 0; d &lt; outDirs.size(); d++) {</span>
<span class="fc" id="L241">            logger.debug(&quot;outDirs[{}]={}&quot;, d, outDirs.get(d));</span>
            File dir;
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            if (outDirs.get(d).equals(&quot;.&quot;)) {</span>
<span class="fc" id="L244">                dir = tmpDir;</span>
            } else {
<span class="nc" id="L246">                dir = new File(tmpDir, outDirs.get(d));</span>
            }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">            if (!dir.exists()) {</span>
<span class="nc" id="L249">                logger.warn(&quot;Output directory does not exist:{}&quot;, outDirs.get(d));</span>
<span class="nc" id="L250">                continue;</span>
            }
<span class="fc" id="L252">            File[] files = dir.listFiles();</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">            if (files == null) {</span>
<span class="nc" id="L254">                continue;</span>
            }
<span class="fc bfc" id="L256" title="All 2 branches covered.">            for (File file : files) {</span>
<span class="pc bpc" id="L257" title="2 of 4 branches missed.">                if (!(file.exists() &amp;&amp; file.canRead())) {</span>
<span class="nc" id="L258">                    logger.warn(&quot;cannot access child[{}]:{}&quot;, outFiles.size(), file.getAbsolutePath());</span>
<span class="nc" id="L259">                    continue;</span>
                }
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">                if (file.isDirectory()) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    if (recurseSubDirs) {</span>
<span class="nc" id="L263">                        getFileList(file, inputFileName, outFiles);</span>
                    } else {
<span class="nc" id="L265">                        logger.debug(&quot;skipping directory: {}&quot;, file.getPath());</span>
                    }
<span class="nc" id="L267">                    continue;</span>
                }
<span class="fc" id="L269">                String fname = file.getName();</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                if (binFiles.contains(fname)) {</span>
<span class="nc" id="L271">                    logger.debug(&quot;Ignoring file '{}' because it is in BIN_FILES&quot;, fname);</span>
<span class="nc" id="L272">                    continue;</span>
                }
<span class="fc bfc" id="L274" title="All 2 branches covered.">                if (fname.equals(getLogFileName())) {</span>
<span class="fc" id="L275">                    logger.debug(&quot;Using file {} as log message source&quot;, fname);</span>
<span class="fc" id="L276">                    logMessages(tmpDir.getPath());</span>
<span class="fc" id="L277">                    continue;</span>
                }
<span class="pc bpc" id="L279" title="2 of 4 branches missed.">                if (fname.contains(&quot;.&quot;) &amp;&amp; binFileExt.contains(fname.substring(fname.lastIndexOf(&quot;.&quot;) + 1))) {</span>
<span class="nc" id="L280">                    logger.debug(&quot;Ignoring file '{}' because it is in BIN_EXTENSIONS.&quot;, fname);</span>
<span class="nc" id="L281">                    continue;</span>
                }
<span class="pc bpc" id="L283" title="3 of 4 branches missed.">                if (contentFile != null &amp;&amp; contentFile.equals(fname)) {</span>
<span class="nc" id="L284">                    logger.debug(&quot;Ignoring file '{}' because it is to be the new parent data.&quot;, fname);</span>
<span class="nc" id="L285">                    continue;</span>
                }
<span class="fc bfc" id="L287" title="All 2 branches covered.">                if (inputFileName.endsWith(fname)) {</span>
<span class="fc" id="L288">                    logger.debug(&quot;Ignoring file '{}' because it is the input file.&quot;, fname);</span>
<span class="fc" id="L289">                    continue;</span>
                }
<span class="pc bpc" id="L291" title="3 of 4 branches missed.">                if (ignoreEmptyFile &amp;&amp; file.length() == 0) {</span>
<span class="nc" id="L292">                    logger.debug(&quot;Ignoring file '{}' because it is empty.&quot;, fname);</span>
<span class="nc" id="L293">                    continue;</span>
                }
<span class="fc" id="L295">                logger.debug(&quot;Adding output file '{}' for processing&quot;, fname);</span>
<span class="fc" id="L296">                outFiles.add(file);</span>
            }
        }
<span class="fc" id="L299">        outFiles.sort(new FileNameComparator());</span>
<span class="fc" id="L300">    }</span>

<span class="fc" id="L302">    protected static class FileNameComparator implements Comparator&lt;File&gt; {</span>
        @Override
        public int compare(@Nullable File o1, @Nullable File o2) {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">            if (o1 == null) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                return o2 != null ? 1 : 0;</span>
            }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (o2 == null) {</span>
<span class="nc" id="L309">                return -1;</span>
            }
<span class="fc" id="L311">            return o1.getName().compareTo(o2.getName());</span>
        }
    }

    /**
     * Process the result files, turning them into attachments Override hooks: initSprout, preSprout,
     * postSprout,finishSprout
     * 
     * @param parent the original payload
     * @param files the result files
     * @param tempDirName execution area name
     * @param newData data for parent accumulator
     * @return list of attachments
     */
    protected List&lt;IBaseDataObject&gt; sproutResults(IBaseDataObject parent, List&lt;File&gt; files, String tempDirName, StringBuilder newData) {
<span class="fc" id="L326">        List&lt;IBaseDataObject&gt; sprouts = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (files.isEmpty()) {</span>
<span class="nc" id="L329">            logger.warn(&quot;NO OUTPUT FILES FOUND!&quot;);</span>
<span class="nc" id="L330">            return sprouts;</span>
        }

<span class="fc" id="L333">        int fileCount = files.size();</span>
<span class="fc" id="L334">        int actualFileCount = 0;</span>
<span class="fc" id="L335">        int birthOrder = parent.getNumChildren() + 1;</span>

<span class="fc" id="L337">        parent.setNumChildren(fileCount);</span>
<span class="fc" id="L338">        initSprout(parent, files, newData, tempDirName);</span>

<span class="fc bfc" id="L340" title="All 2 branches covered.">        for (File f : files) {</span>
<span class="fc" id="L341">            logger.debug(&quot;Handling data file {}&quot;, f.getName());</span>

<span class="pc bpc" id="L343" title="2 of 4 branches missed.">            if (!f.canRead() || !f.isFile()) {</span>
<span class="nc" id="L344">                logger.debug(&quot;Cannot read from {}&quot;, f.getAbsolutePath());</span>
<span class="nc" id="L345">                continue;</span>
            }

<span class="fc" id="L348">            byte[] theData = Executrix.readDataFromFile(f.getAbsolutePath());</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">            if (theData == null) {</span>
<span class="nc" id="L350">                logger.debug(&quot;Cannot read data from {}&quot;, f.getAbsolutePath());</span>
<span class="nc" id="L351">                continue;</span>
            }

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if (!preSprout(theData, parent, f, birthOrder, fileCount, newData)) {</span>
<span class="nc" id="L355">                continue;</span>
            }

<span class="fc" id="L358">            Map&lt;String, Object&gt; metaData = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (setTitleToFile) {</span>
<span class="fc" id="L360">                metaData.put(DOCUMENT_TITLE, f.getName());</span>
            }

<span class="fc" id="L363">            List&lt;String&gt; tmpForms = getFormsFromFile(f);</span>

<span class="fc" id="L365">            IBaseDataObject dObj = DataObjectFactory.getInstance(theData, parent.getFilename() + Family.SEP + birthOrder, tmpForms.get(0));</span>

<span class="fc" id="L367">            dObj.putParameters(metaData);</span>
<span class="fc" id="L368">            sprouts.add(dObj);</span>

<span class="fc" id="L370">            actualFileCount++;</span>
<span class="fc" id="L371">            birthOrder++;</span>
<span class="fc" id="L372">            postSprout(theData, parent, f, birthOrder, fileCount, actualFileCount, newData, dObj);</span>
<span class="fc" id="L373">        }</span>

<span class="fc" id="L375">        finishSprout(parent, fileCount, actualFileCount, newData);</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (!preserveParentData) {</span>
            try {
<span class="fc" id="L379">                parent.setData(newData.toString().getBytes(charset));</span>
<span class="nc" id="L380">            } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L381">                logger.debug(&quot;SproutResults charset problem&quot;, e);</span>
<span class="nc" id="L382">                parent.setData(newData.toString().getBytes());</span>
<span class="fc" id="L383">            }</span>
        }
<span class="fc" id="L385">        return sprouts;</span>
    }


    /**
     * Determines the initial forms for a new data object based on the configuration settings and the file name. This method
     * may be customized in sub-classes, but at least one form value must be returned!
     */
    protected List&lt;String&gt; getFormsFromFile(File f) {
<span class="fc" id="L394">        List&lt;String&gt; tmpForms = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        for (Map.Entry&lt;String, String&gt; fileTypes : fileTypesByExtension.entrySet()) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (f.getName().endsWith(fileTypes.getKey())) {</span>
<span class="nc" id="L398">                tmpForms.add(fileTypes.getValue());</span>
            }
<span class="nc" id="L400">        }</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (tmpForms.isEmpty()) {</span>
<span class="fc" id="L402">            tmpForms.addAll(newChildForms);</span>
        }
<span class="fc" id="L404">        return tmpForms;</span>
    }


    /**
     * Override hook when attachment processing is about to be started If CONTENT_FILE has been specified that data is read
     * and loaded into the newData accumulator now
     * 
     * @param parent the original payload
     * @param files the result files
     * @param newData accumulator for replacement parent data
     * @param dirName name of process execution area
     */
    protected void initSprout(IBaseDataObject parent, List&lt;File&gt; files, StringBuilder newData, String dirName) {
<span class="fc" id="L418">        logger.debug(&quot;initSprout hook contentFile={}&quot;, contentFile);</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (contentFile != null) {</span>
<span class="nc" id="L420">            byte[] fileData = Executrix.readDataFromFile(dirName + File.separator + contentFile);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (fileData != null) {</span>
<span class="nc" id="L422">                newData.append(new String(fileData));</span>
            } else {
<span class="nc" id="L424">                logger.debug(&quot;Can't find new content file:{}{}{}&quot;, dirName, File.separator, contentFile);</span>
            }
        }
<span class="fc" id="L427">    }</span>


    /**
     * Override hook when attachment processing is finished
     * 
     * @param parent the original payload
     * @param numSubParts the number of attachments handled
     * @param actualFileCount the number of result files processed
     * @param newParentData accumulator for replacement parent data
     */
    protected void finishSprout(IBaseDataObject parent, int numSubParts, int actualFileCount, StringBuilder newParentData) {
<span class="fc" id="L439">        logger.debug(&quot;finishSprout hook&quot;);</span>
<span class="fc" id="L440">    }</span>

    /**
     * Override hook when an attachment begins processing
     * 
     * @param data the bytes of content for the attachment
     * @param parent the original payload
     * @param f the file the content comes from
     * @param birthOrder for this attachment
     * @param numSubParts the number of attachments handled
     * @param newParentData accumulator for replacement parent data
     * @return true to continue, false to skip this attachment
     */
    protected boolean preSprout(byte[] data, IBaseDataObject parent, File f, int birthOrder, int numSubParts, StringBuilder newParentData) {
<span class="fc" id="L454">        logger.debug(&quot;preSprout hook on {} order={}&quot;, f.getName(), birthOrder);</span>
<span class="fc" id="L455">        return true;</span>
    }

    /**
     * Override hook when an attachment finished processing
     * 
     * @param data the bytes of content for the attachment
     * @param parent the original payload
     * @param f the file the content comes from
     * @param birthOrder for this attachment
     * @param numSubParts the number of attachments handled
     * @param actualFileCount count of files to process
     * @param newParentData accumulator for replacement parent data
     * @param theSprout the new data object
     */
    protected void postSprout(byte[] data, IBaseDataObject parent, File f, int birthOrder, int numSubParts, int actualFileCount,
            StringBuilder newParentData, IBaseDataObject theSprout) {
<span class="fc" id="L472">        logger.debug(&quot;postSprout hook on {} order={}&quot;, f.getName(), birthOrder);</span>
<span class="fc" id="L473">    }</span>


    /**
     * Process in a custom way when there is only one file result
     * 
     * @param d the parent payload
     * @param f the file to process
     * @return 0 when it works
     */
    protected int processSingleChild(IBaseDataObject d, File f) {
<span class="nc" id="L484">        byte[] theData = Executrix.readDataFromFile(f.getAbsolutePath());</span>
<span class="nc" id="L485">        return processSingleChild(d, f, theData);</span>
    }


    /**
     * Process in a custom way when there is only one file result
     * 
     * @param d the parent payload
     * @param theData the bytes to process
     * @param f the file the data comes from
     * @return 0 when it works
     */
    protected int processSingleChild(IBaseDataObject d, File f, byte[] theData) {
<span class="nc" id="L498">        String filename = f.getName();</span>
<span class="nc" id="L499">        d.setData(theData);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if (setTitleToFile) {</span>
<span class="nc" id="L501">            d.putParameter(DOCUMENT_TITLE, filename);</span>
        }
<span class="nc" id="L503">        List&lt;String&gt; tmpForms = getFormsFromFile(f);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        for (String tmpForm : tmpForms) {</span>
<span class="nc" id="L505">            d.pushCurrentForm(tmpForm);</span>
<span class="nc" id="L506">        }</span>
<span class="nc" id="L507">        d.setFileType(singleChildFiletype);</span>
<span class="nc" id="L508">        return 0;</span>
    }

    /**
     * Process in a custom way when there is only one file result
     *
     * @param d the parent payload
     * @param theData the bytes to process
     * @param f the file the data comes from
     * @return 0 when it works
     * @deprecated use {@link #processSingleChild(IBaseDataObject, File, byte[])}
     */
    @Deprecated
    @SuppressWarnings(&quot;InconsistentOverloads&quot;)
    protected int processSingleChild(IBaseDataObject d, byte[] theData, File f) {
<span class="nc" id="L523">        return processSingleChild(d, f, theData);</span>
    }

    /**
     * Process an incoming payload in synchronized fashion
     * 
     * @param theDataObject the payload to process
     */
    protected synchronized List&lt;IBaseDataObject&gt; synchronizedProcess(IBaseDataObject theDataObject) throws ResourceException {
<span class="nc" id="L532">        return processData(theDataObject);</span>
    }


    /**
     * Process an incoming payload in non-synchronized fashion
     * 
     * @param theDataObject the payload to process
     */
    protected List&lt;IBaseDataObject&gt; unSynchronizedProcess(IBaseDataObject theDataObject) throws ResourceException {
<span class="fc" id="L542">        return processData(theDataObject);</span>
    }


    /**
     * Process an incoming payload returning a list of attachments
     * 
     * @param tData the payload to process
     */
    @Override
    public List&lt;IBaseDataObject&gt; processHeavyDuty(IBaseDataObject tData) throws ResourceException {
        List&lt;IBaseDataObject&gt; entries;

<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        if (doSynchronized) {</span>
<span class="nc" id="L556">            entries = synchronizedProcess(tData);</span>
        } else {
<span class="fc" id="L558">            entries = unSynchronizedProcess(tData);</span>
        }

<span class="pc bpc" id="L561" title="1 of 4 branches missed.">        if (entries == null || entries.isEmpty()) {</span>
<span class="fc" id="L562">            logger.debug(&quot;no messages found in file.&quot;);</span>
<span class="fc" id="L563">            return Collections.emptyList();</span>
        }

<span class="fc" id="L566">        addParentInformation(tData, entries);</span>

        // Replace parent if single child and singleOutputAsChild is false
<span class="pc bpc" id="L569" title="1 of 8 branches missed.">        if (executrix.getOutput().equals(&quot;FILE&quot;) &amp;&amp; entries.size() == 1 &amp;&amp; contentFile == null &amp;&amp; !singleOutputAsChild) {</span>
<span class="fc" id="L570">            IBaseDataObject d = entries.get(0);</span>
<span class="fc" id="L571">            tData.setData(d.data());</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">            if (keepParentHashesForSingleChild) {</span>
<span class="fc" id="L573">                KffDataObjectHandler.removeHash(d);</span>
            }
<span class="fc" id="L575">            tData.putUniqueParameters(d.getParameters());</span>
<span class="fc" id="L576">            tData.setCurrentForm(d.currentForm());</span>
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">            if (!keepParentFiletypeForSingleChild) {</span>
<span class="nc" id="L578">                tData.setFileType(d.getFileType());</span>
            }
<span class="fc" id="L580">            return Collections.emptyList(); // so we just continue with current</span>
        }

        // Set the parent form after the addParentInformation call
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if (newParentForm != null) {</span>
<span class="fc" id="L585">            logger.debug(&quot;Pushing new parent form {}&quot;, newParentForm);</span>
<span class="fc" id="L586">            tData.pushCurrentForm(newParentForm);</span>
        }

<span class="fc" id="L589">        return entries;</span>
    }

    /**
     * Process an incoming payload returning attachments This entry point is shared among all synchronized, unsynchronized,
     * normal and heavy-duty processing entry points.
     * 
     * @param tData the payload to process
     * @return attachments
     */
    protected List&lt;IBaseDataObject&gt; processData(IBaseDataObject tData) throws ResourceException {
<span class="fc" id="L600">        return processData(tData, 0, tData.dataLength());</span>
    }


    /**
     * Process an incoming payload returning attachments, using only some of the data This entry point is shared among all
     * synchronized, unsynchronized, normal and heavy-duty processing entry points.
     * 
     * @param tData the payload to process
     * @param start offset in data to start
     * @param len length of data to use
     * @return attachments
     */
    protected List&lt;IBaseDataObject&gt; processData(@Nullable IBaseDataObject tData, int start, int len) throws ResourceException {
<span class="fc" id="L614">        List&lt;IBaseDataObject&gt; sprouts = new ArrayList&lt;&gt;();</span>

        // Validate parameters
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (tData == null) {</span>
<span class="nc" id="L618">            logger.debug(&quot;Received null data object!&quot;);</span>
<span class="nc" id="L619">            return sprouts;</span>
        }

        // Validate data
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        if (tData.data() == null) {</span>
<span class="nc" id="L624">            logger.debug(&quot;Received null data: {}&quot;, tData);</span>
<span class="nc" id="L625">            tData.addProcessingError(&quot;NULL data in &quot; + placeName + &quot;.process&quot;);</span>
<span class="nc" id="L626">            tData.pushCurrentForm(newErrorForm);</span>
<span class="nc" id="L627">            return sprouts;</span>
        }

        // Validate start and len
<span class="pc bpc" id="L631" title="3 of 6 branches missed.">        if (start &lt; 0 || len &lt;= 0 || (start + len) &gt; tData.dataLength()) {</span>
<span class="nc" id="L632">            logger.debug(&quot;Invalid start/len for data {}/{}&quot;, start, len);</span>
<span class="nc" id="L633">            tData.addProcessingError(&quot;Invalid data &quot; + start + &quot;/&quot; + len);</span>
<span class="nc" id="L634">            tData.pushCurrentForm(newErrorForm);</span>
<span class="nc" id="L635">            return sprouts;</span>
        }

<span class="fc" id="L638">        File f = null;</span>
<span class="fc" id="L639">        int result = -1;</span>
        try {
            // make the directory and write the input file.
<span class="fc" id="L642">            TempFileNames names = executrix.writeInputDataToNewTempDir(tData.data(), start, len);</span>
<span class="fc" id="L643">            f = new File(names.getInputFilename());</span>
<span class="fc" id="L644">            logger.debug(&quot;Wrote file out to {}&quot;, f.getPath());</span>

            // Create the command string and run it
<span class="fc" id="L647">            String[] cmd = executrix.getCommand(names);</span>
<span class="fc" id="L648">            StringBuilder parentData = new StringBuilder();</span>

<span class="fc" id="L650">            logger.debug(&quot;Generated command {}&quot;, Arrays.asList(cmd));</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">            if (executrix.getOutput().equals(&quot;FILE&quot;)) {</span>
<span class="fc" id="L653">                result = processCommand(cmd);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">            } else if (executrix.getOutput().equals(&quot;STD&quot;)) {</span>
<span class="fc" id="L655">                StringBuilder errbuf = new StringBuilder();</span>
<span class="fc" id="L656">                result = processCommand(cmd, parentData, errbuf);</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">                if (errbuf.length() &gt; 0) {</span>
<span class="nc" id="L658">                    tData.addProcessingError(errbuf.toString());</span>
                }
            }

            // Clean out any proxies that would cause an infinite loop.
            // we will add new forms later.
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            if (nukeMyProxies) {</span>
<span class="fc" id="L665">                nukeMyProxies(tData);</span>
            }
<span class="fc" id="L667">            logger.debug(&quot;Parent forms {}, nuke={}&quot;, tData.getAllCurrentForms(), nukeMyProxies);</span>

            // Generate the list of resulting files in the directory(s)
<span class="fc" id="L670">            List&lt;File&gt; files = getFileList(f.getParentFile(), f.getName());</span>

<span class="pc bpc" id="L672" title="1 of 4 branches missed.">            if (files != null &amp;&amp; !files.isEmpty()) {</span>
<span class="fc" id="L673">                sprouts = sproutResults(tData, files, f.getParent(), parentData);</span>
            }
<span class="nc" id="L675">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L676">            logger.error(&quot;Problem in command execution&quot;, ex);</span>
        } finally {
            // Delete the temporary directory and all of its contents.
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">            if (f != null) {</span>
<span class="fc" id="L680">                cleanupFiles(f.getParentFile());</span>
            }
        }

        // If there was no result, then report it in 2 places.
<span class="fc bfc" id="L685" title="All 2 branches covered.">        if (sprouts.isEmpty()) {</span>
<span class="fc" id="L686">            logger.debug(&quot;Command failed. nothing to sprout for file: result={}&quot;, result);</span>
<span class="fc" id="L687">            tData.addProcessingError(&quot;ERROR in &quot; + placeName + &quot;. Exec returned errno &quot; + result);</span>
<span class="fc" id="L688">            tData.pushCurrentForm(newErrorForm);</span>
        }
<span class="fc" id="L690">        return sprouts;</span>
    }

    /**
     * Execute the command and args in the array
     * 
     * @param cmd the command and args to execute
     * @return the process errno status value
     */
    protected int processCommand(String[] cmd) {
<span class="fc" id="L700">        return processCommand(cmd, new StringBuilder(), new StringBuilder());</span>
    }

    /**
     * Execute the command and args in the array
     * 
     * @param cmd the command and args to execute
     * @param stdout builder to append stdout from process
     * @param stderr builder to append stderr from process
     * @return the process errno status value
     */
    protected int processCommand(String[] cmd, StringBuilder stdout, StringBuilder stderr) {
<span class="fc" id="L712">        return executrix.execute(cmd, stdout, stderr, charset);</span>
    }


    /**
     * API Compatibility wrapper for Executrix cleanup method
     * 
     * @param tempDir the directory to remove
     */
    protected void cleanupFiles(File tempDir) {
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if (!keepFilesDebug) {</span>
<span class="nc" id="L723">            cleanupDirectory(tempDir);</span>
        }
<span class="fc" id="L725">    }</span>

    /**
     * API Compatibility wrapper for Executrix cleanup method
     * 
     * @param dir the directory to remove
     */
    protected void cleanupDirectory(File dir) {
<span class="nc" id="L733">        boolean status = Executrix.cleanupDirectory(dir);</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (!status) {</span>
<span class="nc" id="L735">            logger.debug(&quot;Could not remove temp directory {}&quot;, dir);</span>
        }
<span class="nc" id="L737">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>