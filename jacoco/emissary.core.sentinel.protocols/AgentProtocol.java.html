<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AgentProtocol.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.core.sentinel.protocols</a> &gt; <span class="el_source">AgentProtocol.java</span></div><h1>AgentProtocol.java</h1><pre class="source lang-java linenums">package emissary.core.sentinel.protocols;

import emissary.config.Configurator;
import emissary.core.Factory;
import emissary.core.IMobileAgent;
import emissary.core.Namespace;
import emissary.core.NamespaceException;
import emissary.core.sentinel.Sentinel;
import emissary.core.sentinel.protocols.rules.AllMaxTime;
import emissary.core.sentinel.protocols.rules.Rule;
import emissary.core.sentinel.protocols.trackers.AgentTracker;
import emissary.directory.DirectoryPlace;
import emissary.directory.KeyManipulator;
import emissary.pool.MobileAgentFactory;

import org.apache.commons.lang3.StringUtils;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * This protocol buckets places that are running in mobile agents and then looks at max and min time in place and the
 * number of agents that are potentially &quot;stuck.&quot; After places are bucketed, the place stats are run against the
 * configured rules to determine if all conditions are met. Once all rule conditions are met, then the configured action
 * will be triggered, i.e. log/notify.
 */
public class AgentProtocol extends Protocol {

    // key: agent name, value: how long Sentinel has observed the mobile agent
<span class="pc" id="L35">    protected final Map&lt;String, AgentTracker&gt; trackers = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L37">    public AgentProtocol() {}</span>

    public AgentProtocol(Configurator config) {
<span class="nc" id="L40">        super(config);</span>
<span class="nc" id="L41">    }</span>

    @Override
    protected Rule&lt;PlaceAgentStats&gt; getRule(final String ruleId) throws IOException {
        try {
<span class="fc" id="L46">            Map&lt;String, String&gt; map = config.findStringMatchMap(ruleId + &quot;_&quot;);</span>
<span class="fc" id="L47">            String rule = map.getOrDefault(&quot;RULE&quot;, AllMaxTime.class.getName());</span>
<span class="fc" id="L48">            return (Rule) Factory.create(rule, ruleId, validate(map.get(&quot;PLACE_MATCHER&quot;)), map.get(&quot;TIME_LIMIT_MINUTES&quot;),</span>
<span class="fc" id="L49">                    map.get(&quot;PLACE_THRESHOLD&quot;));</span>
<span class="nc" id="L50">        } catch (NamespaceException e) {</span>
<span class="nc" id="L51">            throw new IOException(e);</span>
        }
    }

    /**
     * Validate the place exists in the {@link Namespace}
     *
     * @param place the name of the place
     * @throws NamespaceException if the directory place does not exist
     * @throws IllegalStateException if the place cannot be found
     */
    protected String validate(final String place) throws NamespaceException {
        // validate that the place exists
<span class="fc" id="L64">        DirectoryPlace directoryPlace = Namespace.lookup(DirectoryPlace.class).iterator().next();</span>
<span class="fc" id="L65">        if (directoryPlace.getEntries().stream()</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">                .noneMatch(entry -&gt; KeyManipulator.getServiceClassname(entry.getFullKey()).matches(place))) {</span>
<span class="fc" id="L67">            throw new IllegalStateException(&quot;Place not found in the directory&quot;);</span>
        }
<span class="fc" id="L69">        return place;</span>
    }

    /**
     * Checks to see if the mobile agents are processing the same data since the last polling event
     *
     * @throws IOException if there is a problem looking up resources in the {@link Namespace}
     */
    @Override
    public void run() throws IOException {
        try {
<span class="fc" id="L80">            List&lt;String&gt; agentKeys = Namespace.keySet().stream()</span>
<span class="fc" id="L81">                    .filter(k -&gt; k.startsWith(MobileAgentFactory.AGENT_NAME))</span>
<span class="fc" id="L82">                    .sorted()</span>
<span class="fc" id="L83">                    .collect(Collectors.toList());</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            for (String agentKey : agentKeys) {</span>
<span class="fc" id="L85">                updateTracker(agentKey);</span>
<span class="fc" id="L86">            }</span>
<span class="fc" id="L87">            runRules(trackers);</span>
<span class="nc" id="L88">        } catch (NamespaceException e) {</span>
<span class="nc" id="L89">            throw new IOException(&quot;There was an issue running protocol&quot;, e);</span>
<span class="fc" id="L90">        }</span>
<span class="fc" id="L91">    }</span>

    /**
     * Checks to see if the mobile agent is processing the same data since the last polling event
     *
     * @param agentKey the agent key, i.e. MobileAgent-01
     * @throws NamespaceException if there is a problem looking up resources in the {@link Namespace}
     */
    protected void updateTracker(final String agentKey) throws NamespaceException {
<span class="fc" id="L100">        logger.trace(&quot;Searching for agent [{}]&quot;, agentKey);</span>
<span class="fc" id="L101">        IMobileAgent mobileAgent = (IMobileAgent) Namespace.lookup(agentKey);</span>
<span class="fc" id="L102">        AgentTracker trackedAgent = trackers.computeIfAbsent(mobileAgent.getName(), AgentTracker::new);</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (mobileAgent.isInUse()) {</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">            if (!Objects.equals(mobileAgent.agentId(), trackedAgent.getAgentId())</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">                    || !Objects.equals(mobileAgent.getLastPlaceProcessed(), trackedAgent.getDirectoryEntryKey())) {</span>
<span class="fc" id="L106">                trackedAgent.clear();</span>
<span class="fc" id="L107">                trackedAgent.setAgentId(mobileAgent.agentId());</span>
<span class="fc" id="L108">                trackedAgent.setDirectoryEntryKey(mobileAgent.getLastPlaceProcessed());</span>
            }
<span class="fc" id="L110">            trackedAgent.incrementTimer(Sentinel.lookup().getPollingInterval());</span>
<span class="fc" id="L111">            logger.trace(&quot;Agent acquired {}&quot;, trackedAgent);</span>
        } else {
<span class="nc" id="L113">            trackedAgent.clear();</span>
<span class="nc" id="L114">            logger.trace(&quot;Agent not in use [{}]&quot;, agentKey);</span>
        }
<span class="fc" id="L116">    }</span>

    /**
     * Run the configured rules over the watched mobile-agents
     */
    public void runRules(Map&lt;String, AgentTracker&gt; trackers) {

<span class="fc" id="L123">        Map&lt;String, PlaceAgentStats&gt; placeAgentStats = generatePlaceAgentStats(trackers);</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (!placeAgentStats.isEmpty()) {</span>
<span class="fc" id="L125">            logger.debug(&quot;Running rules on agents {}&quot;, placeAgentStats);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            if (rules.values().stream().allMatch(rule -&gt; rule.condition(placeAgentStats.values()))) {</span>
<span class="fc" id="L127">                logger.warn(&quot;Sentinel rules matched -- {}&quot;, rules.values());</span>
<span class="fc" id="L128">                action.trigger((Map) trackers);</span>
            }
        }
<span class="fc" id="L131">    }</span>

    protected Map&lt;String, PlaceAgentStats&gt; generatePlaceAgentStats(Map&lt;String, AgentTracker&gt; trackers) {
<span class="fc" id="L134">        Map&lt;String, PlaceAgentStats&gt; placeAgentStats = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (AgentTracker tracker : trackers.values()) {</span>
<span class="fc" id="L136">            String placeKey = tracker.getPlaceName();</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (StringUtils.isNotBlank(placeKey)) {</span>
<span class="fc" id="L138">                placeAgentStats.put(placeKey, placeAgentStats.getOrDefault(placeKey, new PlaceAgentStats(placeKey)).update(tracker.getTimer()));</span>
            }
<span class="fc" id="L140">        }</span>
<span class="fc" id="L141">        return placeAgentStats;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L146">        return new StringJoiner(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;)</span>
<span class="fc" id="L147">                .add(&quot;\&quot;rules\&quot;:&quot; + rules.values())</span>
<span class="fc" id="L148">                .add(&quot;\&quot;action\&quot;:&quot; + action)</span>
<span class="fc" id="L149">                .toString();</span>
    }

    public static class PlaceAgentStats {

        private final String place;
        private int count;
<span class="fc" id="L156">        private long maxTimeInPlace = -1;</span>
<span class="fc" id="L157">        private long minTimeInPlace = -1;</span>

<span class="fc" id="L159">        public PlaceAgentStats(String place) {</span>
<span class="fc" id="L160">            this.place = place;</span>
<span class="fc" id="L161">        }</span>

        public String getPlace() {
<span class="fc" id="L164">            return place;</span>
        }

        public int getCount() {
<span class="fc" id="L168">            return count;</span>
        }

        public long getMaxTimeInPlace() {
<span class="fc" id="L172">            return maxTimeInPlace;</span>
        }

        public long getMinTimeInPlace() {
<span class="fc" id="L176">            return minTimeInPlace;</span>
        }

        public PlaceAgentStats update(long timer) {
<span class="fc" id="L180">            this.count++;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            this.minTimeInPlace = this.minTimeInPlace &lt; 0 ? timer : Math.min(this.minTimeInPlace, timer);</span>
<span class="fc" id="L182">            this.maxTimeInPlace = Math.max(this.maxTimeInPlace, timer);</span>
<span class="fc" id="L183">            return this;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>