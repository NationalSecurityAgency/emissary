<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Startup.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.admin</a> &gt; <span class="el_source">Startup.java</span></div><h1>Startup.java</h1><pre class="source lang-java linenums">package emissary.admin;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.config.ServiceConfigGuide;
import emissary.core.EmissaryException;
import emissary.core.EmissaryRuntimeException;
import emissary.core.Namespace;
import emissary.directory.DirectoryEntry;
import emissary.directory.DirectoryPlace;
import emissary.directory.EmissaryNode;
import emissary.directory.IDirectoryPlace;
import emissary.directory.KeyManipulator;
import emissary.pickup.PickUpPlace;
import emissary.place.CoordinationPlace;
import emissary.place.IServiceProviderPlace;
import emissary.server.EmissaryServer;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import javax.annotation.Nullable;

public class Startup {

    public static final int DIRECTORYSTART = 0;
    public static final int DIRECTORYADD = 1;
    public static final int DIRECTORYDELETE = 2;
    public static final String ACTIONADD = &quot;-add&quot;;
    public static final String ACTIONDELETE = &quot;-delete&quot;;
    public static final String ACTIONSTART = &quot;-start&quot;;

    private static final String PARALLEL_PLACE_STARTUP_CONFIG = &quot;PARALLEL_PLACE_STARTUP&quot;;
    @SuppressWarnings(&quot;NonFinalStaticField&quot;)
<span class="fc" id="L49">    static int directoryAction = DIRECTORYADD;</span>

    // If we are an emissary node these will be present
    private final EmissaryNode node;

    // Our logger
<span class="fc" id="L55">    private static final Logger logger = LoggerFactory.getLogger(Startup.class);</span>

    // The startup config object
<span class="fc" id="L58">    @Nullable</span>
    protected Configurator hostsConfig = null;

    // Successfully started directories
<span class="fc" id="L62">    protected final Map&lt;String, String&gt; localDirectories = new ConcurrentHashMap&lt;&gt;();</span>

    // Failed directories
<span class="fc" id="L65">    protected final Map&lt;String, String&gt; failedLocalDirectories = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L67">    protected final Set&lt;String&gt; failedPlaces = ConcurrentHashMap.newKeySet();</span>

    // Collection of the places as they finish coming up
<span class="fc" id="L70">    protected static final Map&lt;String, String&gt; places = new ConcurrentHashMap&lt;&gt;();</span>

    // Collection of places that are being started
<span class="fc" id="L73">    protected final Set&lt;String&gt; placesToStart = ConcurrentHashMap.newKeySet();</span>

    // sorted lists of the place types, grouped by hostname
<span class="fc" id="L76">    protected final Map&lt;String, Set&lt;String&gt;&gt; placeLists = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L77">    protected final Map&lt;String, Set&lt;String&gt;&gt; pickupLists = new ConcurrentHashMap&lt;&gt;();</span>

    // sets to keep track of possible invisible place startup
<span class="fc" id="L80">    protected static final Set&lt;String&gt; activeDirPlaces = new LinkedHashSet&lt;&gt;();</span>
<span class="fc" id="L81">    protected static final Set&lt;String&gt; placeAlreadyStarted = new LinkedHashSet&lt;&gt;();</span>

    // invisible place startups occurred in strict mode
    @SuppressWarnings(&quot;NonFinalStaticField&quot;)
<span class="fc" id="L85">    protected static boolean invisPlacesStartedInStrictMode = false;</span>

    /**
     * n return the full DNS name and port without the protocol part
     */
    public static String placeHost(final String key) {
<span class="fc" id="L91">        return KeyManipulator.getServiceHost(key);</span>
    }

    /**
     * return the type of place specified Key manipulator does not work on this, though it seems to if the key has dots in
     * the hostname like many do.
     */
    public static String placeName(final String key) {
<span class="fc" id="L99">        final int pos = key.lastIndexOf(&quot;/&quot;);</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">        if (pos != -1) {</span>
<span class="fc" id="L101">            return key.substring(pos + 1);</span>
        }
<span class="nc" id="L103">        return key;</span>
    }

    /**
     * Set the action based on the command line argument
     */
    public static int setAction(final String optarg) {
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (ACTIONADD.equalsIgnoreCase(optarg)) {</span>
<span class="nc" id="L111">            return DIRECTORYADD;</span>
        }

<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (ACTIONDELETE.equalsIgnoreCase(optarg)) {</span>
<span class="nc" id="L115">            return DIRECTORYDELETE;</span>
        }

        // default
<span class="nc" id="L119">        return DIRECTORYSTART;</span>
    }

    private static String makeConfig(final String path, final String file) {
<span class="nc bnc" id="L123" title="All 4 branches missed.">        if (file.startsWith(&quot;/&quot;) &amp;&amp; new File(file).exists()) {</span>
<span class="nc" id="L124">            return file;</span>
        }
<span class="nc" id="L126">        return ConfigUtil.getConfigFile(path, file);</span>
    }

    /**
     * The main entry point
     */
    @SuppressWarnings(&quot;SystemOut&quot;)
    public static void main(final String[] args) throws IOException, EmissaryException {


        //
        // Evaluate arguments to the static main
        //
        // Need config path and startup config file on command line
<span class="nc bnc" id="L140" title="All 4 branches missed.">        if (args.length &lt; 1 || args.length &gt; 3) {</span>
<span class="nc" id="L141">            System.err.println(&quot;Usage: java emissary.admin.Startup &quot; + &quot;[-start|-add|-delete] [config_path] config_file&quot;);</span>
<span class="nc" id="L142">            return;</span>
        }

        final String startupConfigFile;
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (args.length == 1) {</span>
<span class="nc" id="L147">            directoryAction = setAction(ACTIONSTART);</span>
<span class="nc bnc" id="L148" title="All 4 branches missed.">            if (args[0].startsWith(&quot;/&quot;) || args[0].toUpperCase(Locale.getDefault()).startsWith(&quot;HTTP&quot;)) {</span>
<span class="nc" id="L149">                startupConfigFile = args[0];</span>
            } else {
<span class="nc" id="L151">                startupConfigFile = ConfigUtil.getConfigFile(args[0]);</span>
            }
<span class="nc bnc" id="L153" title="All 2 branches missed.">        } else if (args.length == 2) {</span>
<span class="nc" id="L154">            directoryAction = setAction(ACTIONSTART);</span>
<span class="nc" id="L155">            startupConfigFile = makeConfig(args[0], args[1]);</span>
        } else {
<span class="nc" id="L157">            directoryAction = setAction(args[0]);</span>
<span class="nc" id="L158">            startupConfigFile = makeConfig(args[1], args[2]);</span>
        }

<span class="nc" id="L161">        final Startup start = new Startup(startupConfigFile, new EmissaryNode());</span>
<span class="nc" id="L162">        start.start();</span>

<span class="nc" id="L164">        logger.info(&quot;The system is up and running fine. All ahead Warp-7.&quot;);</span>
<span class="nc" id="L165">    }</span>


    /**
     * Start the system
     */
    public void start() throws EmissaryException {
<span class="fc" id="L172">        final boolean bootStatus = bootstrap();</span>

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (!bootStatus) {</span>
<span class="nc" id="L175">            throw new EmissaryException(&quot;Unable to bootstrap the system&quot;);</span>
        }

        // bootstrap now only starts the processing places (this allows
        // derived classes to hold off starting the pickup places until
        // they've completed their own set-up). So we have to startup
        // the pickup places here.
<span class="fc" id="L182">        startPickUpPlaces();</span>

<span class="pc bpc" id="L184" title="3 of 4 branches missed.">        if (!verifyNoInvisiblePlacesStarted() &amp;&amp; node.isStrictStartupMode()) {</span>
<span class="nc" id="L185">            invisPlacesStartedInStrictMode = true;</span>
        }
<span class="fc" id="L187">    }</span>


    // $AUTO: Constructors.

    /**
     * Class constructor loads the config file
     */
    public Startup(final String startupConfigFile, EmissaryNode node) throws IOException {
        // Read in startup config file specifying place/host setup
<span class="nc" id="L197">        this(new ServiceConfigGuide(startupConfigFile), node);</span>
<span class="nc" id="L198">    }</span>

    public Startup(final InputStream startupConfigStream, EmissaryNode node) throws IOException {
<span class="nc" id="L201">        this(new ServiceConfigGuide(startupConfigStream), node);</span>
<span class="nc" id="L202">    }</span>

<span class="fc" id="L204">    public Startup(final Configurator config, EmissaryNode node) {</span>
<span class="fc" id="L205">        this.hostsConfig = config;</span>
<span class="fc" id="L206">        this.node = node;</span>
<span class="fc" id="L207">    }</span>

    public boolean bootstrap() {

        //
        // Setup the Local Directories in a hashtable
        //
<span class="fc" id="L214">        final boolean status = localDirectorySetup(this.localDirectories);</span>

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (!status) {</span>
<span class="nc" id="L217">            logger.warn(&quot;Startup: local directory setup failed.&quot;);</span>
<span class="nc" id="L218">            return false;</span>
        }

        //
        // Set up the rest of the Places except no pickups
        //
<span class="fc" id="L224">        sortPlaces(this.hostsConfig.findEntries(&quot;PLACE&quot;));</span>

<span class="fc" id="L226">        logger.info(&quot;Ready to start {} place(s) and {} PickUp place(s).&quot;, hashListSize(this.placeLists), hashListSize(this.pickupLists));</span>

<span class="fc" id="L228">        logger.info(&quot;Processing non-pickup places...&quot;);</span>
<span class="fc" id="L229">        startMapOfPlaces(this.placeLists);</span>

        //
        // Wait for all places to get started and registered
        //
<span class="fc" id="L234">        this.stopAndWaitForPlaceCreation();</span>

<span class="fc" id="L236">        logger.debug(&quot;Done with bootstrap phase&quot;);</span>
<span class="fc" id="L237">        return true;</span>
    }

    /**
     * Start all the pickup places and wait for them to finish
     */
    void startPickUpPlaces() {

<span class="fc" id="L245">        startMapOfPlaces(this.pickupLists);</span>

<span class="fc" id="L247">        logger.info(&quot;Processing pickup places...&quot;);</span>

        //
        // Wait for all places to get started and registered
        //
<span class="fc" id="L252">        stopAndWaitForPlaceCreation();</span>

<span class="fc" id="L254">    }</span>

    void startMapOfPlaces(final Map&lt;String, Set&lt;String&gt;&gt; m) {

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (hashListSize(m) &gt; 0) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            for (final Set&lt;String&gt; placeList : m.values()) {</span>
<span class="nc" id="L260">                final boolean status = placeSetup(directoryAction, this.localDirectories, places, placeList);</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (!status) {</span>
<span class="nc" id="L263">                    logger.warn(&quot;Startup: places setup failed!&quot;);</span>
<span class="nc" id="L264">                    return;</span>
                }
<span class="nc" id="L266">            }</span>

        }

<span class="fc" id="L270">        logger.debug(&quot;done with map of {} places&quot;, hashListSize(m));</span>
<span class="fc" id="L271">    }</span>

    /**
     * Count all entries in lists of a map
     */
    private static int hashListSize(@Nullable final Map&lt;String, Set&lt;String&gt;&gt; m) {
<span class="fc" id="L277">        int total = 0;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (m != null) {</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            for (final Set&lt;String&gt; l : m.values()) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                if (l != null) {</span>
<span class="nc" id="L281">                    total += l.size();</span>
                }
<span class="nc" id="L283">            }</span>
        }
<span class="fc" id="L285">        return total;</span>
    }

    protected boolean localDirectorySetup(final Map&lt;String, String&gt; localDirectoriesArg) {

<span class="fc" id="L290">        final List&lt;String&gt; hostParameters = this.hostsConfig.findEntries(&quot;LOCAL_DIRECTORY&quot;);</span>

<span class="fc" id="L292">        final long start = System.currentTimeMillis();</span>
<span class="fc" id="L293">        final Map&lt;String, String&gt; dirStarts = new HashMap&lt;&gt;();</span>
<span class="fc" id="L294">        EmissaryNode emissaryNode = EmissaryServer.getInstance().getNode();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (final String thePlaceLocation : hostParameters) {</span>

<span class="fc" id="L297">            final String host = placeHost(thePlaceLocation);</span>

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            if (KeyManipulator.isLocalTo(thePlaceLocation, &quot;http://&quot; + this.node.getNodeName() + &quot;:&quot; + this.node.getNodePort() + &quot;/StartupEngine&quot;)) {</span>
<span class="fc" id="L300">                final String thePlaceClassStr = PlaceStarter.getClassString(thePlaceLocation);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L302">                    logger.info(&quot;Doing local startup for directory {}({}) &quot;, getLocationName(thePlaceLocation), thePlaceClassStr);</span>
                }
<span class="fc" id="L304">                final IServiceProviderPlace p = PlaceStarter.createPlace(thePlaceLocation, null, thePlaceClassStr, null, emissaryNode);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                if (p != null) {</span>
<span class="fc" id="L306">                    dirStarts.put(host, thePlaceLocation);</span>
<span class="fc" id="L307">                    localDirectoriesArg.put(host, p.toString());</span>
                } else {
<span class="nc" id="L309">                    localDirectoriesArg.remove(thePlaceLocation);</span>
<span class="nc" id="L310">                    logger.warn(&quot;Giving up on directory {}&quot;, thePlaceLocation);</span>
                }
<span class="fc" id="L312">            } else {</span>
<span class="nc" id="L313">                logger.warn(&quot;Directory location is not local: {}&quot;, thePlaceLocation);</span>
            }
<span class="fc" id="L315">        }</span>

        // All local directories must be up before proceeding
<span class="fc" id="L318">        logger.debug(&quot;Waiting for all local directories to start, expecting {}&quot;, dirStarts.size());</span>
<span class="fc" id="L319">        int prevCount = 0;</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">        while (localDirectoriesArg.size() + this.failedLocalDirectories.size() &lt; dirStarts.size()) {</span>
<span class="nc" id="L321">            final int newCount = localDirectoriesArg.size() + this.failedLocalDirectories.size();</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">            if (newCount &gt; prevCount &amp;&amp; newCount &lt; dirStarts.size()) {</span>
<span class="nc" id="L323">                logger.info(&quot;Completed {} of {} local directories&quot;, localDirectoriesArg.size(), dirStarts.size());</span>
<span class="nc" id="L324">                prevCount = newCount;</span>
            }

            try {
<span class="nc" id="L328">                Thread.sleep(10);</span>
<span class="nc" id="L329">            } catch (InterruptedException e) {</span>
<span class="nc" id="L330">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L331">            }</span>
<span class="nc" id="L332">        }</span>

<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L335">            logger.debug(&quot;Directories all up in {}s&quot;, (System.currentTimeMillis() - start) / 1000.0);</span>
        }

<span class="fc" id="L338">        return true;</span>
    }

    /**
     * Start all places on the list on a thread, return control immediately. All places in hostParameters list must be for
     * the same host:port!
     */
    protected boolean placeSetup(final int directoryActionArg, final Map&lt;String, String&gt; localDirectoriesArg, final Map&lt;String, String&gt; placesArg,
            final Set&lt;String&gt; hostParameters) {

        // Track how many places we are trying to start
<span class="nc" id="L349">        this.placesToStart.addAll(hostParameters);</span>

<span class="nc" id="L351">        final Thread t = new Thread(() -&gt; {</span>

<span class="nc" id="L353">            final String thePlaceHost = placeHost(hostParameters.stream().findFirst().get());</span>

<span class="nc" id="L355">            final String localDirectory = localDirectoriesArg.get(thePlaceHost);</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (localDirectory == null) {</span>
<span class="nc" id="L358">                hostParameters.forEach(placesToStart::remove);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (failedLocalDirectories.get(thePlaceHost) != null) {</span>
<span class="nc" id="L360">                    logger.warn(&quot;Skipping {} due to previously failed directory&quot;, thePlaceHost);</span>
                } else {
<span class="nc" id="L362">                    logger.warn(&quot;Skipping {} due to local Directory not found&quot;, thePlaceHost);</span>
                }
<span class="nc" id="L364">                return;</span>
            }

<span class="nc bnc" id="L367" title="All 4 branches missed.">            if (directoryActionArg != DIRECTORYSTART &amp;&amp; directoryActionArg != DIRECTORYADD) {</span>
<span class="nc" id="L368">                hostParameters.forEach(placesToStart::remove);</span>
<span class="nc" id="L369">                return;</span>
            }

<span class="nc" id="L372">            logger.debug(&quot;Using localDir={} to create {} places on {}&quot;, localDirectory, hostParameters.size(), thePlaceHost);</span>

            // Create a stream of places that can be configured to start in parallel
<span class="nc" id="L375">            boolean parallelPlaceStartup = hostsConfig.findBooleanEntry(PARALLEL_PLACE_STARTUP_CONFIG, false);</span>
<span class="nc" id="L376">            Stream&lt;String&gt; hostParametersStream = StreamSupport.stream(hostParameters.spliterator(), parallelPlaceStartup);</span>
<span class="nc" id="L377">            logger.info(&quot;Using parallel place startup: {}&quot;, hostParametersStream.isParallel());</span>

            // Start everything in hostParameters
            // (PLACE lines from cfg file for a given host
<span class="nc" id="L381">            hostParametersStream.forEach(thePlaceLocation -&gt; {</span>
<span class="nc" id="L382">                placeName(thePlaceLocation);</span>

                // Get the class name and Class object for what we want to make
<span class="nc" id="L385">                final String thePlaceLocName = getLocationName(thePlaceLocation);</span>
<span class="nc" id="L386">                final String thePlaceClassString = PlaceStarter.getClassString(thePlaceLocation);</span>
<span class="nc" id="L387">                StringBuilder startupBuilder =</span>
                        new StringBuilder(&quot;Doing local startup on &quot;)
<span class="nc" id="L389">                                .append(thePlaceLocName)</span>
<span class="nc" id="L390">                                .append(&quot;(&quot;)</span>
<span class="nc" id="L391">                                .append(thePlaceClassString).append(&quot;)...&quot;);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (thePlaceClassString == null) {</span>
<span class="nc" id="L393">                    startupBuilder.append(&quot;skipping, no class string!!&quot;);</span>
<span class="nc" id="L394">                    placesToStart.remove(thePlaceLocation);</span>
<span class="nc" id="L395">                    logger.warn(startupBuilder.toString());</span>
<span class="nc" id="L396">                    return;</span>
                }
<span class="nc" id="L398">                logger.debug(&quot;Starting place {}&quot;, thePlaceLocation);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (KeyManipulator.isLocalTo(thePlaceLocation, String.format(&quot;http://%s:%s/StartupEngine&quot;, node.getNodeName(), node.getNodePort()))) {</span>
<span class="nc bnc" id="L400" title="All 4 branches missed.">                    if (directoryActionArg == DIRECTORYADD &amp;&amp; Namespace.exists(thePlaceLocation)) {</span>
                        // logger.info(&quot;Local place already exists: {}&quot;, thePlaceLocation);
<span class="nc" id="L402">                        startupBuilder.append(&quot;local place already exists&quot;);</span>
<span class="nc" id="L403">                        placesToStart.remove(thePlaceLocation);</span>
                        // add place to placeAlreadyStarted list, so can be verified in verifyNoInvisibleStartPlaces
<span class="nc" id="L405">                        placeAlreadyStarted.add(thePlaceLocation.substring(thePlaceLocation.lastIndexOf(&quot;/&quot;) + 1));</span>
<span class="nc" id="L406">                        logger.info(startupBuilder.toString());</span>
<span class="nc" id="L407">                        return;</span>
                    }

<span class="nc" id="L410">                    final IServiceProviderPlace p = PlaceStarter.createPlace(thePlaceLocation, null, thePlaceClassString, localDirectory);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    if (p != null) {</span>
<span class="nc" id="L412">                        placesArg.put(thePlaceLocation, thePlaceLocation);</span>
<span class="nc" id="L413">                        startupBuilder.append(&quot;done!&quot;);</span>
<span class="nc" id="L414">                        logger.info(startupBuilder.toString());</span>
                    } else {
                        // logger.error(&quot;{} failed to start!&quot;, thePlaceLocation);
<span class="nc" id="L417">                        failedPlaces.add(thePlaceLocation);</span>
<span class="nc" id="L418">                        placesToStart.remove(thePlaceLocation);</span>
<span class="nc" id="L419">                        startupBuilder.append(&quot;FAILED!!&quot;);</span>
<span class="nc" id="L420">                        logger.error(startupBuilder.toString());</span>
                    }
                }
<span class="nc" id="L423">            });</span>
<span class="nc" id="L424">        });</span>
<span class="nc" id="L425">        t.start();</span>
<span class="nc" id="L426">        return true;</span>
    }

    /**
     * Check to see if all the places have started and been registered in the directory. This doesn't account for
     * directories, just things started with a &quot;PLACE&quot; tag
     */
    protected void stopAndWaitForPlaceCreation() {
<span class="fc" id="L434">        int numPlacesExpected = this.placesToStart.size();</span>
        int numPlacesFound;
<span class="fc" id="L436">        int numPlacesFoundPreviously = 0;</span>

<span class="fc" id="L438">        logger.info(&quot;Waiting for {} places to start {}&quot;, placesToStart.size(),</span>
<span class="pc" id="L439">                placesToStart.stream().map(s -&gt; StringUtils.substringAfterLast(s, &quot;/&quot;)).sorted().collect(Collectors.toList()));</span>
        do {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            if (this.placesToStart.size() != numPlacesExpected) {</span>
<span class="nc" id="L442">                logger.info(&quot;Now waiting for {} places to start. (originally {} places)&quot;, this.placesToStart.size(), numPlacesExpected);</span>
<span class="nc" id="L443">                numPlacesExpected = this.placesToStart.size();</span>
            }

<span class="fc" id="L446">            numPlacesFound = places.size();</span>

<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            if (numPlacesFound &gt;= numPlacesExpected) {</span>
<span class="fc" id="L449">                boolean failedPlaceStartups = false;</span>

<span class="pc bpc" id="L451" title="1 of 2 branches missed.">                if (!this.failedPlaces.isEmpty()) {</span>
<span class="nc" id="L452">                    failedPlaceStartups = true;</span>
<span class="nc" id="L453">                    String failedPlaceList = String.join(&quot;; &quot;, this.failedPlaces);</span>
<span class="nc" id="L454">                    logger.warn(&quot;The following places have failed to start: {}&quot;, failedPlaceList);</span>
                }
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">                if (!CoordinationPlace.getFailedCoordinationPlaces().isEmpty()) {</span>
<span class="nc" id="L457">                    failedPlaceStartups = true;</span>
<span class="nc" id="L458">                    String failedCoordPlaceList = String.join(&quot;; &quot;, CoordinationPlace.getFailedCoordinationPlaces());</span>
<span class="nc" id="L459">                    logger.warn(&quot;The following coordination places have failed to start: {}&quot;, failedCoordPlaceList);</span>
                }

                // check if strict startup &amp; places/coordination places failed, if yes, shut down server
<span class="pc bpc" id="L463" title="3 of 4 branches missed.">                if (this.node.isStrictStartupMode() &amp;&amp; failedPlaceStartups) {</span>
<span class="nc" id="L464">                    logger.error(&quot;Server failed to start due to Strict mode being enabled.  To disable strict mode, &quot; +</span>
                            &quot;run server start command without the --strict flag&quot;);
<span class="nc" id="L466">                    logger.error(&quot;Server shutting down&quot;);</span>
<span class="nc" id="L467">                    System.exit(1);</span>
                }

                // normal termination of the loop
<span class="fc" id="L471">                logger.debug(&quot;Woohoo! {} of {} places are up and running.&quot;, numPlacesFound, numPlacesExpected);</span>
<span class="fc" id="L472">                break;</span>
            }

            try {
<span class="nc" id="L476">                Thread.sleep(500);</span>
<span class="nc" id="L477">            } catch (InterruptedException e) {</span>
<span class="nc" id="L478">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L479">            }</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (numPlacesFound != numPlacesFoundPreviously) {</span>
<span class="nc" id="L482">                numPlacesFoundPreviously = numPlacesFound;</span>

<span class="nc" id="L484">                final float percentageUp = (float) numPlacesFound / (float) numPlacesExpected;</span>
                final String leadString;
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (percentageUp &lt; 0.20) {</span>
<span class="nc" id="L487">                    leadString = &quot;Hmmm... only &quot;;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                } else if (percentageUp &lt; 0.40) {</span>
<span class="nc" id="L489">                    leadString = &quot;Ok, now &quot;;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                } else if (percentageUp &lt; 0.60) {</span>
<span class="nc" id="L491">                    leadString = &quot;Making progress, &quot;;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                } else if (percentageUp &lt; 0.80) {</span>
<span class="nc" id="L493">                    leadString = &quot;Over half way there! &quot;;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                } else if (percentageUp &lt; 0.95) {</span>
<span class="nc" id="L495">                    leadString = &quot;Almost ready! &quot;;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                } else if (numPlacesFound + 1 == numPlacesExpected) {</span>
<span class="nc" id="L497">                    leadString = &quot;One more to go... &quot;;</span>
                } else {
<span class="nc" id="L499">                    leadString = &quot;Yeah! &quot;;</span>
                }

<span class="nc" id="L502">                logger.debug(&quot;{}{} of {} places are up and running.&quot;, leadString, numPlacesFound, numPlacesExpected);</span>
<span class="nc" id="L503">            }</span>

        } while (true); // break terminated loop
<span class="fc" id="L506">    }</span>

    /**
     * sort all the PLACE entries into either a processing place or a pickup place
     */
    protected void sortPlaces(final List&lt;String&gt; placeList) {

<span class="pc bpc" id="L513" title="1 of 2 branches missed.">        for (final String location : placeList) {</span>
<span class="nc" id="L514">            final String className = PlaceStarter.getClassString(location);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (className == null) {</span>
<span class="nc" id="L516">                continue;</span>
            }

            try {
<span class="nc bnc" id="L520" title="All 2 branches missed.">                sortPickupOrPlace(location, PickUpPlace.implementsPickUpPlace(Class.forName(className)) ? this.pickupLists : this.placeLists);</span>
<span class="nc" id="L521">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L522">                logger.error(&quot;Could not create place {}&quot;, className, e);</span>
<span class="nc" id="L523">            }</span>
<span class="nc" id="L524">        }</span>
<span class="fc" id="L525">    }</span>

    private static void sortPickupOrPlace(String theLocation, Map&lt;String, Set&lt;String&gt;&gt; placeList) {
<span class="nc" id="L528">        final String host = placeHost(theLocation);</span>
<span class="nc" id="L529">        Set&lt;String&gt; l = placeList.computeIfAbsent(host, k -&gt; new LinkedHashSet&lt;&gt;());</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (l.contains(theLocation)) {</span>
<span class="nc" id="L531">            logger.warn(&quot;Sorting places found duplicate {}({}), skipping!&quot;, getLocationName(theLocation), PlaceStarter.getClassString(theLocation));</span>
        } else {
<span class="nc" id="L533">            l.add(theLocation);</span>
        }
<span class="nc" id="L535">    }</span>

    protected static String getLocationName(String location) {
<span class="fc" id="L538">        return StringUtils.substringAfterLast(location, &quot;/&quot;);</span>
    }

    /**
     * Verifies the active directory places vs places started up. Log if any places are started without being announced in
     * start-up.
     *
     * @return true if no invisible places started, false if yes
     */
    public static boolean verifyNoInvisiblePlacesStarted() {
        try {
<span class="fc" id="L549">            IDirectoryPlace dirPlace = DirectoryPlace.lookup();</span>
<span class="fc" id="L550">            List&lt;DirectoryEntry&gt; dirEntries = dirPlace.getEntries();</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">            for (DirectoryEntry entry : dirEntries) {</span>
                // add place names of active places. getLocalPlace() returns null for any place that failed to start
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (entry.getLocalPlace() != null) {</span>
<span class="fc" id="L554">                    activeDirPlaces.add(entry.getLocalPlace().getPlaceName());</span>
                }
<span class="fc" id="L556">            }</span>

            // remove DirectoryPlace from activeDirPlaces. DirectoryPlace is started up automatically in order to
            // start all other places, so it isn't per se &quot;announced&quot;, but it is known and logged
<span class="fc" id="L560">            activeDirPlaces.removeIf(dir -&gt; dir.equalsIgnoreCase(&quot;DirectoryPlace&quot;));</span>
<span class="nc" id="L561">        } catch (EmissaryException e) {</span>
<span class="nc" id="L562">            throw new EmissaryRuntimeException(e);</span>
<span class="fc" id="L563">        }</span>

        // compares place names in active dirs and active places, removes them from set if found
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        for (String thePlaceLocation : places.values()) {</span>
<span class="nc" id="L567">            activeDirPlaces.removeIf(dir -&gt; dir.equalsIgnoreCase(placeName(thePlaceLocation)));</span>
<span class="nc" id="L568">        }</span>

        // places that are attempted to startup but are already up are added to separate list
        // this will only check if places are added to that list
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if (!placeAlreadyStarted.isEmpty()) {</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            for (String thePlaceLocation : placeAlreadyStarted) {</span>
<span class="nc" id="L574">                activeDirPlaces.removeIf(dir -&gt; dir.equalsIgnoreCase(thePlaceLocation));</span>
<span class="nc" id="L575">            }</span>
        }

        // if any places are left in active dir keys, they are places not announced on startup
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (!activeDirPlaces.isEmpty()) {</span>
<span class="nc" id="L580">            logger.warn(&quot;{} place(s) started up without being announced! {}&quot;, activeDirPlaces.size(), activeDirPlaces);</span>
<span class="nc" id="L581">            return false;</span>
        }

<span class="fc" id="L584">        return true;</span>
    }

    // get invisibly started places
    public static Set&lt;String&gt; getInvisPlaces() {
<span class="nc" id="L589">        return activeDirPlaces;</span>
    }

    // get if invisible places are started while in strict mode
    public static boolean isInvisPlacesStartedInStrictMode() {
<span class="fc" id="L594">        return invisPlacesStartedInStrictMode;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>