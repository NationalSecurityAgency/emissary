<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlaceStarter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.admin</a> &gt; <span class="el_source">PlaceStarter.java</span></div><h1>PlaceStarter.java</h1><pre class="source lang-java linenums">package emissary.admin;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.core.EmissaryException;
import emissary.core.EmissaryRuntimeException;
import emissary.core.Factory;
import emissary.core.Namespace;
import emissary.core.NamespaceException;
import emissary.directory.DirectoryEntry;
import emissary.directory.DirectoryPlace;
import emissary.directory.EmissaryNode;
import emissary.directory.IDirectoryPlace;
import emissary.directory.KeyManipulator;
import emissary.place.IServiceProviderPlace;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;

/**
 * Static methods to start places in the system.
 */
@SuppressWarnings(&quot;SystemExitOutsideMain&quot;)
public class PlaceStarter {
<span class="fc" id="L33">    private static final Logger logger = LoggerFactory.getLogger(PlaceStarter.class);</span>

    private static final Configurator classConf;

    protected static final String defaultClassName = &quot;emissary.place.sample.DevNullPlace&quot;;

    static {
        Configurator tmpCConfigurator;
        try {
<span class="fc" id="L42">            tmpCConfigurator = ConfigUtil.getClassNameInventory();</span>
<span class="nc" id="L43">        } catch (IOException | EmissaryException iox) {</span>
<span class="nc" id="L44">            tmpCConfigurator = null;</span>
<span class="nc" id="L45">            logger.error(&quot;Missing ClassNameInventory.cfg: all places will become &quot; + defaultClassName</span>
<span class="nc" id="L46">                    + &quot; which is probably not what you want. Config is now &quot; + System.getProperty(ConfigUtil.CONFIG_DIR_PROPERTY), iox);</span>
<span class="nc" id="L47">            System.exit(1);</span>
<span class="fc" id="L48">        }</span>
<span class="fc" id="L49">        classConf = tmpCConfigurator;</span>
<span class="fc" id="L50">    }</span>

    /**
     * Create a place using File based config
     *
     * @param theLocation key for the new place
     * @param theClassStr string name of the class to instantiate
     * @param directory the string directory name to register in
     * @return the place that was found or created, or null if it can't be done
     */
    public static IServiceProviderPlace createPlace(final String theLocation, final String theClassStr, final String directory) {
        // generate constructor args
<span class="nc" id="L62">        final String theConfigFile = theClassStr + ConfigUtil.CONFIG_FILE_ENDING;</span>

<span class="nc" id="L64">        final Object[] constructorArgs = {theConfigFile, directory, theLocation};</span>

<span class="nc" id="L66">        return createPlace(theLocation, constructorArgs, theClassStr);</span>
    }

    /**
     * Create a place using Stream based config
     *
     * @param theLocation key for the new place
     * @param theConfigStream stream configuration for the place
     * @param theClassStr string name of the class to instantiate
     * @param directory the string directory name to register in
     * @return the place that was found or created, or null if it can't be done
     */
    public static IServiceProviderPlace createPlace(final String theLocation, final InputStream theConfigStream, final String theClassStr,
            final String directory) {
        // generate constructor args
<span class="fc" id="L81">        final Object[] constructorArgs = {theConfigStream, directory, theLocation};</span>
<span class="fc" id="L82">        return createPlace(theLocation, constructorArgs, theClassStr);</span>
    }

    /**
     * Create a place using Stream based config
     *
     * @param theLocation key for the new place
     * @param theConfigStream stream configuration for the place
     * @param theClassStr string name of the class to instantiate
     * @param directory the string directory name to register in
     * @param node the emissary node
     * @return the place that was found or created, or null if it can't be done
     */
    public static IServiceProviderPlace createPlace(final String theLocation, final InputStream theConfigStream, final String theClassStr,
            final String directory, final EmissaryNode node) {
        // generate constructor args
<span class="fc" id="L98">        final Object[] constructorArgs = {theConfigStream, directory, theLocation, node};</span>
<span class="fc" id="L99">        return createPlace(theLocation, constructorArgs, theClassStr);</span>
    }


    /**
     * Create a place using generic Object[] constructor args for maximum flexibility for finding any existing constructor.
     * Will check to see if the place already exists first and return the existing instance from the Namespace if it does.
     *
     * @param theLocation key for the new place
     * @param constructorArgs array of args to pass to the place constructor
     * @param theClassStr string name of the class to instantiate
     * @return the place that was found or created, or null if it can't be done
     * @deprecated use {@link #createPlace(String, List, String)}
     */
    @Nullable
    @Deprecated
    @SuppressWarnings(&quot;AvoidObjectArrays&quot;)
    public static IServiceProviderPlace createPlace(final String theLocation, final Object[] constructorArgs, @Nullable final String theClassStr) {
<span class="fc" id="L117">        return createPlace(theLocation, Arrays.asList(constructorArgs), theClassStr);</span>
    }

    /**
     * Create a place using generic List constructor args for maximum flexibility for finding any existing constructor. Will
     * check to see if the place already exists first and return the existing instance from the Namespace if it does.
     *
     * @param theLocation key for the new place
     * @param constructorArgs list of args to pass to the place constructor
     * @param theClassStr string name of the class to instantiate
     * @return the place that was found or created, or null if it can't be done
     */
    @Nullable
    public static IServiceProviderPlace createPlace(final String theLocation, final List&lt;Object&gt; constructorArgs,
            @Nullable final String theClassStr) {
<span class="fc" id="L132">        logger.debug(&quot;Ready to createPlace {} as {}&quot;, theLocation, theClassStr);</span>

<span class="fc" id="L134">        final long t1 = System.currentTimeMillis();</span>

        // check the input arguments
        // TODO we should add a check to validate theLocation
<span class="fc" id="L138">        final IServiceProviderPlace place = alreadyExists(theLocation);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (place != null) {</span>
            // a place already exists at this location, can't create another!
<span class="nc" id="L141">            logger.warn(&quot;{} already exists!&quot;, theLocation);</span>
<span class="nc" id="L142">            return place;</span>
        }

        // error, must have the class string known...
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (theClassStr == null) {</span>
<span class="nc" id="L147">            logger.warn(&quot;classStr check failed for {}&quot;, theLocation);</span>
<span class="nc" id="L148">            return null;</span>
        }

<span class="fc" id="L151">        final String bindKey = KeyManipulator.removeExpense(theLocation);</span>
        final IServiceProviderPlace thePlace;
        try {
<span class="fc" id="L154">            thePlace = (IServiceProviderPlace) Factory.create(theClassStr, constructorArgs, bindKey);</span>
<span class="fc" id="L155">        } catch (Throwable te) {</span>
            // error creating place
<span class="fc" id="L157">            logger.error(&quot;cannot create {}&quot;, theLocation, te);</span>
<span class="fc" id="L158">            shutdownFailedPlace(bindKey, null);</span>
<span class="fc" id="L159">            return null; // couldn't start the place.</span>
<span class="fc" id="L160">        }</span>

<span class="fc" id="L162">        final long t2 = System.currentTimeMillis();</span>

<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L165">            logger.debug(&quot;Started {} in {}s&quot;, theLocation, (t2 - t1) / 1000.0);</span>
        }
<span class="fc" id="L167">        return thePlace;</span>
    }

    public static void shutdownFailedPlace(final String loc, @Nullable final IServiceProviderPlace place) {
        try {
<span class="fc" id="L172">            logger.warn(&quot;shutting down the failed place: {}&quot;, loc);</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            if (place != null) {</span>
<span class="nc" id="L174">                place.shutDown();</span>
            } else {
                // Force keys to be deregistered if we can
<span class="fc" id="L177">                deregisterPlace(loc);</span>
            }
<span class="fc" id="L179">            Namespace.unbind(loc);</span>
<span class="nc" id="L180">        } catch (Throwable tt) {</span>
<span class="nc" id="L181">            logger.error(&quot;whoa there pardner... {}&quot;, loc, tt);</span>
<span class="fc" id="L182">        }</span>
<span class="fc" id="L183">    }</span>

    public static void deregisterPlace(final String loc) {
        try {
<span class="fc" id="L187">            final IDirectoryPlace localDir = DirectoryPlace.lookup();</span>
<span class="fc" id="L188">            final List&lt;DirectoryEntry&gt; entries = localDir.getMatchingEntries(&quot;*.&quot; + loc);</span>
<span class="pc bpc" id="L189" title="2 of 4 branches missed.">            if (entries != null &amp;&amp; !entries.isEmpty()) {</span>
<span class="nc" id="L190">                final List&lt;String&gt; keys = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                for (final DirectoryEntry entry : entries) {</span>
<span class="nc" id="L192">                    keys.add(entry.getKey());</span>
<span class="nc" id="L193">                }</span>
<span class="nc" id="L194">                logger.info(&quot;Forcing removal of {} keys due to failed {}&quot;, keys.size(), loc);</span>
<span class="nc" id="L195">                localDir.removePlaces(keys);</span>
<span class="nc" id="L196">            } else {</span>
<span class="fc" id="L197">                logger.debug(&quot;Failed {} did not have any directory keys registered&quot;, loc);</span>
            }
<span class="nc" id="L199">        } catch (EmissaryException ee) {</span>
<span class="nc" id="L200">            logger.debug(&quot;NO local directory, cannot force key dereg for {}&quot;, loc);</span>
<span class="fc" id="L201">        }</span>
<span class="fc" id="L202">    }</span>

    // ////////////////////////////////////////////////////////////
    /**
     * method to check if the place already exists.
     */
    // ////////////////////////////////////////////////////////////
    @Nullable
    public static IServiceProviderPlace alreadyExists(final String theLocation) {
<span class="fc" id="L211">        final String thePlaceHost = Startup.placeHost(theLocation);</span>
        // TODO should we add a check for index of? Can cause an exception if // isn't present
<span class="fc" id="L213">        final String luStr = theLocation.substring(theLocation.indexOf(&quot;//&quot;));</span>
        try {
<span class="nc" id="L215">            final IServiceProviderPlace thePlace = (IServiceProviderPlace) Namespace.lookup(luStr);</span>
<span class="nc" id="L216">            logger.debug(&quot;{} already running on {}&quot;, theLocation, thePlaceHost);</span>
<span class="nc" id="L217">            return thePlace;</span>
<span class="fc" id="L218">        } catch (NamespaceException nse) {</span>
            // expected when the place doesn't exist
<span class="nc" id="L220">        } catch (Throwable t) {</span>
            // empty catch block
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">        return null;</span>
    }

    public static String getClassString(final String theLocation) {
<span class="fc" id="L227">        return getClassString(theLocation, false);</span>
    }

    public static String getClassString(final String theLocation, boolean isStrictMode) {
<span class="fc" id="L231">        final String thePlaceName = Startup.placeName(theLocation);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (StringUtils.isBlank(thePlaceName)) {</span>
<span class="nc" id="L233">            logger.error(&quot;Illegal location specified {}, has no place name&quot;, theLocation);</span>
        }
<span class="fc" id="L235">        final List&lt;String&gt; classStringList = classConf.findEntries(thePlaceName);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (classStringList.isEmpty()) {</span>
<span class="fc" id="L237">            logger.error(&quot;Need a CLASS config entry for {} check entry in emissary.admin.ClassNameInventory.cfg, using default &quot;</span>
                    + &quot;{} which is probably not what you want.&quot;, thePlaceName, defaultClassName);
<span class="fc" id="L239">            return defaultClassName;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        } else if (classStringList.size() &gt; 1) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (isStrictMode) {</span>
<span class="nc" id="L242">                throw new EmissaryRuntimeException(&quot;Multiple entries for &quot; + thePlaceName + &quot;, found &quot; + classStringList);</span>
            }
<span class="nc" id="L244">            logger.warn(&quot;Multiple entries for {}, found {}&quot;, thePlaceName, classStringList);</span>
        }
<span class="fc" id="L246">        return classStringList.get(0);</span>
    }

    /** This class is not meant to be instantiated. */
    private PlaceStarter() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>