<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServiceConfigGuide.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.config</a> &gt; <span class="el_source">ServiceConfigGuide.java</span></div><h1>ServiceConfigGuide.java</h1><pre class="source lang-java linenums">package emissary.config;

import jakarta.annotation.Nullable;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.Serializable;
import java.io.StreamTokenizer;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * This class implements the Configurator interface for services within the Emissary framework.
 */

public class ServiceConfigGuide implements Configurator, Serializable {

    static final long serialVersionUID = 3906838615422657150L;
    public static final char SLASH = '/';
    public static final char COLON = ':';
    public static final String DOUBLESLASH = &quot;//&quot;;

<span class="fc" id="L48">    protected static final Logger logger = LoggerFactory.getLogger(ServiceConfigGuide.class);</span>

    protected static final String DEFAULT_FILE_NAME = &quot;default.cfg&quot;;
    protected static final String POST_FILE_NAME = &quot;post.cfg&quot;;

    // Used on the RHS to make a null assignment
    // Obsolete, use @{NULL}
    protected static final String NULL_VALUE = &quot;&lt;null&gt;&quot;;

    // Hold all service specific parameters in a list
<span class="fc" id="L58">    protected List&lt;ConfigEntry&gt; serviceParameters = new ArrayList&lt;&gt;();</span>

    // Hold all remove config entries, operator of !=
<span class="fc" id="L61">    protected List&lt;ConfigEntry&gt; removeParameters = new ArrayList&lt;&gt;();</span>

    protected String operator;

    // Start and end to a dynamic substitution
    protected static final String VSTART = &quot;@{&quot;;
    protected static final String VEND = &quot;}&quot;;

    // Shared map of all environment properties
    // Access them with @ENV{'os.name'} for example
    // This is obsolete, all values from properties and
    // environment are now in the main values map and available
    // for immediate substitution
    protected static final String ENVSTART = &quot;@ENV{'&quot;;
    protected static final String ENVSTOP = &quot;'}&quot;;

    // Map of last values seen
<span class="fc" id="L78">    protected Map&lt;String, String&gt; values = new HashMap&lt;&gt;();</span>

    // Get this once per jvm
    private static final String hostname;

    // Grab the hostname for @{HOST} replacement
    static {
        String tmpHostname;
        try {
<span class="fc" id="L87">            tmpHostname = InetAddress.getLocalHost().getCanonicalHostName();</span>
<span class="nc" id="L88">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L89">            logger.error(&quot;Error getting host name&quot;, e);</span>
<span class="nc" id="L90">            tmpHostname = &quot;localhost&quot;;</span>
<span class="fc" id="L91">        }</span>
<span class="fc" id="L92">        hostname = tmpHostname;</span>
<span class="fc" id="L93">    }</span>

    /**
     * Public default constructor
     */
<span class="fc" id="L98">    public ServiceConfigGuide() {</span>
<span class="fc" id="L99">        initializeValues();</span>
<span class="fc" id="L100">    }</span>

    /**
     * Public constructor with dir and filename
     *
     * @param path the directory where config files are
     * @param file the name of te file in the directory
     */
    public ServiceConfigGuide(final String path, final String file) throws IOException {
<span class="fc" id="L109">        this(path + File.separator + file);</span>
<span class="fc" id="L110">    }</span>

    /**
     * Public default constructor with file name
     *
     * @param filename the name of the disk file
     */
    public ServiceConfigGuide(final String filename) throws IOException {
<span class="fc" id="L118">        this();</span>
        try {
<span class="fc" id="L120">            readConfigData(filename);</span>
<span class="nc" id="L121">        } catch (ConfigSyntaxException ex) {</span>
<span class="nc" id="L122">            throw new IOException(&quot;Cannot parse configuration file &quot; + ex.getMessage(), ex);</span>
<span class="fc" id="L123">        }</span>
<span class="fc" id="L124">    }</span>

    /**
     * Public default constructor with InputStream
     *
     * @param is the InputStream
     */
    public ServiceConfigGuide(final InputStream is) throws IOException {
<span class="fc" id="L132">        this();</span>
        try {
<span class="fc" id="L134">            readConfigData(is);</span>
<span class="nc" id="L135">        } catch (ConfigSyntaxException ex) {</span>
<span class="nc" id="L136">            throw new IOException(&quot;Cannot parse configuration file &quot; + ex.getMessage(), ex);</span>
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">    }</span>

    /**
     * Public default constructor with InputStream and name
     *
     * @param is the InputStream
     * @param name the name of the stream good for reporting errors
     */
    public ServiceConfigGuide(final InputStream is, final String name) throws IOException {
<span class="fc" id="L147">        this();</span>
        try {
<span class="fc" id="L149">            readConfigData(is, name);</span>
<span class="fc" id="L150">        } catch (ConfigSyntaxException ex) {</span>
<span class="fc" id="L151">            logger.error(&quot;Caught ConfigSytaxException {}&quot;, ex.getMessage());</span>
<span class="fc" id="L152">            throw new IOException(&quot;Cannot parse configuration file &quot; + ex.getMessage(), ex);</span>
<span class="fc" id="L153">        }</span>
<span class="fc" id="L154">    }</span>

    /**
     * Initialize the values map, which is used to replace stuff in the configs
     */
    protected void initializeValues() {
<span class="fc" id="L160">        this.values.clear();</span>

        // TODO: see if we can stop adding all env variables and
        // system properties to the replace values

        // Add all the environment variables
<span class="fc" id="L166">        this.values.putAll(System.getenv());</span>

        // Add all the system properties
<span class="fc" id="L169">        final Properties props = System.getProperties();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (Enumeration&lt;?&gt; e = props.propertyNames(); e.hasMoreElements();) {</span>
<span class="fc" id="L171">            final String key = (String) e.nextElement();</span>
<span class="fc" id="L172">            logger.trace(&quot;Adding {} to replaceable properties&quot;, key);</span>
<span class="fc" id="L173">            this.values.put(key, props.getProperty(key));</span>
<span class="fc" id="L174">        }</span>

        // used for substitution when reading cfg files
<span class="fc" id="L177">        this.values.put(&quot;CONFIG_DIR&quot;, StringUtils.join(ConfigUtil.getConfigDirs(), &quot;,&quot;));</span>
<span class="fc" id="L178">        this.values.put(&quot;PRJ_BASE&quot;, ConfigUtil.getProjectBase());</span>
<span class="fc" id="L179">        this.values.put(&quot;PROJECT_BASE&quot;, ConfigUtil.getProjectBase());</span>
<span class="fc" id="L180">        this.values.put(&quot;OUTPUT_ROOT&quot;, ConfigUtil.getOutputRoot());</span>
<span class="fc" id="L181">        this.values.put(&quot;BIN_DIR&quot;, ConfigUtil.getBinDir());</span>
<span class="fc" id="L182">        this.values.put(&quot;HOST&quot;, hostname);</span>
<span class="fc" id="L183">        this.values.put(&quot;/&quot;, File.separator);</span>
<span class="fc" id="L184">        this.values.put(&quot;TMPDIR&quot;, System.getProperty(&quot;java.io.tmpdir&quot;));</span>
<span class="fc" id="L185">        this.values.put(&quot;NULL&quot;, null);</span>
<span class="fc" id="L186">        this.values.put(&quot;OS.NAME&quot;, System.getProperty(&quot;os.name&quot;).replace(' ', '_'));</span>
<span class="fc" id="L187">        this.values.put(&quot;OS.VER&quot;, System.getProperty(&quot;os.version&quot;).replace(' ', '_'));</span>
<span class="fc" id="L188">        this.values.put(&quot;OS.ARCH&quot;, System.getProperty(&quot;os.arch&quot;).replace(' ', '_'));</span>
<span class="fc" id="L189">    }</span>

    /**
     * Reads the configuration file specified in the argument and sets the mandatory parameters.
     */
    protected void readConfigData(final String filename) throws IOException, ConfigSyntaxException {
<span class="fc" id="L195">        readSingleConfigFile(filename);</span>
<span class="fc" id="L196">    }</span>

    public void readConfigData(final InputStream is) throws IOException, ConfigSyntaxException {
<span class="fc" id="L199">        readConfigData(is, &quot;UNKNOWN&quot;);</span>
<span class="fc" id="L200">    }</span>


    protected void readConfigData(final InputStream is, final String filename) throws IOException, ConfigSyntaxException {
<span class="fc" id="L204">        final Reader r = new BufferedReader(new InputStreamReader(is));</span>
<span class="fc" id="L205">        final StreamTokenizer in = new StreamTokenizer(r);</span>
<span class="fc" id="L206">        int nextToken = StreamTokenizer.TT_WORD;</span>
        String parmName;
        String sval;

<span class="fc" id="L210">        in.commentChar('#');</span>
<span class="fc" id="L211">        in.wordChars(33, 33);</span>
<span class="fc" id="L212">        in.wordChars(36, 47);</span>
<span class="fc" id="L213">        in.wordChars(58, 64);</span>
<span class="fc" id="L214">        in.wordChars(91, 96);</span>
<span class="fc" id="L215">        in.wordChars(123, 65536);</span>

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        while (nextToken != StreamTokenizer.TT_EOF) {</span>
            // Read three tokens at a time (X = Y)
<span class="fc" id="L219">            nextToken = in.nextToken();</span>

            // Make sure the first token in the tuple is a word
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (nextToken == StreamTokenizer.TT_EOF) {</span>
<span class="fc" id="L223">                break;</span>
            }
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (nextToken == StreamTokenizer.TT_NUMBER) {</span>
<span class="fc" id="L226">                throw new ConfigSyntaxException(&quot;Illegal token &quot; + in.sval + &quot;, missing quote on line &quot; + in.lineno() + &quot;?&quot;);</span>
            }

<span class="fc" id="L229">            parmName = in.sval;</span>

<span class="fc" id="L231">            nextToken = in.nextToken();</span>
<span class="fc" id="L232">            this.operator = in.sval;</span>

<span class="fc" id="L234">            nextToken = in.nextToken();</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">            if (nextToken == StreamTokenizer.TT_NUMBER) {</span>
<span class="fc" id="L236">                sval = Long.toString((long) in.nval);</span>
            } else {
<span class="fc" id="L238">                sval = in.sval;</span>
            }

<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (sval == null) {</span>
                // Problem is likely on previous line
<span class="fc" id="L243">                throw new ConfigSyntaxException(&quot;Illegal token &quot; + parmName + &quot;, missing space or value on line &quot; + (in.lineno() - 1) + &quot;?&quot;);</span>
            }

<span class="fc" id="L246">            handleNewEntry(parmName, sval, this.operator, filename, in.lineno() - 1, false);</span>
        }
<span class="fc" id="L248">        r.close();</span>
<span class="fc" id="L249">        is.close();</span>
<span class="fc" id="L250">    }</span>

    protected void readSingleConfigFile(final String filename) throws IOException, ConfigSyntaxException {
<span class="fc" id="L253">        logger.debug(&quot;Reading config file {}&quot;, filename);</span>
<span class="fc" id="L254">        final InputStream is = ConfigUtil.getConfigData(filename);</span>
<span class="fc" id="L255">        readConfigData(is, filename);</span>
<span class="fc" id="L256">    }</span>

    /**
     * Handle a newly parsed or passed in entry. Substitutions are handled on both the LHS and RHS, then the values are
     * stored as a ConfigEntry in our local list and map. Only the last value in the map is available for substitutions. LHS
     * is analyzed before RHS and in L to R order.
     *
     * @param parmNameArg the LHS
     * @param svalArg the raw RHS
     * @param operatorArg the equation
     * @param filename the filename we are parsing for error reporting
     * @param lineno the line number we are currently reporting the error on
     * @param merge true when adding in from a merge
     * @return a new config entry with the expanded key and value
     * @throws IOException when the key or value is malformed
     */
    protected ConfigEntry handleNewEntry(final String parmNameArg, final String svalArg, final String operatorArg, final String filename,
            final int lineno, final boolean merge) throws IOException {
<span class="fc" id="L274">        final String parmName = handleReplacements(parmNameArg, filename, lineno);</span>
<span class="fc" id="L275">        final String sval = handleReplacements(svalArg, filename, lineno);</span>

        // Create a config entry from this
<span class="fc" id="L278">        final ConfigEntry anEntry = new ConfigEntry(parmName, sval);</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (&quot;!=&quot;.equals(operatorArg)) {</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">            if (&quot;*&quot;.equals(sval)) {</span>
<span class="fc" id="L282">                removeAllEntries(parmName);</span>
<span class="fc" id="L283">                this.values.remove(parmName);</span>
            } else {
<span class="fc" id="L285">                removeEntry(anEntry);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (sval.equals(this.values.get(parmName))) {</span>
<span class="fc" id="L287">                    this.values.remove(parmName);</span>
                }
            }
<span class="fc" id="L290">            this.removeParameters.add(anEntry);</span>
        } else {
            // Save the entry in the list
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (merge) {</span>
<span class="fc" id="L294">                this.serviceParameters.add(0, anEntry);</span>
            } else {
<span class="fc" id="L296">                this.serviceParameters.add(anEntry);</span>
            }

            // Save this pair in the map
<span class="fc" id="L300">            this.values.put(parmName, sval);</span>
        }

<span class="fc bfc" id="L303" title="All 4 branches covered.">        if (&quot;IMPORT_FILE&quot;.equals(parmName) || &quot;OPT_IMPORT_FILE&quot;.equals(parmName)) {</span>
<span class="fc" id="L304">            final List&lt;String&gt; fileFlavorList = new ArrayList&lt;&gt;();</span>
            // Add the base file and then add all the flavor versions
<span class="fc" id="L306">            fileFlavorList.add(sval);</span>
<span class="fc" id="L307">            final String[] fileFlavors = ConfigUtil.addFlavors(sval);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">            if (ArrayUtils.isNotEmpty(fileFlavors)) {</span>
<span class="fc" id="L309">                fileFlavorList.addAll(Arrays.asList(fileFlavors));</span>
            }
<span class="fc" id="L311">            logger.debug(&quot;ServiceConfigGuide::handleNewEntry -- FileFlavorList = {}&quot;, fileFlavorList);</span>

            // loop through the files and attempt to read/merger the configurations.
<span class="fc bfc" id="L314" title="All 2 branches covered.">            for (int i = 0; i &lt; fileFlavorList.size(); i++) {</span>
<span class="fc" id="L315">                final String fileFlavor = fileFlavorList.get(i);</span>
                // recursion alert: This could lead to getFile being called
                try {
<span class="fc" id="L318">                    readConfigData(ConfigUtil.getConfigStream(fileFlavor), fileFlavor);</span>
<span class="fc" id="L319">                } catch (ConfigSyntaxException e) {</span>
                    // whether opt or not, syntax errors are a problem
<span class="fc" id="L321">                    throw new IOException(parmName + &quot; = &quot; + sval + &quot; from &quot; + filename + &quot; failed &quot; + e.getMessage(), e);</span>
<span class="fc" id="L322">                } catch (IOException e) {</span>
                    // Throw exception if it is an IMPORT_FILE and the base file is not found
<span class="fc bfc" id="L324" title="All 4 branches covered.">                    if (&quot;IMPORT_FILE&quot;.equals(parmName) &amp;&amp; i == 0) {</span>
<span class="fc" id="L325">                        String importFileName = Paths.get(svalArg).getFileName().toString();</span>
<span class="fc" id="L326">                        throw new IOException(&quot;In &quot; + filename + &quot;, cannot find IMPORT_FILE: &quot; + sval</span>
                                + &quot; on the specified path. Make sure IMPORT_FILE (&quot; + importFileName + &quot;) exists, and the file path is correct.&quot;,
                                e);
                    }
<span class="fc" id="L330">                }</span>
            }
<span class="fc" id="L332">            return anEntry;</span>
<span class="pc bpc" id="L333" title="1 of 4 branches missed.">        } else if (&quot;CREATE_DIRECTORY&quot;.equals(parmName) &amp;&amp; !createDirectory(sval)) {</span>
<span class="nc" id="L334">            logger.warn(&quot;{}: Cannot create directory {}&quot;, filename, sval);</span>
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">        } else if (&quot;CREATE_FILE&quot;.equals(parmName) &amp;&amp; !createFile(sval)) {</span>
<span class="nc" id="L336">            logger.warn(&quot;{}: Cannot create file {}&quot;, filename, sval);</span>
        }

<span class="fc" id="L339">        return anEntry;</span>
    }

    /**
     * Handle all the possible replacements in a string value
     *
     * @param svalArg the raw value
     * @param filename the filename we are parsing for error reporting
     * @param lineno the line number we are currently reporting the error on
     * @return the expanded value with all legal @{..} values replaced
     * @throws IOException when the value is malformed
     */
    protected String handleReplacements(final String svalArg, final String filename, final int lineno) throws IOException {
<span class="fc" id="L352">        String sval = svalArg;</span>
<span class="fc" id="L353">        int startpos = 0;</span>
<span class="fc bfc" id="L354" title="All 4 branches covered.">        while (sval != null &amp;&amp; sval.indexOf(VSTART, startpos) &gt; -1) {</span>
<span class="fc" id="L355">            final int ndx = sval.indexOf(VSTART, startpos);</span>
<span class="fc" id="L356">            final int edx = sval.indexOf(VEND, ndx + VSTART.length());</span>
<span class="pc bpc" id="L357" title="3 of 4 branches missed.">            if (ndx == -1 &amp;&amp; ndx &gt;= edx) {</span>
<span class="nc" id="L358">                throw new IOException(&quot;Problem parsing line &quot; + lineno + &quot; &quot; + sval);</span>
            }
<span class="fc" id="L360">            final String tok = sval.substring(ndx + VSTART.length(), edx);</span>
<span class="fc" id="L361">            logger.debug(&quot;Replacement token is {}&quot;, tok);</span>
<span class="fc" id="L362">            final String mapval = this.values.get(tok);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            if (mapval != null) {</span>
<span class="fc" id="L364">                sval = sval.substring(0, ndx) + mapval + sval.substring(edx + VEND.length());</span>
            } else {
<span class="fc" id="L366">                logger.warn(&quot;Did not find replacement for '{}' in file {} at line {}&quot;, tok, filename, lineno);</span>
<span class="fc" id="L367">                startpos = edx + VEND.length();</span>
            }
<span class="fc" id="L369">        }</span>

        // This is obsolete
<span class="fc bfc" id="L372" title="All 4 branches covered.">        if (sval != null &amp;&amp; sval.contains(ENVSTART)) {</span>
<span class="fc" id="L373">            sval = substituteEnvProps(sval, filename, lineno);</span>
        }

        // Do unicode stuff
<span class="fc bfc" id="L377" title="All 6 branches covered.">        if (sval != null &amp;&amp; (sval.contains(&quot;\\u&quot;) || sval.contains(&quot;\\U&quot;))) {</span>
<span class="fc" id="L378">            sval = substituteUtfChars(sval, filename, lineno);</span>
        }

        // This is obsolete
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">        if (sval != null &amp;&amp; sval.equals(NULL_VALUE)) {</span>
<span class="nc" id="L383">            sval = null;</span>
<span class="nc" id="L384">            logger.debug(&quot;Using {} is deprecated, please just use {}NULL{}&quot;, NULL_VALUE, VSTART, VEND);</span>
        }
<span class="fc" id="L386">        return sval;</span>
    }

    /**
     * Substitute any java unicode character values: \\uxxxx
     *
     * @param s the string to process
     * @param filename the name of the file we are in for error reporting
     * @param lnum the current line number for error reporting
     * @return string with character values replaced
     */
    protected String substituteUtfChars(final String s, final String filename, final int lnum) throws IOException {
<span class="fc" id="L398">        final int slen = s.length();</span>
<span class="fc" id="L399">        final StringBuilder sb = new StringBuilder(slen);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (int i = 0; i &lt; slen; i++) {</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (s.charAt(i) != '\\') {</span>
<span class="fc" id="L402">                sb.append(s.charAt(i));</span>
<span class="pc bpc" id="L403" title="1 of 6 branches missed.">            } else if ((i + 4) &lt; slen &amp;&amp; (s.charAt(i + 1) == 'u' || s.charAt(i + 1) == 'U')) {</span>
<span class="fc" id="L404">                int epos = i + 2;</span>
<span class="fc bfc" id="L405" title="All 4 branches covered.">                final int max = (s.charAt(epos) == '1' || s.charAt(epos) == '0') ? (i + 7) : (i + 6);</span>
<span class="fc bfc" id="L406" title="All 4 branches covered.">                while (epos &lt; slen</span>
                        &amp;&amp; epos &lt; max
<span class="pc bpc" id="L408" title="2 of 8 branches missed.">                        &amp;&amp; ((s.charAt(epos) &gt;= '0' &amp;&amp; s.charAt(epos) &lt;= '9') || (s.charAt(epos) &gt;= 'A' &amp;&amp; s.charAt(epos) &lt;= 'F')</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">                                || (s.charAt(epos) &gt;= 'a' &amp;&amp; s</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">                                        .charAt(epos) &lt;= 'f'))) {</span>
<span class="fc" id="L411">                    epos++;</span>
                }
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">                if (epos &lt;= slen) {</span>
                    try {
<span class="fc" id="L415">                        final int digit = Integer.parseInt(s.substring(i + 2, epos), 16);</span>
<span class="fc" id="L416">                        sb.appendCodePoint(digit);</span>
<span class="fc" id="L417">                        i = epos - 1;</span>
<span class="nc" id="L418">                    } catch (RuntimeException ex) {</span>
<span class="nc" id="L419">                        throw new IOException(&quot;Unable to convert characters in &quot; + s + &quot;, from filename=&quot; + filename + &quot; line &quot; + lnum, ex);</span>
<span class="fc" id="L420">                    }</span>
                }
<span class="fc" id="L422">            } else {</span>
<span class="fc" id="L423">                sb.append(s.charAt(i));</span>
            }
        }

<span class="fc" id="L427">        return sb.toString();</span>
    }

    /**
     * Substitute any referenced env properties with their values. Look for @ENV{'foo'} and replace foo with
     * System.getProperty(&quot;foo&quot;) or System.getenv(&quot;foo&quot;) in that order.
     *
     * @param str the string to process
     * @param filename the name of the file we are in for error reporting
     * @param lnum the current line number for error reporting
     * @return string with env values replaced
     */
    protected String substituteEnvProps(final String str, final String filename, final int lnum) throws IOException {
<span class="fc" id="L440">        int lastPos = -1;</span>
<span class="fc" id="L441">        int thisPos = 0;</span>
<span class="fc" id="L442">        int count = 0;</span>

<span class="fc" id="L444">        logger.debug(&quot;{}{} style substitution is deprecated. Please just use {}yourvalue{}&quot;, ENVSTART, ENVSTOP, VSTART, VEND);</span>

<span class="fc" id="L446">        String currentStr = str;</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        while ((thisPos = currentStr.indexOf(ENVSTART, thisPos)) &gt; lastPos) {</span>
<span class="fc" id="L448">            final int start = thisPos + ENVSTART.length();</span>
<span class="fc" id="L449">            final int stop = currentStr.indexOf(ENVSTOP, thisPos);</span>
<span class="fc" id="L450">            count++;</span>
            // Pull out the env name they specified
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (stop &gt; start) {</span>
<span class="fc" id="L453">                final String envName = currentStr.substring(start, stop);</span>
<span class="fc" id="L454">                String envVal = System.getProperty(envName);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                if (envVal == null) {</span>
<span class="fc" id="L456">                    envVal = System.getenv(envName);</span>
                }
                // We got a replacement, do the subst
<span class="fc bfc" id="L459" title="All 2 branches covered.">                if (envVal != null) {</span>
<span class="fc" id="L460">                    currentStr = currentStr.substring(0, thisPos) + // before</span>
                            envVal + // replacement value
<span class="fc" id="L462">                            currentStr.substring(stop + ENVSTOP.length()); // tail</span>
<span class="fc" id="L463">                    logger.debug(&quot;Replaced {} with {} at {}: {}&quot;, envName, envVal, filename, lnum);</span>
                } else {
<span class="fc" id="L465">                    logger.debug(&quot;No env value for {} at {}: {}&quot;, envName, filename, lnum);</span>
                }
<span class="fc" id="L467">            } else {</span>
<span class="nc" id="L468">                throw new IOException(&quot;Runaway string on line -&gt;&quot; + currentStr + &quot;&lt;- at &quot; + filename + &quot;: &quot; + lnum);</span>
            }

<span class="fc" id="L471">            lastPos = thisPos;</span>
<span class="fc" id="L472">        }</span>
<span class="fc" id="L473">        logger.debug(&quot;Found {} env vars to subst --&gt; {}&quot;, count, currentStr);</span>
<span class="fc" id="L474">        return currentStr;</span>
    }

    /**
     * Create a directory as specified by the config driver
     */
    protected boolean createDirectory(final String sval) {
<span class="fc" id="L481">        final String fixedSval = sval.replace('\\', '/');</span>
<span class="fc" id="L482">        logger.debug(&quot;Trying to create dir {}&quot;, fixedSval);</span>
<span class="fc" id="L483">        final File d = new File(fixedSval);</span>
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">        if (!d.exists() &amp;&amp; !d.mkdirs()) {</span>
<span class="nc" id="L485">            logger.debug(&quot;Failed to create directory {}&quot;, fixedSval);</span>
<span class="nc" id="L486">            return false;</span>
        }
<span class="fc" id="L488">        return true;</span>
    }

    /**
     * Create a file as specified by the config driver
     */
    protected boolean createFile(final String sval) {

<span class="fc" id="L496">        final String fixedSval = sval.replace('\\', '/');</span>
<span class="fc" id="L497">        logger.debug(&quot;Trying to create file {}&quot;, fixedSval);</span>
<span class="fc" id="L498">        final File d = new File(fixedSval);</span>
<span class="fc" id="L499">        FileWriter newFile = null;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (!d.exists()) {</span>
            try {
                // Ensure the directory exists to hold the file
<span class="fc" id="L503">                final File parent = new File(new File(d.getCanonicalPath()).getParent());</span>
<span class="pc bpc" id="L504" title="1 of 4 branches missed.">                if (!parent.exists() &amp;&amp; !createDirectory(parent.toString())) {</span>
<span class="nc" id="L505">                    logger.debug(&quot;Failed to create parent directory for {}&quot;, fixedSval);</span>
<span class="nc" id="L506">                    return false;</span>
                }
                // Create the file in the directory
<span class="fc" id="L509">                newFile = new FileWriter(d);</span>
<span class="nc" id="L510">            } catch (IOException e) {</span>
<span class="nc" id="L511">                logger.debug(&quot;Failed to create file {}&quot;, fixedSval, e);</span>
<span class="nc" id="L512">                return false;</span>
            } finally {
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                if (newFile != null) {</span>
                    try {
<span class="fc" id="L516">                        newFile.close();</span>
<span class="nc" id="L517">                    } catch (IOException ioe) {</span>
<span class="nc" id="L518">                        logger.debug(&quot;Error closing file&quot;, ioe);</span>
<span class="fc" id="L519">                    }</span>
                }
            }
        }
<span class="fc" id="L523">        return true;</span>
    }

    /**
     * Get the names of all entries for this config This set is not backed by the configuration and any changes to it are
     * not reflected in the configuration.
     */
    @Override
    public Set&lt;String&gt; entryKeys() {
<span class="fc" id="L532">        final Set&lt;String&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        for (final ConfigEntry curEntry : this.serviceParameters) {</span>
<span class="fc" id="L534">            set.add(curEntry.getKey());</span>
<span class="fc" id="L535">        }</span>
<span class="fc" id="L536">        return set;</span>
    }

    /**
     * Get all the entries for this config This is a copy and changes to it are not reflected in the configuration
     */
    @Override
    public List&lt;ConfigEntry&gt; getEntries() {
<span class="fc" id="L544">        return new ArrayList&lt;&gt;(this.serviceParameters);</span>
    }

    /**
     * Remove entries, those with operators of '!=' are stored and can be retrieved for replay during merge. This method is
     * not part of the Configurator interface.
     */
    protected List&lt;ConfigEntry&gt; getRemoveEntries() {
<span class="fc" id="L552">        return new ArrayList&lt;&gt;(this.removeParameters);</span>
    }

    /**
     * Add an entry to this config
     *
     * @param key the name of the entry
     * @param value the value
     * @return the new entry or null if it fails
     */
    @Override
    public ConfigEntry addEntry(final String key, final String value) {
<span class="fc" id="L564">        ConfigEntry entry = null;</span>
        try {
<span class="fc" id="L566">            entry = handleNewEntry(key, value, &quot;=&quot;, &quot;&lt;user&gt;&quot;, 1, false);</span>
<span class="nc" id="L567">        } catch (IOException ex) {</span>
<span class="nc" id="L568">            logger.error(&quot;Could not add entry for {}&quot;, key, ex);</span>
<span class="fc" id="L569">        }</span>
<span class="fc" id="L570">        return entry;</span>
    }

    /**
     * Add a list of entries for the same key
     *
     * @param key the name of the entry
     * @param values the values
     * @return the new entries or null if it fails
     */
    @Override
    public List&lt;ConfigEntry&gt; addEntries(final String key, final List&lt;String&gt; values) {
<span class="fc" id="L582">        final List&lt;ConfigEntry&gt; list = new ArrayList&lt;&gt;();</span>
        try {
<span class="fc" id="L584">            int i = 1;</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            for (final String value : values) {</span>
<span class="fc" id="L586">                final ConfigEntry entry = handleNewEntry(key, value, &quot;=&quot;, &quot;&lt;user&gt;&quot;, i++, false);</span>
<span class="fc" id="L587">                list.add(entry);</span>
<span class="fc" id="L588">            }</span>
<span class="nc" id="L589">        } catch (IOException ex) {</span>
<span class="nc" id="L590">            logger.error(&quot;Error adding entries for {}&quot;, key, ex);</span>
<span class="fc" id="L591">        }</span>
<span class="fc" id="L592">        return list;</span>
    }

    /**
     * Remove all entries by the given name
     *
     * @param key the name of the entry or entries
     * @param value the value
     */
    @Override
    public void removeEntry(final String key, final String value) {
        try {
<span class="fc" id="L604">            handleNewEntry(key, value, &quot;!=&quot;, &quot;&lt;user&gt;&quot;, 1, false);</span>
<span class="nc" id="L605">        } catch (IOException ex) {</span>
<span class="nc" id="L606">            logger.warn(&quot;Cannot remove entry&quot;, ex);</span>
<span class="fc" id="L607">        }</span>
<span class="fc" id="L608">    }</span>

    /**
     * Remove an entry from the list of parameters matching the ConfigEntry argument passed in.
     *
     * @param anEntry the entry to remove
     */
    public void removeEntry(final ConfigEntry anEntry) {
        // NB: enhanced for loop does not support remove
<span class="fc bfc" id="L617" title="All 2 branches covered.">        for (final Iterator&lt;ConfigEntry&gt; i = this.serviceParameters.iterator(); i.hasNext();) {</span>
<span class="fc" id="L618">            final ConfigEntry curEntry = i.next();</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (anEntry.getKey().equals(curEntry.getKey())</span>
<span class="pc bpc" id="L620" title="4 of 8 branches missed.">                    &amp;&amp; ((anEntry.getValue() == null &amp;&amp; curEntry.getValue() == null) || (anEntry.getValue() != null &amp;&amp; anEntry.getValue().equals(</span>
<span class="fc" id="L621">                            curEntry.getValue())))) {</span>
<span class="fc" id="L622">                logger.debug(&quot;Removing {} = {}&quot;, curEntry.getKey(), curEntry.getValue());</span>
<span class="fc" id="L623">                i.remove();</span>
            }
<span class="fc" id="L625">        }</span>
<span class="fc" id="L626">    }</span>

    /**
     * Return a list containing all the parameter values matching the key argument passed in.
     *
     * @param theParameter the key to match
     * @param defaultString value for list when no matches are found
     * @return the list with all matching entries or the default value supplied
     */
    @Override
    public List&lt;String&gt; findEntries(final String theParameter, final String defaultString) {
<span class="fc" id="L637">        final List&lt;String&gt; result = findEntries(theParameter);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if (result.isEmpty()) {</span>
<span class="fc" id="L639">            result.add(defaultString);</span>
        }
<span class="fc" id="L641">        return result;</span>
    }

    /**
     * Return a list containing all the parameter values matching the key argument passed in
     *
     * @param theParameter the key to match
     * @return list with all matching entries, or empty list if none
     */
    @Override
    public List&lt;String&gt; findEntries(final String theParameter) {
<span class="fc" id="L652">        final List&lt;String&gt; matchingEntries = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (final ConfigEntry curEntry : this.serviceParameters) {</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">            if (theParameter.equals(curEntry.getKey())) {</span>
<span class="fc" id="L656">                matchingEntries.add(curEntry.getValue());</span>
            }
<span class="fc" id="L658">        }</span>
<span class="fc" id="L659">        return matchingEntries;</span>
    }

    /**
     * Remove all entries from the list of parameters matching the String argument passed in.
     *
     * @param theParameter key name to match, all matching will be removed
     */
    public void removeAllEntries(final String theParameter) {
        // NB: enhanced for loop does not support remove
<span class="fc bfc" id="L669" title="All 2 branches covered.">        for (final Iterator&lt;ConfigEntry&gt; i = this.serviceParameters.iterator(); i.hasNext();) {</span>
<span class="fc" id="L670">            final ConfigEntry curEntry = i.next();</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (theParameter.equals(curEntry.getKey())) {</span>
<span class="fc" id="L672">                logger.debug(&quot;Removing {} = {}&quot;, curEntry.getKey(), curEntry.getValue());</span>
<span class="fc" id="L673">                i.remove();</span>
            }
<span class="fc" id="L675">        }</span>
<span class="fc" id="L676">    }</span>

    /**
     * Return a set with all parameter values as members
     *
     * @param theParameter key value to match
     * @return set of all entries found or empty set if none
     */
    @Override
    public Set&lt;String&gt; findEntriesAsSet(final String theParameter) {

<span class="fc" id="L687">        final Set&lt;String&gt; matchingEntries = new HashSet&lt;&gt;();</span>

<span class="fc bfc" id="L689" title="All 2 branches covered.">        for (final ConfigEntry curEntry : this.serviceParameters) {</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">            if (theParameter.equals(curEntry.getKey())) {</span>
<span class="fc" id="L691">                matchingEntries.add(curEntry.getValue());</span>
            }
<span class="fc" id="L693">        }</span>
<span class="fc" id="L694">        return matchingEntries;</span>
    }

    /**
     * Find entries beginning with the specified string
     *
     * @param theParameter key to match with a startsWith
     * @return list of entries matching specified value or empty list if none
     */
    @Override
    public List&lt;ConfigEntry&gt; findStringMatchEntries(final String theParameter) {

<span class="fc" id="L706">        final List&lt;ConfigEntry&gt; matchingEntries = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L708" title="All 2 branches covered.">        for (final ConfigEntry curEntry : this.serviceParameters) {</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (curEntry.getKey().startsWith(theParameter)) {</span>
<span class="fc" id="L710">                matchingEntries.add(curEntry);</span>
            }
<span class="fc" id="L712">        }</span>
<span class="fc" id="L713">        return matchingEntries;</span>
    }

    /**
     * Find entries beginning with the specified string and put them into a list with the specified part of the name
     * stripped off like #findStringMatchMap
     *
     * @param theParameter key to match with a startsWith
     * @return list of ConfigEntry
     */
    @Override
    public List&lt;ConfigEntry&gt; findStringMatchList(final String theParameter) {
<span class="fc" id="L725">        final List&lt;ConfigEntry&gt; list = findStringMatchEntries(theParameter);</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">        for (final ConfigEntry entry : list) {</span>
<span class="fc" id="L727">            entry.setKey(entry.getKey().substring(theParameter.length()));</span>
<span class="fc" id="L728">        }</span>
<span class="fc" id="L729">        return list;</span>
    }

    /**
     * Find entries beginning with the specified string and return a hash keyed on the remainder of the string with the
     * value of the config line as the value of the hash
     *
     * @param theParameter the key to look for in the config file
     */
    @Override
    public Map&lt;String, String&gt; findStringMatchMap(final String theParameter) {
<span class="fc" id="L740">        return findStringMatchMap(theParameter, false);</span>
    }

    /**
     * Find entries beginning with the specified string and return a hash keyed on the remainder of the string with the
     * value of the config line as the value of the hash
     *
     * &lt;pre&gt;
     * {@code
     * Example config entries
     *    FOO_ONE: AAA
     *    FOO_TWO: BBB
     * Calling findStringMatchMap(&quot;FOO_&quot;,true)
     * will yield a map with
     *     ONE -&gt; AAA
     *     TWO -&gt; BBB
     * }
     * &lt;/pre&gt;
     *
     * @param theParameter the key to look for in the config file
     * @param preserveCase if false all keys will be upcased
     * @return map where key is remainder after match and value is the config value, or an empty map if none found
     */
    @Override
    public Map&lt;String, String&gt; findStringMatchMap(final String theParameter, final boolean preserveCase) {
<span class="fc" id="L765">        return findStringMatchMap(theParameter, preserveCase, false);</span>
    }

    /**
     * Find entries beginning with the specified string and return a hash keyed on the remainder of the string with the
     * value of the config line as the value of the hash
     *
     * &lt;pre&gt;
     * {@code
     * Example config entries
     *    FOO_ONE: AAA
     *    FOO_TWO: BBB
     * Calling findStringMatchMap(&quot;FOO_&quot;,true)
     * will yield a map with
     *     ONE -&gt; AAA
     *     TWO -&gt; BBB
     * }
     * &lt;/pre&gt;
     *
     * @param theParameter the key to look for in the config file
     * @param preserveCase if false all keys will be upcased
     * @param preserveOrder if true key ordering is preserved
     * @return map where key is remainder after match and value is the config value, or an empty map if none found
     */
    @Override
    public Map&lt;String, String&gt; findStringMatchMap(@Nullable final String theParameter, final boolean preserveCase, final boolean preserveOrder) {
<span class="fc bfc" id="L791" title="All 2 branches covered.">        if (theParameter == null) {</span>
<span class="fc" id="L792">            return Collections.emptyMap();</span>
        }

<span class="fc bfc" id="L795" title="All 2 branches covered.">        final Map&lt;String, String&gt; theHash = preserveOrder ? new LinkedHashMap&lt;&gt;() : new HashMap&lt;&gt;();</span>
<span class="fc" id="L796">        final List&lt;ConfigEntry&gt; parameters = this.findStringMatchEntries(theParameter);</span>

<span class="fc bfc" id="L798" title="All 2 branches covered.">        for (final ConfigEntry el : parameters) {</span>
<span class="fc" id="L799">            String key = el.getKey();</span>
<span class="fc" id="L800">            key = key.substring(theParameter.length());</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">            if (!preserveCase) {</span>
<span class="fc" id="L802">                key = key.toUpperCase(Locale.getDefault());</span>
            }
<span class="fc" id="L804">            theHash.put(key, el.getValue());</span>
<span class="fc" id="L805">        }</span>
<span class="fc" id="L806">        return theHash;</span>
    }

    /**
     * Find entries beginning with the specified string and return a hash keyed on the remainder of the string with the
     * value of the config line as the value of the hash Multiple values for the same hash are allowed and returned as a
     * Set.
     *
     * &lt;pre&gt;
     * {@code
     * Example config entries
     *    FOO_ONE: AAA
     *    FOO_TWO: BBB
     *    FOO_TWO: CCC
     * Calling findStringMatchMap(&quot;FOO_&quot;,true)
     * will yield a map with Sets
     *     ONE -&gt; {AAA}
     *     TWO -&gt; {BBB,CCC}
     * }
     * &lt;/pre&gt;
     *
     * @param param the key to look for in the config file
     * @return map where key is remainder after match and value is a Set of all found config values, or an empty map if none
     *         found
     */
    @Override
    public Map&lt;String, Set&lt;String&gt;&gt; findStringMatchMultiMap(@Nullable final String param) {
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">        if (param == null) {</span>
<span class="nc" id="L834">            return Map.of();</span>
        }

<span class="fc" id="L837">        return findStringMatchMultiMap(param, false);</span>
    }

    /**
     * Find entries beginning with the specified string and return a hash keyed on the remainder of the string with the
     * value of the config line as the value of the hash Multiple values for the same hash are allowed and returned as a
     * Set.
     *
     * &lt;pre&gt;
     * {@code
     * Example config entries
     *    FOO_ONE: AAA
     *    FOO_TWO: BBB
     *    FOO_TWO: CCC
     * Calling findStringMatchMap(&quot;FOO_&quot;,true)
     * will yield a map with Sets
     *     ONE -&gt; {AAA}
     *     TWO -&gt; {BBB,CCC}
     * }
     * &lt;/pre&gt;
     *
     * @param param the key to look for in the config file
     * @param preserveOrder ordering of keys is preserved
     * @return map where key is remainder after match and value is a Set of all found config values, or an empty map if none
     *         found
     */
    @Override
    public Map&lt;String, Set&lt;String&gt;&gt; findStringMatchMultiMap(@Nullable final String param, final boolean preserveOrder) {

<span class="pc bpc" id="L866" title="1 of 2 branches missed.">        if (param == null) {</span>
<span class="nc" id="L867">            return Map.of();</span>
        }

<span class="fc bfc" id="L870" title="All 2 branches covered.">        final Map&lt;String, Set&lt;String&gt;&gt; theHash = preserveOrder ? new LinkedHashMap&lt;&gt;() : new HashMap&lt;&gt;();</span>
<span class="fc" id="L871">        final List&lt;ConfigEntry&gt; parameters = this.findStringMatchEntries(param);</span>

<span class="fc bfc" id="L873" title="All 2 branches covered.">        for (final ConfigEntry el : parameters) {</span>
<span class="fc" id="L874">            final String key = el.getKey().substring(param.length()).toUpperCase(Locale.getDefault());</span>

<span class="fc bfc" id="L876" title="All 2 branches covered.">            if (theHash.containsKey(key)) {</span>
<span class="fc" id="L877">                theHash.get(key).add(el.getValue());</span>
            } else {
<span class="fc bfc" id="L879" title="All 2 branches covered.">                final Set&lt;String&gt; values = preserveOrder ? new LinkedHashSet&lt;&gt;() : new HashSet&lt;&gt;();</span>
<span class="fc" id="L880">                values.add(el.getValue());</span>
<span class="fc" id="L881">                theHash.put(key, values);</span>
            }
<span class="fc" id="L883">        }</span>
<span class="fc" id="L884">        return theHash;</span>

    }

    /**
     * Return the first string entry matching the key parameter
     *
     * @param theParameter key to match
     * @return the first matching value
     * @throws IllegalArgumentException if no non-blank value is found
     */
    @Override
    public String findRequiredStringEntry(final String theParameter) {
<span class="fc" id="L897">        String value = findStringEntry(theParameter, null);</span>
<span class="fc" id="L898">        Validate.notBlank(value, &quot;Missing required parameter [%s]&quot;, theParameter);</span>
<span class="fc" id="L899">        return value;</span>
    }

    /**
     * Return the first string entry matching the key parameter or the default if no match is found
     *
     * @param theParameter the key to match
     * @param dflt string to use when no matches are found
     * @return the first matching entry of the default if none found
     */
    @Override
    public String findStringEntry(final String theParameter, @Nullable final String dflt) {
<span class="fc" id="L911">        final List&lt;String&gt; matchingEntries = findEntries(theParameter);</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">        for (final String entry : matchingEntries) {</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (entry != null) {</span>
<span class="fc" id="L914">                return entry;</span>
            }
<span class="fc" id="L916">        }</span>
<span class="fc" id="L917">        return dflt;</span>
    }

    /**
     * Return the first string entry matching the key parameter or null if no match is found
     *
     * @param theParameter key to match
     * @return the first matching value or null if none
     */
    @Override
    public String findStringEntry(final String theParameter) {
<span class="fc" id="L928">        return findStringEntry(theParameter, null);</span>
    }

    /**
     * Return the last (newest) string entry matching the key parameter or an empty string if no match is found
     *
     * @param theParameter the key to match
     * @return the last matching value or empty string if none found
     */
    @Override
    public String findLastStringEntry(final String theParameter) {
<span class="fc" id="L939">        String result = &quot;&quot;;</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">        for (final ConfigEntry curEntry : this.serviceParameters) {</span>
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">            if (theParameter.equals(curEntry.getKey())) {</span>
<span class="fc" id="L942">                result = curEntry.getValue();</span>
            }
<span class="fc" id="L944">        }</span>
<span class="fc" id="L945">        return result;</span>
    }

    /**
     * Return a long from a string entry representing either an int, a long, a double, with or without a final letter
     * designation such as &quot;m&quot; or &quot;M&quot; for megabytes, &quot;g&quot; or &quot;G&quot; for gigabytes, etc. Legal designations are bBkKmMgGTt or
     * just a number.
     *
     * @param theParameter the config entry name
     * @param dflt the default value when nothing found in config
     * @return the long value of the size parameter
     */
    @Override
    public long findSizeEntry(final String theParameter, final long dflt) {
<span class="fc" id="L959">        final List&lt;String&gt; matchingEntries = findEntries(theParameter);</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (!matchingEntries.isEmpty()) {</span>
<span class="fc" id="L961">            long val = dflt;</span>
<span class="fc" id="L962">            final String s = matchingEntries.get(0);</span>
<span class="fc" id="L963">            final char c = Character.toUpperCase(s.charAt(s.length() - 1));</span>
<span class="fc" id="L964">            final String ss = s.substring(0, s.length() - 1);</span>
<span class="fc" id="L965">            boolean broken = false;</span>
<span class="fc bfc" id="L966" title="All 7 branches covered.">            switch (c) {</span>
                case 'T':
<span class="fc" id="L968">                    val = Long.parseLong(ss) * 1024 * 1024 * 1024 * 1024;</span>
<span class="fc" id="L969">                    break;</span>
                case 'G':
<span class="fc" id="L971">                    val = Long.parseLong(ss) * 1024 * 1024 * 1024;</span>
<span class="fc" id="L972">                    break;</span>
                case 'M':
<span class="fc" id="L974">                    val = Long.parseLong(ss) * 1024 * 1024;</span>
<span class="fc" id="L975">                    break;</span>
                case 'K':
<span class="fc" id="L977">                    val = Long.parseLong(ss) * 1024;</span>
<span class="fc" id="L978">                    break;</span>
                case 'B':
<span class="fc" id="L980">                    val = Long.parseLong(ss);</span>
<span class="fc" id="L981">                    break;</span>
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
<span class="fc" id="L992">                    val = Long.parseLong(s);</span>
<span class="fc" id="L993">                    break;</span>
                default:
<span class="fc" id="L995">                    broken = true;</span>
            }

<span class="fc bfc" id="L998" title="All 2 branches covered.">            if (!broken) {</span>
<span class="fc" id="L999">                return val;</span>
            }
<span class="fc" id="L1001">            return dflt;</span>
        }
<span class="fc" id="L1003">        return dflt;</span>
    }

    /**
     * Return the string canonical file name of a matching entry
     *
     * @param theParameter the key to match
     * @param dflt the string to use as a default when no matches are found
     * @return the first matching value run through File.getCanonicalPath
     */
    @Override
    public String findCanonicalFileNameEntry(final String theParameter, final String dflt) {
<span class="fc" id="L1015">        final String fn = findStringEntry(theParameter, dflt);</span>
<span class="pc bpc" id="L1016" title="1 of 4 branches missed.">        if (fn != null &amp;&amp; fn.length() &gt; 0) {</span>
            try {
<span class="fc" id="L1018">                return new File(fn).getCanonicalPath();</span>
<span class="nc" id="L1019">            } catch (IOException ex) {</span>
<span class="nc" id="L1020">                logger.error(&quot;Cannot compute canonical path on {}&quot;, fn, ex);</span>
            }
        }
<span class="fc" id="L1023">        return fn;</span>
    }

    /**
     * Return an int of the first entry matching the key parameter or the default if no match is found
     *
     * @param theParameter the key to match
     * @param dflt the int to use when no matches are found
     * @return the first matching value or the default when none found
     */
    @Override
    public int findIntEntry(final String theParameter, final int dflt) {
<span class="fc" id="L1035">        final List&lt;String&gt; matchingEntries = findEntries(theParameter);</span>

<span class="fc bfc" id="L1037" title="All 2 branches covered.">        if (!matchingEntries.isEmpty()) {</span>
            try {
<span class="fc" id="L1039">                return Integer.parseInt(matchingEntries.get(0));</span>
<span class="nc" id="L1040">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L1041">                logger.warn(&quot;{} is non-numeric returning default value: {}&quot;, theParameter, dflt);</span>
            }
        }
<span class="fc" id="L1044">        return dflt;</span>
    }

    /**
     * Return a long of the first entry matching the key parameter or the default if no match is found
     *
     * @param theParameter the key to match
     * @param dflt the value to use when no matches are found
     * @return the first matching value or the default when none found
     */
    @Override
    public long findLongEntry(final String theParameter, final long dflt) {
<span class="fc" id="L1056">        final List&lt;String&gt; matchingEntries = findEntries(theParameter);</span>

<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (!matchingEntries.isEmpty()) {</span>
            try {
<span class="fc" id="L1060">                return Long.parseLong(matchingEntries.get(0));</span>
<span class="nc" id="L1061">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L1062">                logger.warn(&quot;{} is non-numeric returning default value: {}&quot;, theParameter, dflt);</span>
            }
        }
<span class="fc" id="L1065">        return dflt;</span>
    }

    /**
     * Return a double of the first entry matching the key parameter or the default if no match is found
     *
     * @param theParameter the key to match
     * @param dflt the value to use when no matches are found
     * @return the first matching value or the default when none found
     */
    @Override
    public double findDoubleEntry(final String theParameter, final double dflt) {
<span class="fc" id="L1077">        final List&lt;String&gt; matchingEntries = findEntries(theParameter);</span>

<span class="fc bfc" id="L1079" title="All 2 branches covered.">        if (!matchingEntries.isEmpty()) {</span>
            try {
<span class="fc" id="L1081">                return Double.parseDouble(matchingEntries.get(0));</span>
<span class="nc" id="L1082">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L1083">                logger.warn(&quot;{} is non-numeric returning default value: {}&quot;, theParameter, dflt);</span>
            }
        }
<span class="fc" id="L1086">        return dflt;</span>
    }

    /**
     * Return boolean of the first entry matching the key parameter or the default if no match is found
     *
     * @param theParameter the key to match
     * @param dflt the value to use when no matches are found
     * @return the first matching value or the default when none found
     */
    @Override
    public boolean findBooleanEntry(final String theParameter, final boolean dflt) {
<span class="fc" id="L1098">        final List&lt;String&gt; matchingEntries = findEntries(theParameter);</span>

<span class="fc bfc" id="L1100" title="All 2 branches covered.">        if (!matchingEntries.isEmpty()) {</span>
<span class="fc" id="L1101">            String el = matchingEntries.get(0);</span>
<span class="fc" id="L1102">            el = el.toUpperCase(Locale.getDefault());</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">            if (el.startsWith(&quot;F&quot;)) {</span>
<span class="fc" id="L1104">                return false;</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">            } else if (el.startsWith(&quot;T&quot;)) {</span>
<span class="fc" id="L1106">                return true;</span>
            }
        }
<span class="fc" id="L1109">        return dflt;</span>
    }

    /**
     * Return boolean of the first entry matching the key parameter or the default if no match is found
     *
     * @param theParameter the key to match
     * @param dflt the value to use when no matches are found
     * @return the first matching value or the default when none found
     */
    @Override
    public boolean findBooleanEntry(final String theParameter, final String dflt) {
<span class="fc" id="L1121">        return findBooleanEntry(theParameter, Boolean.parseBoolean(dflt));</span>
    }

    /**
     * Get the value of a parameter that is purported to be numeric
     *
     * @param name the name of the parameter
     */
    protected int getNumericParameter(final String name) {
<span class="nc" id="L1130">        final String val = this.values.get(name);</span>
<span class="nc" id="L1131">        int i = -1;</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (val != null) {</span>
            try {
<span class="nc" id="L1134">                i = Integer.parseInt(val);</span>
<span class="nc" id="L1135">            } catch (NumberFormatException ex) {</span>
<span class="nc" id="L1136">                logger.warn(&quot;{} is non-numeric: {}&quot;, name, val);</span>
<span class="nc" id="L1137">            }</span>
        }
<span class="nc" id="L1139">        return i;</span>
    }

    public boolean debug() {
<span class="fc" id="L1143">        return &quot;TRUE&quot;.equalsIgnoreCase(this.values.get(&quot;DEBUG&quot;));</span>
    }

    /**
     * Merge in a new configuration set with this one. New things are supposed to override older things in the sense of
     * findStringEntry which only picks the top of the list, the new things should get added to the top. If the merged in
     * Configurator contains remove entries (operator of '!=') then it only applies to entries in this instance, not in
     * &quot;other&quot;. This is slightly different than when a config is read in directly, but without that there would be no way to
     * remove entries from a super-config and continue to supply entries here and still be able to use the wildcard remove
     * (value of '*') The order in the merged config file is important. Any '!= &quot;*&quot;' operations must precede the new value
     * being supplied since normal remove operations take place in each config before the merge.
     *
     * @param other the new entries to merge in
     */
    @Override
    public void merge(final Configurator other) throws IOException {
<span class="fc" id="L1159">        int i = 1;</span>

        // First handle the remove entries from &quot;other&quot;
<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">        if (other instanceof ServiceConfigGuide) {</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">            for (final ConfigEntry entry : ((ServiceConfigGuide) other).getRemoveEntries()) {</span>
<span class="fc" id="L1164">                handleNewEntry(entry.getKey(), entry.getValue(), &quot;!=&quot;, &quot;&lt;merge&gt;&quot;, i++, true);</span>
<span class="fc" id="L1165">            }</span>
        }

        // Add in new entries from &quot;other&quot; at the top of the list
<span class="fc bfc" id="L1169" title="All 2 branches covered.">        for (final ConfigEntry entry : other.getEntries()) {</span>
<span class="fc" id="L1170">            handleNewEntry(entry.getKey(), entry.getValue(), &quot;=&quot;, &quot;&lt;merge&gt;&quot;, i++, true);</span>
<span class="fc" id="L1171">        }</span>
<span class="fc" id="L1172">    }</span>

    /**
     * Public main used to verify config file construction off-line
     */
    public static void main(final String[] args) {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        if (args.length &lt; 1) {</span>
<span class="nc" id="L1179">            logger.error(&quot;usage: java ServiceConfigGuide configfile&quot;);</span>
<span class="nc" id="L1180">            return;</span>
        }

<span class="nc bnc" id="L1183" title="All 2 branches missed.">        for (String arg : args) {</span>
            try {
<span class="nc" id="L1185">                final ServiceConfigGuide sc = new ServiceConfigGuide(arg);</span>
<span class="nc" id="L1186">                logger.info(&quot;Config File:{} &quot;, arg);</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">                for (int i = 0; i &lt; sc.serviceParameters.size(); i++) {</span>
<span class="nc" id="L1188">                    final ConfigEntry c = sc.serviceParameters.get(i);</span>
<span class="nc" id="L1189">                    logger.info(&quot;{}: {}&quot;, c.getKey(), c.getValue());</span>
                }
<span class="nc" id="L1191">                logger.info(&quot;---&quot;);</span>
<span class="nc" id="L1192">            } catch (IOException e) {</span>
<span class="nc" id="L1193">                logger.info(&quot;Cannot process {}:{}&quot;, arg, e.getLocalizedMessage());</span>
<span class="nc" id="L1194">            }</span>
        }
<span class="nc" id="L1196">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>