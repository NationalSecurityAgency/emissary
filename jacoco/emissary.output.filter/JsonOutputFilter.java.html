<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonOutputFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.output.filter</a> &gt; <span class="el_source">JsonOutputFilter.java</span></div><h1>JsonOutputFilter.java</h1><pre class="source lang-java linenums">package emissary.output.filter;

import emissary.config.Configurator;
import emissary.core.IBaseDataObject;
import emissary.core.channels.SeekableByteChannelFactory;
import emissary.directory.DirectoryEntry;
import emissary.output.io.DateFilterFilenameGenerator;
import emissary.util.TimeUtil;

import com.fasterxml.jackson.annotation.JsonFilter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;
import com.fasterxml.jackson.databind.ser.PropertyWriter;
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
import com.fasterxml.jackson.databind.ser.std.MapProperty;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.annotation.Nullable;
import org.apache.commons.collections4.CollectionUtils;

import java.io.IOException;
import java.time.Instant;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.UUID;

import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;

/**
 * JSON Output filter using Jackson
 */
<span class="fc" id="L47">public class JsonOutputFilter extends AbstractRollableFilter {</span>

<span class="fc" id="L49">    protected Set&lt;String&gt; denylistFields = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L50">    protected Set&lt;String&gt; denylistPrefixes = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L51">    protected Set&lt;String&gt; allowlistFields = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L52">    protected Set&lt;String&gt; allowlistPrefixes = new TreeSet&lt;&gt;();</span>
    protected Map&lt;String, Set&lt;String&gt;&gt; denylistValues;
    protected Set&lt;String&gt; stripPrefixes;

<span class="fc" id="L56">    protected boolean emitPayload = true;</span>

    protected ObjectMapper jsonMapper;

    @Override
    public void initialize(final Configurator theConfigG, @Nullable final String filterName, final Configurator theFilterConfig) {
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">        if (filterName == null) {</span>
<span class="nc" id="L63">            setFilterName(&quot;JSON&quot;);</span>
        }
<span class="fc" id="L65">        super.initialize(theConfigG, filterName, theFilterConfig);</span>
<span class="fc" id="L66">        this.allowlistFields.addAll(this.filterConfig.findEntries(&quot;EXTRA_PARAM&quot;));</span>
<span class="fc" id="L67">        this.allowlistPrefixes.addAll(this.filterConfig.findEntries(&quot;EXTRA_PREFIX&quot;));</span>
<span class="fc" id="L68">        this.denylistFields.addAll(this.filterConfig.findEntries(&quot;DENYLIST_FIELD&quot;));</span>
<span class="fc" id="L69">        this.denylistPrefixes.addAll(this.filterConfig.findEntries(&quot;DENYLIST_PREFIX&quot;));</span>
<span class="fc" id="L70">        this.denylistValues = this.filterConfig.findStringMatchMultiMap(&quot;DENYLIST_VALUE_&quot;);</span>
<span class="fc" id="L71">        this.stripPrefixes = this.filterConfig.findEntriesAsSet(&quot;STRIP_PARAM_PREFIX&quot;);</span>
<span class="fc" id="L72">        this.emitPayload = this.filterConfig.findBooleanEntry(&quot;EMIT_PAYLOAD&quot;, true);</span>
<span class="fc" id="L73">        initFilenameGenerator();</span>
<span class="fc" id="L74">        initJsonMapper();</span>
<span class="fc" id="L75">    }</span>

    @Override
    protected void initFilenameGenerator() {
<span class="fc" id="L79">        this.fileNameGenerator = new DateFilterFilenameGenerator(&quot;json&quot;);</span>
<span class="fc" id="L80">    }</span>

    /**
     * Initialize the Jackson json object mapper
     */
    protected void initJsonMapper() {
<span class="fc" id="L86">        jsonMapper = new ObjectMapper();</span>
<span class="fc" id="L87">        jsonMapper.registerModule(new IbdoModule());</span>
<span class="fc" id="L88">        jsonMapper.registerModule(new JavaTimeModule());</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        jsonMapper.addMixIn(IBaseDataObject.class, emitPayload ? IbdoPayloadMixin.class : IbdoParameterMixin.class);</span>
        // the id in addFilter must match the annotation for JsonFilter
<span class="fc" id="L91">        jsonMapper.setFilterProvider(new SimpleFilterProvider().addFilter(&quot;param_filter&quot;, new IbdoParameterFilter()));</span>
<span class="fc" id="L92">    }</span>

    @Override
    public byte[] convert(final List&lt;IBaseDataObject&gt; list, final Map&lt;String, Object&gt; params) throws IOException {
<span class="fc" id="L96">        return jsonMapper.writeValueAsBytes(list);</span>
    }

    class IbdoParameterFilter extends SimpleBeanPropertyFilter {

        protected final boolean outputAll;
        protected final boolean emptyDenylist;
        protected final boolean denylistStar;
        protected final boolean emptyAllowlist;
        protected final boolean allowlistStar;
        private static final char KEY_REPLACEMENT = '_';

<span class="fc" id="L108">        public IbdoParameterFilter() {</span>
            // if all collections are empty, then output everything
<span class="pc bpc" id="L110" title="1 of 4 branches missed.">            this.allowlistStar = (allowlistFields.contains(&quot;*&quot;) || allowlistFields.contains(&quot;ALL&quot;));</span>
<span class="pc bpc" id="L111" title="1 of 4 branches missed.">            this.denylistStar = (denylistFields.contains(&quot;*&quot;) || denylistFields.contains(&quot;ALL&quot;));</span>
<span class="fc bfc" id="L112" title="All 4 branches covered.">            this.emptyDenylist = CollectionUtils.isEmpty(denylistFields) &amp;&amp; CollectionUtils.isEmpty(denylistPrefixes);</span>
<span class="pc bpc" id="L113" title="1 of 4 branches missed.">            this.emptyAllowlist = CollectionUtils.isEmpty(allowlistFields) &amp;&amp; CollectionUtils.isEmpty(allowlistPrefixes);</span>
<span class="fc bfc" id="L114" title="All 6 branches covered.">            this.outputAll = emptyDenylist &amp;&amp; (allowlistStar || emptyAllowlist);</span>
<span class="fc" id="L115">        }</span>

        @Override
        public void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider provider, PropertyWriter writer) throws Exception {

<span class="fc" id="L120">            String key = writer.getName();</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L122">            Collection&lt;Object&gt; values = (Collection&lt;Object&gt;) ((Map&lt;?, ?&gt;) pojo).get(key);</span>

<span class="fc bfc" id="L124" title="All 2 branches covered.">            if (includeParameter(key)) {</span>
<span class="fc" id="L125">                Collection&lt;Object&gt; write = filter(key, values);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">                if (CollectionUtils.isNotEmpty(write)) {</span>
                    // customize the key
<span class="fc" id="L128">                    jgen.writeFieldName(transform(key));</span>

                    // only write the element
<span class="fc" id="L131">                    ((MapProperty) writer).setValue(write);</span>
<span class="fc" id="L132">                    writer.serializeAsElement(write, jgen, provider);</span>
                }
            }
<span class="fc" id="L135">        }</span>

        protected boolean includeParameter(String key) {
<span class="fc bfc" id="L138" title="All 2 branches covered.">            if (outputAll) {</span>
<span class="fc" id="L139">                return true;</span>
            }

            // check the allow/deny list first
<span class="fc bfc" id="L143" title="All 2 branches covered.">            if (denylistFields.contains(key)) {</span>
<span class="fc" id="L144">                return false;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            } else if (allowlistFields.contains(key)) {</span>
<span class="fc" id="L146">                return true;</span>
            }

            // see if there is a hit on the denylist prefix
<span class="fc bfc" id="L150" title="All 2 branches covered.">            for (final String prefix : denylistPrefixes) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">                if (key.startsWith(prefix)) {</span>
<span class="fc" id="L152">                    return false;</span>
                }
<span class="fc" id="L154">            }</span>

            // omit/emit all parameters if '*' or 'ALL'
<span class="fc bfc" id="L157" title="All 2 branches covered.">            if (denylistStar) {</span>
<span class="fc" id="L158">                return false;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            } else if (allowlistStar) {</span>
<span class="fc" id="L160">                return true;</span>
            }

            // there is a hit on the allow-list prefix, but it is on the deny-list
<span class="fc bfc" id="L164" title="All 2 branches covered.">            for (final String prefix : allowlistPrefixes) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                if (key.startsWith(prefix)) {</span>
<span class="fc" id="L166">                    return true;</span>
                }
<span class="fc" id="L168">            }</span>

            // if we were only given an deny-list, output all keys
<span class="fc" id="L171">            return emptyAllowlist;</span>
        }

        protected Collection&lt;Object&gt; filter(String key, Collection&lt;Object&gt; values) {
<span class="fc" id="L175">            Set&lt;Object&gt; keep = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            for (final Object value : values) {</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">                if (!(denylistValues.containsKey(key) &amp;&amp; denylistValues.get(key).contains(value.toString()))) {</span>
<span class="fc" id="L178">                    keep.add(value);</span>
                }
<span class="fc" id="L180">            }</span>
<span class="fc" id="L181">            return keep;</span>
        }

        protected String transform(String name) {
<span class="fc" id="L185">            return normalize(strip(name.toUpperCase(Locale.getDefault())));</span>
        }

        protected String strip(String name) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">            for (final String prefix : stripPrefixes) {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (name.startsWith(prefix)) {</span>
<span class="fc" id="L191">                    return name.substring(prefix.length());</span>
                }
<span class="fc" id="L193">            }</span>
<span class="fc" id="L194">            return name;</span>
        }

        protected String normalize(String name) {
<span class="fc" id="L198">            boolean changed = false;</span>
<span class="fc" id="L199">            char[] ch = name.toCharArray();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (int i = 0; i &lt; ch.length; i++) {</span>
<span class="pc bpc" id="L201" title="3 of 6 branches missed.">                if (!Character.isLetterOrDigit(ch[i]) &amp;&amp; Character.compare(ch[i], '_') != 0 &amp;&amp; Character.compare(ch[i], '.') != 0) {</span>
<span class="nc" id="L202">                    ch[i] = KEY_REPLACEMENT;</span>
<span class="nc" id="L203">                    changed = true;</span>
                }
            }
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (changed) {</span>
<span class="nc" id="L207">                return new String(ch);</span>
            }

<span class="fc" id="L210">            return name;</span>
        }
    }

    /**
     * Ibdo {@link Module} implementation that allows registration of serializers
     */
    class IbdoModule extends SimpleModule {
        private static final long serialVersionUID = -8129967131240053241L;

<span class="fc" id="L220">        public IbdoModule() {</span>
<span class="fc" id="L221">            addSerializer(IBaseDataObject.class, new IbdoSerializer());</span>
<span class="fc" id="L222">        }</span>
    }

    /**
     * Add some fields to the ibdo before output This is only needed if custom fields need to be written for the ibdo
     */
<span class="fc" id="L228">    class IbdoSerializer extends JsonSerializer&lt;IBaseDataObject&gt; {</span>

        @Override
        public void serialize(IBaseDataObject ibdo, JsonGenerator jgen, SerializerProvider provider) throws IOException {
<span class="fc" id="L232">            jgen.writeStartObject();</span>
<span class="fc" id="L233">            JavaType javaType = provider.constructType(IBaseDataObject.class);</span>
<span class="fc" id="L234">            BeanDescription beanDesc = provider.getConfig().introspect(javaType);</span>
<span class="fc" id="L235">            JsonSerializer&lt;Object&gt; serializer = BeanSerializerFactory.instance.findBeanOrAddOnSerializer(provider, javaType, beanDesc,</span>
<span class="fc" id="L236">                    provider.isEnabled(MapperFeature.USE_STATIC_TYPING));</span>

            // add some custom fields here
<span class="fc" id="L239">            jgen.writeObjectField(&quot;id&quot;, dropOffUtil.getBestIdFrom(ibdo));</span>
<span class="fc" id="L240">            jgen.writeObjectField(&quot;processedTimestamp&quot;, TimeUtil.getCurrentDateFullISO8601());</span>

<span class="fc" id="L242">            serializer.unwrappingSerializer(null).serialize(ibdo, jgen, provider);</span>
<span class="fc" id="L243">            jgen.writeEndObject();</span>
<span class="fc" id="L244">        }</span>
    }

    /**
     * This class is used so we do not have to annotate the IBaseDataObject. Set custom annotations on the method signatures
     * to include/exclude fields in the ibdo.
     */
<span class="nc" id="L251">    abstract static class IbdoMixin {</span>
        @JsonProperty(&quot;internalId&quot;)
        abstract UUID getInternalId();

        @JsonProperty(&quot;creationTimestamp&quot;)
        abstract Instant getCreationTimestamp();

        @JsonProperty(&quot;shortName&quot;)
        abstract String shortName();

        @JsonProperty(&quot;parameters&quot;)
        @JsonFilter(&quot;param_filter&quot;)
        abstract Map&lt;String, Collection&lt;Object&gt;&gt; getParameters();

        @JsonProperty(&quot;members&quot;)
        @JsonInclude(NON_EMPTY)
        abstract List&lt;IBaseDataObject&gt; getExtractedRecords();

        @JsonIgnore
        abstract SeekableByteChannelFactory getChannelFactory();

        @JsonIgnore
        abstract int dataLength();

        @JsonIgnore
        abstract String getHeaderEncoding();

        @JsonIgnore
        abstract int getNumChildren();

        @JsonIgnore
        abstract int getNumSiblings();

        @JsonIgnore
        abstract int getBirthOrder();

        @JsonIgnore
        abstract String getFontEncoding();

        @JsonIgnore
        abstract Map&lt;String, String&gt; getCookedParameters();

        @JsonIgnore
        abstract Set&lt;String&gt; getParameterKeys();

        @JsonIgnore
        abstract boolean isFileTypeEmpty();

        @JsonIgnore
        abstract String getFileType();

        @JsonIgnore
        abstract int getNumAlternateViews();

        @JsonIgnore
        abstract Set&lt;String&gt; getAlternateViewNames();

        @JsonIgnore
        abstract boolean isBroken();

        @JsonIgnore
        abstract String getFilename();

        @JsonIgnore
        abstract List&lt;String&gt; getAllCurrentForms();

        @JsonIgnore
        abstract DirectoryEntry getLastPlaceVisited();

        @JsonIgnore
        abstract DirectoryEntry getPenultimatePlaceVisited();

        @JsonIgnore
        abstract int getPriority();

        @JsonIgnore
        abstract int getExtractedRecordCount();

        @JsonIgnore
        abstract boolean isOutputable();

        @JsonIgnore
        abstract String getBroken();

        @JsonIgnore
        abstract String getProcessingError();
    }

<span class="nc" id="L339">    abstract static class IbdoParameterMixin extends IbdoMixin {</span>
        @JsonIgnore
        abstract byte[] data();

        @JsonIgnore
        abstract Map&lt;String, byte[]&gt; getAlternateViews();
    }

<span class="nc" id="L347">    abstract static class IbdoPayloadMixin extends IbdoMixin {</span>
        @JsonProperty(&quot;payload&quot;)
        @JsonInclude(NON_EMPTY)
        abstract byte[] data();

        @JsonProperty(&quot;views&quot;)
        @JsonInclude(NON_EMPTY)
        abstract Map&lt;String, byte[]&gt; getAlternateViews();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>