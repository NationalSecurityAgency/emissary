<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractFilter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.output.filter</a> &gt; <span class="el_source">AbstractFilter.java</span></div><h1>AbstractFilter.java</h1><pre class="source lang-java linenums">package emissary.output.filter;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.core.EmissaryRuntimeException;
import emissary.core.IBaseDataObject;
import emissary.output.DropOffUtil;
import emissary.util.JavaCharSet;

import jakarta.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Provides the base mechanism for a drop off filter
 */
<span class="fc" id="L31">public abstract class AbstractFilter implements IDropOffFilter {</span>
    /** A static convenience logger */
<span class="fc" id="L33">    protected static final Logger slogger = LoggerFactory.getLogger(AbstractFilter.class);</span>

    /** get a logger configured on the impl's classname */
<span class="fc" id="L36">    protected Logger logger = LoggerFactory.getLogger(this.getClass().getName());</span>

    /** hold onto the parent configurator */
    protected Configurator configG;

    /** hold onto the specific filter configurator */
    protected Configurator filterConfig;

    /** hold onto the filter name, impl should set this */
<span class="fc" id="L45">    protected String filterName = &quot;Abstract&quot;;</span>

    /** hold the output specification, if any, for this filter */
    protected String outputSpec;

    /** hold the error specification, if any, for this filter */
    protected String errorSpec;

    /** hold the filter condition specification, if any, for this filter */
    protected String filterConditionSpec;

    /** hold the filter condition, if any, for this filter */
    private IFilterCondition filterCondition;

    /**
     * A set of FileType and FileTYpe.ViewName strings controlling what can be output by this filter
     */
<span class="fc" id="L62">    protected Set&lt;String&gt; outputTypes = Collections.emptySet();</span>

    /** String to use when dealing with the primary view specifically */
    public static final String PRIMARY_VIEW_NAME = &quot;PrimaryView&quot;;
    public static final String PRIMARY_VIEW = &quot;.&quot; + PRIMARY_VIEW_NAME;

    /** Primary view wildcard string */
    public static final String ALL_PRIMARY_VIEWS = &quot;*&quot; + PRIMARY_VIEW;

    /** String to use when dealing with a language in a view */
    public static final String LANGUAGE_VIEW_NAME = &quot;Language&quot;;
    public static final String LANGUAGE_VIEW = &quot;.&quot; + LANGUAGE_VIEW_NAME;

    /** Language wildcard string */
    public static final String ALL_LANGUAGE_VIEWS = &quot;*&quot; + LANGUAGE_VIEW;

    /** Alternate view wildcard string */
    public static final String ALL_ALT_VIEWS = &quot;*.AlternateView&quot;;

    /** Metadata view name */
    public static final String METADATA_VIEW_NAME = &quot;Metadata&quot;;
    public static final String METADATA_VIEW = &quot;.&quot; + METADATA_VIEW_NAME;

    /* alternate views to NOT output if only a file type/form is specified */
<span class="fc" id="L86">    protected Set&lt;String&gt; denylist = new HashSet&lt;&gt;();</span>
<span class="fc" id="L87">    protected Set&lt;String&gt; wildCardDenylist = new HashSet&lt;&gt;();</span>

<span class="fc" id="L89">    @Nullable</span>
    protected DropOffUtil dropOffUtil = null;

<span class="fc" id="L92">    protected String denylistAllowedNameChars = &quot;a-zA-Z0-9_\\-&quot;;</span>
<span class="fc" id="L93">    protected String denylistFiletypeFormat = &quot;^[%s]+$&quot;;</span>
    protected Pattern denylistFiletypeFormatPattern;
<span class="fc" id="L95">    protected String denylistViewNameFormat = &quot;^[%s]+(\\.[%s]+)?\\*?$&quot;;</span>
    protected Pattern denylistViewNameFormatPattern;

    /**
     * Initialization phase hook for the filter with default preferences for the runtime configuration of the filter
     */
    @Override
    public void initialize(final Configurator theConfigG, final String filterName) {
<span class="fc" id="L103">        loadFilterConfiguration(null);</span>
<span class="fc" id="L104">        initialize(theConfigG, filterName, this.filterConfig);</span>
<span class="fc" id="L105">    }</span>

    /**
     * Initialization phase hook for the filter with provided filter configuration
     * 
     * @param theConfigG passed in configuration object, usually DropOff's config
     * @param filterName the configured name of this filter or null for the default
     * @param theFilterConfig the configuration for the specific filter
     */
    @Override
    public void initialize(final Configurator theConfigG, @Nullable final String filterName,
            final Configurator theFilterConfig) {
<span class="fc" id="L117">        this.configG = theConfigG;</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (filterName != null) {</span>
<span class="fc" id="L119">            setFilterName(filterName);</span>
        }
<span class="fc" id="L121">        loadFilterConfiguration(theFilterConfig);</span>
<span class="fc" id="L122">        loadFilterCondition(theConfigG);</span>
<span class="fc" id="L123">        loadOutputSpec(theConfigG);</span>
<span class="fc" id="L124">        this.dropOffUtil = new DropOffUtil(theConfigG);</span>
<span class="fc" id="L125">        initializeOutputTypes(this.filterConfig);</span>
<span class="fc" id="L126">    }</span>

    private void loadFilterCondition(final Configurator parentConfig) {
<span class="fc" id="L129">        this.filterConditionSpec = parentConfig.findStringEntry(&quot;FILTER_CONDITION_&quot; + getFilterName(), null);</span>

        // format FILTER_CONDITION_&lt;filtername&gt; = profilename:clazz just like dropoff filter config
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (!StringUtils.isEmpty(filterConditionSpec)) {</span>
            final String name;
            final String clazz;
<span class="nc" id="L135">            Configurator filterConfig = null;</span>
<span class="nc" id="L136">            final int colpos = filterConditionSpec.indexOf(':');</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (colpos &gt; -1) {</span>
<span class="nc" id="L138">                name = filterConditionSpec.substring(0, colpos);</span>
<span class="nc" id="L139">                clazz = filterConditionSpec.substring(colpos + 1);</span>
<span class="nc" id="L140">                final String filterConfigName = parentConfig.findStringEntry(name);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if (filterConfigName != null) {</span>
                    try {
<span class="nc" id="L143">                        filterConfig = ConfigUtil.getConfigInfo(filterConfigName);</span>
<span class="nc" id="L144">                    } catch (IOException configError) {</span>
<span class="nc" id="L145">                        logger.warn(&quot;Specified filter configuration {} cannot be loaded&quot;, filterConfigName);</span>
<span class="nc" id="L146">                        return;</span>
<span class="nc" id="L147">                    }</span>
                }
<span class="nc" id="L149">            } else {</span>
<span class="nc" id="L150">                clazz = filterConditionSpec;</span>
            }

            try {
<span class="nc" id="L154">                final Object filterConditionObj = emissary.core.Factory.create(clazz);</span>

<span class="nc bnc" id="L156" title="All 4 branches missed.">                if (filterConditionObj != null &amp;&amp; filterConditionObj instanceof IFilterCondition) {</span>
<span class="nc" id="L157">                    this.filterCondition = (IFilterCondition) filterConditionObj;</span>
                    // initialize using the config
<span class="nc" id="L159">                    filterCondition.initialize(filterConfig);</span>
                } else {
<span class="nc" id="L161">                    logger.warn(&quot;Failed to initialize filter condition {}. Filter does not implement IFilterCondition&quot;, getFilterName());</span>
                }
<span class="nc" id="L163">            } catch (Throwable t) {</span>
                // failed to initialize
<span class="nc" id="L165">                logger.error(&quot;Failed in initialize filter condition {} with argument {} and message {}&quot;, getFilterName(), filterConditionSpec,</span>
<span class="nc" id="L166">                        t.getMessage(), t);</span>
<span class="nc" id="L167">            }</span>

        }
<span class="fc" id="L170">    }</span>

    /**
     * Run custom configuration
     * 
     * @param config the filter specific configurator
     */
    protected void initializeOutputTypes(@Nullable final Configurator config) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (config != null) {</span>
<span class="fc" id="L179">            this.loadNameValidationPatterns(config);</span>
<span class="fc" id="L180">            this.outputTypes = config.findEntriesAsSet(&quot;OUTPUT_TYPE&quot;);</span>
<span class="fc" id="L181">            this.logger.debug(&quot;Loaded {} output types for filter {}&quot;, this.outputTypes.size(), this.outputTypes);</span>
<span class="fc" id="L182">            this.initializeDenylist(config);</span>
        } else {
<span class="nc" id="L184">            this.logger.debug(&quot;InitializeCustom has null filter config&quot;);</span>
        }
<span class="fc" id="L186">    }</span>

    protected void loadNameValidationPatterns(final Configurator config) {
<span class="fc" id="L189">        denylistAllowedNameChars = config.findStringEntry(&quot;DENYLIST_ALLOWED_NAME_CHARS&quot;, denylistAllowedNameChars);</span>
<span class="fc" id="L190">        denylistFiletypeFormat = config.findStringEntry(&quot;DENYLIST_FILETYPE_FORMAT&quot;, denylistFiletypeFormat);</span>
<span class="fc" id="L191">        denylistFiletypeFormatPattern = Pattern.compile(denylistFiletypeFormat.replace(&quot;%s&quot;, denylistAllowedNameChars));</span>
<span class="fc" id="L192">        denylistViewNameFormat = config.findStringEntry(&quot;DENYLIST_VIEW_NAME_FORMAT&quot;, denylistViewNameFormat);</span>
<span class="fc" id="L193">        denylistViewNameFormatPattern = Pattern.compile(denylistViewNameFormat.replace(&quot;%s&quot;, denylistAllowedNameChars));</span>
<span class="fc" id="L194">    }</span>

    protected void initializeDenylist(final Configurator config) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (String entry : config.findEntriesAsSet(&quot;DENYLIST&quot;)) {</span>
<span class="fc" id="L198">            String viewName = validateAndRemoveDenylistFiletype(entry);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (matchesDenylistViewNameFormatPattern(viewName)) {</span>
<span class="pc bpc" id="L200" title="2 of 4 branches missed.">                if (viewName.chars().filter(ch -&gt; ch == '.').count() &gt; 0) {</span>
<span class="nc" id="L201">                    logger.warn(&quot;`DENYLIST = \&quot;{}\&quot;` viewName `{}` should not contain any `.` characters&quot;, entry, viewName);</span>
                }

<span class="fc bfc" id="L204" title="All 2 branches covered.">                if (viewName.endsWith(&quot;*&quot;)) {</span>
<span class="fc" id="L205">                    String strippedEntry = entry.substring(0, entry.length() - 1);</span>
<span class="fc" id="L206">                    this.wildCardDenylist.add(strippedEntry);</span>
<span class="fc" id="L207">                } else {</span>
<span class="fc" id="L208">                    this.denylist.add(entry);</span>
                }

            } else {
<span class="fc" id="L212">                throw new EmissaryRuntimeException(String.format(</span>
                        &quot;Invalid filter configuration: `DENYLIST = \&quot;%s\&quot;` &quot; +
                                &quot;entry `%s` must match pattern `%s`.&quot;,
<span class="fc" id="L215">                        entry, entry, getDenylistViewNameFormat()));</span>
            }
<span class="fc" id="L217">        }</span>

<span class="fc" id="L219">        this.logger.debug(&quot;Loaded {} ignorelist types for filter {}&quot;, this.denylist.size(), this.denylist);</span>
<span class="fc" id="L220">        this.logger.debug(&quot;Loaded {} wildcard suffix ignorelist types for filter {}&quot;, this.wildCardDenylist.size(), this.wildCardDenylist);</span>
<span class="fc" id="L221">    }</span>

    protected String validateAndRemoveDenylistFiletype(final String entry) {
<span class="fc" id="L224">        String[] names = entry.split(&quot;\\.&quot;, 2);</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (names.length &gt; 1) {</span>
<span class="fc" id="L227">            String filetype = names[0];</span>
<span class="fc" id="L228">            String viewName = names[1];</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (filetype.equals(&quot;*&quot;)) { // DENYLIST = &quot;*.&lt;viewName&gt;&quot; not allowed</span>
<span class="fc" id="L231">                throw new EmissaryRuntimeException(String.format(</span>
                        &quot;Invalid filter configuration: `DENYLIST = \&quot;%s\&quot;` &quot; +
                                &quot;wildcarded filetypes not allowed in denylist - Did you mean `DENYLIST = \&quot;%s\&quot;`?&quot;,
                        entry, viewName));
<span class="fc bfc" id="L235" title="All 2 branches covered.">            } else if (!matchesDenylistFiletypeFormatPattern(filetype)) {</span>
<span class="fc" id="L236">                throw new EmissaryRuntimeException(String.format(</span>
                        &quot;Invalid filter configuration: `DENYLIST = \&quot;%s\&quot;` &quot; +
                                &quot;filetype `%s` must match pattern `%s`&quot;,
<span class="fc" id="L239">                        entry, filetype, getDenylistFiletypeFormat()));</span>
            }
<span class="fc" id="L241">            return viewName;</span>
        }
<span class="fc" id="L243">        return entry;</span>
    }

    /**
     * Return the name of this filter
     * 
     * @return the string name of the filter
     */
    @Override
    public String getFilterName() {
<span class="fc" id="L253">        return this.filterName;</span>
    }

    /**
     * Set the filter name
     * 
     * @param s the new name to use for this filter instance
     */
    @Override
    public void setFilterName(final String s) {
<span class="fc" id="L263">        this.filterName = s;</span>
<span class="fc" id="L264">    }</span>

    /**
     * Load the filter configuration with precendence of provided, named, default Preference order for loading
     * configurations
     * &lt;ol&gt;
     * &lt;li&gt;[filter-package].FILTER_NAME.cfg&lt;/li&gt;
     * &lt;li&gt;[filter-package].[filter-class]-FILTER_NAME.cfg&lt;/li&gt;
     * &lt;li&gt;[filter-package].[filter-class].cfg&lt;/li&gt;
     * &lt;/ol&gt;
     * 
     * @param suppliedFilterConfig configuration to use when not null
     */
    protected void loadFilterConfiguration(@Nullable final Configurator suppliedFilterConfig) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (suppliedFilterConfig != null) {</span>
<span class="fc" id="L279">            this.filterConfig = suppliedFilterConfig;</span>
<span class="fc" id="L280">            return;</span>
        }

<span class="fc" id="L283">        final List&lt;String&gt; configPreferences = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">        if (getFilterName() != null) {</span>
<span class="fc" id="L286">            configPreferences.add(this.getClass().getPackage().getName() + &quot;.&quot; + getFilterName() + ConfigUtil.CONFIG_FILE_ENDING);</span>
<span class="fc" id="L287">            configPreferences.add(this.getClass().getName() + &quot;-&quot; + getFilterName() + ConfigUtil.CONFIG_FILE_ENDING);</span>
        }
<span class="fc" id="L289">        configPreferences.add(this.getClass().getName() + ConfigUtil.CONFIG_FILE_ENDING);</span>

<span class="fc" id="L291">        this.logger.debug(&quot;Looking for filter configuration preferences {}&quot;, configPreferences);</span>
        try {
<span class="fc" id="L293">            this.filterConfig = ConfigUtil.getConfigInfo(configPreferences);</span>
<span class="nc" id="L294">        } catch (IOException iox) {</span>
<span class="nc" id="L295">            this.logger.debug(&quot;Could not find filter configuration for {}&quot;, getFilterName(), iox);</span>
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">    }</span>

    /**
     * Run the filter for a set of documents
     * 
     * @param list collection of IBaseDataObject to run the filter on
     * @param params map of params
     * @return status value
     */
    @Override
    public int filter(final List&lt;IBaseDataObject&gt; list, final Map&lt;String, Object&gt; params) {
        // Important to process them in order, if not already sorted

<span class="fc" id="L310">        int status = 0;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (final IBaseDataObject d : list) {</span>
<span class="fc" id="L312">            status = filter(d, params);</span>
<span class="fc" id="L313">        }</span>
<span class="fc" id="L314">        return status;</span>
    }

    /**
     * Run the filter for a set of documents
     * 
     * @param list collection of IBaseDataObject to run the filter on
     * @param params map of params
     * @param output the output stream
     * @return status value
     */
    @Override
    public int filter(final List&lt;IBaseDataObject&gt; list, final Map&lt;String, Object&gt; params, final OutputStream output) {

<span class="nc" id="L328">        int status = 0;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        for (final IBaseDataObject d : list) {</span>
<span class="nc" id="L330">            status = filter(d, params, output);</span>
<span class="nc" id="L331">        }</span>
<span class="nc" id="L332">        return status;</span>
    }

    /**
     * The method that all filter have to provide for stream based output
     */
    @Override
    public int filter(final IBaseDataObject payload, final Map&lt;String, Object&gt; params, final OutputStream output) {
<span class="nc" id="L340">        throw new IllegalArgumentException(&quot;Not supported, override to support&quot;);</span>
    }

    @Override
    public boolean isOutputtable(final IBaseDataObject d) {
<span class="nc bnc" id="L345" title="All 4 branches missed.">        return filterCondition == null || filterCondition.accept(d);</span>
    }

    @Override
    public boolean isOutputtable(final List&lt;IBaseDataObject&gt; list) {
<span class="pc bpc" id="L350" title="3 of 4 branches missed.">        return filterCondition == null || filterCondition.accept(list);</span>
    }

    /**
     * Determine if the payload is outputtable by the filter
     * 
     * @param d the document
     * @param params map of params
     * @return true if the filter wants a crack at outputting this payload
     */
    @Override
    public boolean isOutputtable(final IBaseDataObject d, final Map&lt;String, Object&gt; params) {
<span class="fc" id="L362">        return true;</span>
    }

    /**
     * Determine if the payload list is outputtable by the filter
     * 
     * @param list collection of IBaseDataObject to check for outputtability
     * @param params map of params
     * @return true if the filter wants a crack at outputting this payload
     */
    @Override
    public boolean isOutputtable(final List&lt;IBaseDataObject&gt; list, final Map&lt;String, Object&gt; params) {
<span class="fc" id="L374">        return true;</span>
    }

    /**
     * Determine is this payload should be output by this filter Usually by the primary view or one of the alternate views
     * being on the outputTypes list from the run-time type configuration stream for the filter in questin.
     *
     * @param type of the data
     */
    protected boolean isOutputtable(final String type) {
<span class="fc bfc" id="L384" title="All 4 branches covered.">        return this.outputTypes.contains(&quot;*&quot;) || this.outputTypes.contains(type);</span>
    }

    /**
     * Determine is this payload should be output by this filter Usually by the primary view or one of the alternate views
     * being on the outputTypes list from the run-time type configuration stream for the filter in question.
     *
     * @param types types to check
     * @return true if any one of the types is outputtable
     */
    protected boolean isOutputtable(final Collection&lt;String&gt; types) {
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (this.outputTypes.contains(&quot;*&quot;)) {</span>
<span class="fc" id="L396">            this.logger.debug(&quot;Outputtable due to wildcard in output types&quot;);</span>
<span class="fc" id="L397">            return true;</span>
        }

<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        final boolean canOutput = !Collections.disjoint(this.outputTypes, types);</span>
<span class="pc bpc" id="L401" title="2 of 4 branches missed.">        if (canOutput &amp;&amp; this.logger.isDebugEnabled()) {</span>
<span class="nc" id="L402">            final Set&lt;String&gt; outputFor = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            for (final String s : this.outputTypes) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                if (types.contains(s)) {</span>
<span class="nc" id="L405">                    outputFor.add(s);</span>
                }
<span class="nc" id="L407">            }</span>
<span class="nc" id="L408">            this.logger.debug(&quot;Outputtable due to non-disjoint sets: {}&quot;, outputFor);</span>
        }
<span class="fc" id="L410">        return canOutput;</span>
    }

    /**
     * Close the filter
     */
    @Override
    public void close() {
        // nothing to do
<span class="fc" id="L419">    }</span>

    /*
     * Extract my Output Spec from the supplied config info and save it
     */
    protected void loadOutputSpec(final Configurator theConfigG) {
<span class="fc" id="L425">        this.outputSpec = theConfigG.findStringEntry(&quot;OUTPUT_SPEC_&quot; + getFilterName(), null);</span>
<span class="fc" id="L426">        this.errorSpec = theConfigG.findStringEntry(&quot;ERROR_SPEC_&quot; + getFilterName(), null);</span>
<span class="fc" id="L427">        this.logger.debug(&quot;Output spec for {} is {}&quot;, getFilterName(), this.outputSpec);</span>
<span class="fc" id="L428">    }</span>

    /**
     * Get bytes as UTF-8 converted from specified charset
     * 
     * @param value the contents
     * @param charset the charset of the bytes in value
     */
    protected String normalizeBytes(final byte[] value, final String charset) {
<span class="nc" id="L437">        return normalizeBytes(value, 0, value.length, charset);</span>
    }

    /**
     * Get bytes as UTF-8 converted from specified charset
     * 
     * @param value the contents
     * @param start position to start subarray
     * @param len length of subarray
     * @param charset the charset of the bytes in value
     */
    protected String normalizeBytes(final byte[] value, final int start, final int len, @Nullable final String charset) {
<span class="nc" id="L449">        String s = null;</span>

<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (charset != null) {</span>
            try {
<span class="nc" id="L453">                s = new String(value, start, len, charset);</span>
<span class="nc" id="L454">            } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L455">                this.logger.debug(&quot;Error encoding string&quot;, ex);</span>
<span class="nc" id="L456">            }</span>
        }

<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (s == null) {</span>
            // from exception or no charset
<span class="nc" id="L461">            s = new String(value, start, len);</span>
        }

<span class="nc" id="L464">        return s;</span>
    }

    /**
     * Extract the charset from the payload or defaultCharset
     * 
     * @param d the payload
     * @param defaultCharset the default
     * @return the charset or defualtCharset if none
     */
    protected String getCharset(final IBaseDataObject d, final String defaultCharset) {
<span class="fc" id="L475">        String lang = d.getFontEncoding();</span>
<span class="pc bpc" id="L476" title="5 of 6 branches missed.">        if (lang == null || lang.toUpperCase(Locale.getDefault()).contains(&quot;ASCII&quot;) || lang.toUpperCase(Locale.getDefault()).contains(&quot;8859-1&quot;)) {</span>
<span class="fc" id="L477">            final String s = d.getStringParameter(&quot;HTML_CHARSET&quot;);</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">            if (s != null) {</span>
<span class="nc" id="L479">                lang = s;</span>
            }
        }
<span class="pc bpc" id="L482" title="5 of 6 branches missed.">        if (lang == null || lang.toUpperCase(Locale.getDefault()).contains(&quot;ASCII&quot;) || lang.toUpperCase(Locale.getDefault()).contains(&quot;8859-1&quot;)) {</span>
<span class="fc" id="L483">            final String s = d.getStringParameter(&quot;MIME_CHARSET&quot;);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (s != null) {</span>
<span class="nc" id="L485">                lang = s;</span>
            }
        }
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (lang == null) {</span>
<span class="fc" id="L489">            return defaultCharset;</span>
        } else {
<span class="nc" id="L491">            return JavaCharSet.get(lang);</span>
        }
    }

    /**
     * Makes a set of the file type, current form with and without the .PrimaryView qualifier and all the alternate view
     * names Result set can be passed to {@link #isOutputtable(Collection)} for checking
     *
     * @param d the payload
     */
    protected Set&lt;String&gt; getTypesToCheck(final IBaseDataObject d) {
<span class="fc" id="L502">        final Set&lt;String&gt; checkTypes = getPrimaryTypesToCheck(d);</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        for (final String viewName : d.getAlternateViewNames()) {</span>
<span class="fc" id="L504">            checkTypes.addAll(getTypesToCheckForNamedView(d, viewName));</span>
<span class="fc" id="L505">        }</span>
<span class="fc" id="L506">        checkTypes.addAll(getTypesToCheckForNamedView(d, METADATA_VIEW_NAME));</span>
<span class="fc" id="L507">        checkTypes.add(ALL_ALT_VIEWS);</span>
<span class="fc" id="L508">        return checkTypes;</span>
    }

    protected Set&lt;String&gt; getTypesToCheckForNamedView(final IBaseDataObject d, final String viewName) {
<span class="fc" id="L512">        final Set&lt;String&gt; checkTypes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L513">        final String lang = this.dropOffUtil.getLanguage(d);</span>
<span class="fc" id="L514">        final String fileType = DropOffUtil.getFileType(d);</span>
<span class="fc" id="L515">        final String currentForm = d.currentForm();</span>

        // skip over denylisted alt views
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (denyListContains(fileType, viewName)) {</span>
<span class="fc" id="L519">            return checkTypes;</span>
        }

<span class="fc" id="L522">        checkTypes.add(fileType);</span>
<span class="fc" id="L523">        checkTypes.add(fileType + &quot;.&quot; + viewName);</span>
<span class="fc" id="L524">        checkTypes.add(&quot;*.&quot; + viewName);</span>

<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (!&quot;NONE&quot;.equals(lang)) {</span>
<span class="nc" id="L527">            checkTypes.add(lang);</span>
<span class="nc" id="L528">            checkTypes.add(lang + &quot;.&quot; + viewName);</span>
<span class="nc" id="L529">            checkTypes.add(lang + &quot;.&quot; + fileType);</span>
<span class="nc" id="L530">            checkTypes.add(lang + &quot;.&quot; + fileType + &quot;.&quot; + viewName);</span>
        }

<span class="pc bpc" id="L533" title="2 of 4 branches missed.">        if (currentForm != null &amp;&amp; !fileType.equals(currentForm)) {</span>
<span class="fc" id="L534">            checkTypes.add(currentForm);</span>
<span class="fc" id="L535">            checkTypes.add(currentForm + &quot;.&quot; + viewName);</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">            if (!&quot;NONE&quot;.equals(lang)) {</span>
<span class="nc" id="L537">                checkTypes.add(lang + &quot;.&quot; + currentForm);</span>
<span class="nc" id="L538">                checkTypes.add(lang + &quot;.&quot; + currentForm + &quot;.&quot; + viewName);</span>
            }
        }
<span class="fc" id="L541">        this.logger.debug(&quot;Types to be checked for named view {}: {}&quot;, viewName, checkTypes);</span>
<span class="fc" id="L542">        return checkTypes;</span>
    }

    protected boolean denyListContains(final String fileType, final String viewName) {
<span class="fc" id="L546">        String fullName = fileType + &quot;.&quot; + viewName;</span>
<span class="fc bfc" id="L547" title="All 4 branches covered.">        if (this.denylist.contains(viewName) || this.denylist.contains(fullName)) {</span>
<span class="fc" id="L548">            return true;</span>
        }
<span class="fc bfc" id="L550" title="All 4 branches covered.">        return this.wildCardDenylist.stream().anyMatch(i -&gt; viewName.startsWith(i) || fullName.startsWith(i));</span>
    }

    /**
     * Makes a set of the file type, current form with and without the .PrimaryView qualifier. Result set can be passed to
     * {@link #isOutputtable(Collection)} for checking whether the primary view should be output
     *
     * @param d the payload
     */
    protected Set&lt;String&gt; getPrimaryTypesToCheck(final IBaseDataObject d) {
<span class="fc" id="L560">        final Set&lt;String&gt; checkTypes = getTypesToCheckForNamedView(d, PRIMARY_VIEW_NAME);</span>
<span class="fc" id="L561">        final String lang = this.dropOffUtil.getLanguage(d);</span>
<span class="fc" id="L562">        checkTypes.add(lang + LANGUAGE_VIEW);</span>
<span class="fc" id="L563">        checkTypes.add(ALL_LANGUAGE_VIEWS);</span>
<span class="fc" id="L564">        checkTypes.add(ALL_PRIMARY_VIEWS);</span>
<span class="fc" id="L565">        return checkTypes;</span>
    }

    @Override
    public String getOutputSpec() {
<span class="fc" id="L570">        return this.outputSpec;</span>
    }

    @Override
    public String getErrorSpec() {
<span class="nc" id="L575">        return this.errorSpec;</span>
    }

    @Override
    public Collection&lt;String&gt; getOutputTypes() {
<span class="nc" id="L580">        return new HashSet&lt;&gt;(this.outputTypes);</span>
    }

    public boolean matchesDenylistFiletypeFormatPattern(String str) {
<span class="fc" id="L584">        return denylistFiletypeFormatPattern.matcher(str).matches();</span>
    }

    public String getDenylistFiletypeFormat() {
<span class="fc" id="L588">        return denylistFiletypeFormatPattern.pattern();</span>
    }

    public boolean matchesDenylistViewNameFormatPattern(String str) {
<span class="fc" id="L592">        return denylistViewNameFormatPattern.matcher(str).matches();</span>
    }

    public String getDenylistViewNameFormat() {
<span class="fc" id="L596">        return denylistViewNameFormatPattern.pattern();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>