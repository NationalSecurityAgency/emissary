<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KffFile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.kff</a> &gt; <span class="el_source">KffFile.java</span></div><h1>KffFile.java</h1><pre class="source lang-java linenums">package emissary.kff;

import jakarta.annotation.Nonnull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.EOFException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.util.concurrent.locks.ReentrantLock;

/**
 * &lt;p&gt;
 * KffFile provides access to the known file filter data. The NIST/NSRL data is a CSV file with other information. It
 * must be preprocessed in order for this class to access it. The input file for this class must consist of a sorted
 * list of known values, where a known value is the CRC32 appended to the SHA-1. This file must be a binary file, so
 * each record will be 24 bytes long (20-byte SHA + 4-byte CRC). The CRC should be big endian.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Implementation notes: The binary input file is too big to read into memory, so we implement a binary search on the
 * file itself. This is why the records must be sorted, and it will improve performance if only unique records are
 * generated as well. This class assumes JDK1.4+ and memory maps the file. For earlier versions of the JDK, we can seek
 * through the RandomAccessFile instead but performance isn't as good. The file cannot be larger than 2^31 (2 GB)
 * because that is the maximum length of the mapped ByteBuffer.
 * &lt;/p&gt;
 */
public class KffFile implements KffFilter {
<span class="fc" id="L29">    private static final Logger logger = LoggerFactory.getLogger(KffFile.class);</span>

    /** File containing SHA-1/CRC32 results of known files */
    protected RandomAccessFile knownFile;

    /** Byte buffer that is mapped to the above file */
    protected ByteBuffer mappedBuf;

    /** Initial value of high index for binary search */
    private final long bSearchInitHigh;

    public static final int DEFAULT_RECORD_LENGTH = 24;
    protected final int recordLength;

    /** String logical name for this filter */
<span class="fc" id="L44">    protected String filterName = &quot;UNKNOWN&quot;;</span>

<span class="fc" id="L46">    protected FilterType ftype = FilterType.UNKNOWN;</span>

<span class="fc" id="L48">    protected String myPreferredAlgorithm = &quot;SHA-1&quot;;</span>

<span class="fc" id="L50">    protected ReentrantLock reentrantLock = new ReentrantLock();</span>

    /**
     * Creates a new instance of KffFile
     *
     * @param filename Name of binary file containing sorted RECORD_LENGTH records that are the hash codes possibly
     *        concatenated with the CRC-32
     * @param filterName the name of this filter
     * @param ftype type of this filter
     * @throws IOException if thrown by file I/O
     */
    public KffFile(String filename, String filterName, FilterType ftype) throws IOException {
<span class="fc" id="L62">        this(filename, filterName, ftype, DEFAULT_RECORD_LENGTH);</span>
<span class="fc" id="L63">    }</span>


    /**
     * Creates a new instance of KffFile
     *
     * @param filename Name of binary file containing sorted RECORD_LENGTH records that are the hash codes possibly
     *        concatenated with the CRC-32
     * @param filterName the name of this filter
     * @param ftype type of this filter
     * @param recordLength fixed record length in file
     * @throws IOException if thrown by file I/O
     */
<span class="fc" id="L76">    public KffFile(String filename, String filterName, FilterType ftype, int recordLength) throws IOException {</span>
<span class="fc" id="L77">        this.ftype = ftype;</span>
<span class="fc" id="L78">        this.filterName = filterName;</span>
<span class="fc" id="L79">        this.recordLength = recordLength;</span>

        // Open file in read-only mode
<span class="fc" id="L82">        knownFile = new RandomAccessFile(filename, &quot;r&quot;);</span>

        // Initial high value for binary search is largest index
<span class="fc" id="L85">        bSearchInitHigh = (knownFile.length() / (long) recordLength) - 1;</span>

<span class="fc" id="L87">        logger.debug(&quot;KFF File {} has {} records&quot;, filename, bSearchInitHigh + 1);</span>
<span class="fc" id="L88">    }</span>

    /**
     * Return the filter name
     */
    @Override
    public String getName() {
<span class="fc" id="L95">        return filterName;</span>
    }


    /**
     * Return the filter type
     */
    @Override
    public FilterType getFilterType() {
<span class="fc" id="L104">        return ftype;</span>
    }

    /**
     * Set the filter type
     *
     * @param f the new type
     */
    public void setFilterType(FilterType f) {
<span class="fc" id="L113">        ftype = f;</span>
<span class="fc" id="L114">    }</span>

    /**
     * Set the preferred algorithm to match what is in the mmaped file
     *
     * @param alg the new algorithm to use
     */
    public void setPreferredAlgorithm(String alg) {
<span class="fc" id="L122">        myPreferredAlgorithm = alg;</span>
<span class="fc" id="L123">    }</span>

    /**
     * Return the algorigthm being used
     */
    public String getPreferredAlgorithm() {
<span class="fc" id="L129">        return myPreferredAlgorithm;</span>
    }

    /**
     * Performs a binary search on the file to see if a given HASH/CRC is in the list.
     *
     * @param hash Result of HASH calculation
     * @param crc Result of CRC calculation
     * @return true if the record is in the list, false if it isn't
     */
    private boolean binaryFileSearch(@Nonnull byte[] hash, long crc) {

        // Initialize indexes for binary search
<span class="fc" id="L142">        long low = 0;</span>
<span class="fc" id="L143">        long high = bSearchInitHigh;</span>

        /* Buffer to hold a record */
<span class="fc" id="L146">        byte[] rec = new byte[recordLength];</span>

<span class="fc" id="L148">        reentrantLock.lock();</span>
        try {
            // Search until the indexes cross
<span class="fc bfc" id="L151" title="All 2 branches covered.">            while (low &lt;= high) {</span>
                // Calculate the midpoint
<span class="fc" id="L153">                long mid = (low + high) &gt;&gt; 1;</span>

                // Multiply the index by the record length to get the buffer position and read the record
<span class="fc" id="L156">                knownFile.seek(recordLength * mid);</span>
<span class="fc" id="L157">                knownFile.readFully(rec);</span>

                // Compare the record with the target. Adjust the indexes accordingly.
<span class="fc" id="L160">                int c = compare(rec, hash, crc);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                if (c &lt; 0) {</span>
<span class="fc" id="L162">                    high = mid - 1;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                } else if (c &gt; 0) {</span>
<span class="fc" id="L164">                    low = mid + 1;</span>
                } else {
<span class="fc" id="L166">                    return true;</span>
                }
<span class="fc" id="L168">            }</span>
<span class="nc" id="L169">        } catch (EOFException e) {</span>
            // this shouldn't happen if we're synchronizing calls correctly
<span class="nc" id="L171">            logger.warn(&quot;EOFException reading KffFile: {}&quot;, e.getLocalizedMessage());</span>
<span class="nc" id="L172">        } catch (IOException e) {</span>
<span class="nc" id="L173">            logger.warn(&quot;Exception reading KffFile&quot;, e);</span>
        } finally {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (reentrantLock.isHeldByCurrentThread()) {</span>
<span class="fc" id="L176">                reentrantLock.unlock();</span>
            }
        }
        // not found
<span class="fc" id="L180">        return false;</span>
    }

    /**
     * Compares the given hash/crc to the one in the record.
     *
     * @param record bytes from the kff binary file, one record long
     * @param hash HASH to compare to record
     * @param crc CRC to compare to record
     * @return &amp;lt;0 if given value is less than record, &amp;gt;0 if given value is greater than record, 0 if they match
     */
    private static int compare(@Nonnull byte[] record, @Nonnull byte[] hash, long crc) {
        int i;

        // Compare the hashes first. We can't compare the bytes directly because a Java byte is signed and may generate the
        // wrong result. We must convert to integers and then mask off the sign bits to get proper results.
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (i = 0; i &lt; hash.length; i++) {</span>
<span class="fc" id="L197">            int ihash = hash[i] &amp; 0xff;</span>
<span class="fc" id="L198">            int irec = record[i] &amp; 0xff;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (ihash &lt; irec) {</span>
<span class="fc" id="L200">                return -1;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            } else if (ihash &gt; irec) {</span>
<span class="fc" id="L202">                return 1;</span>
            }
        }

        // If the hashes match, check the CRCs.
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (crc != -1L) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for (int j = 24; i &lt; record.length; i++, j -= 8) {</span>
<span class="fc" id="L209">                int icrc = ((int) crc &gt;&gt; j) &amp; 0xff;</span>
<span class="fc" id="L210">                int irec = record[i] &amp; 0xff;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                if (icrc &lt; irec) {</span>
<span class="nc" id="L212">                    return -1;</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                } else if (icrc &gt; irec) {</span>
<span class="nc" id="L214">                    return 1;</span>
                }
            }
        }
<span class="fc" id="L218">        return 0;</span>
    }

    @Override
    public boolean check(String fname, ChecksumResults csum) throws Exception {
<span class="fc" id="L223">        byte[] hash = csum.getHash(myPreferredAlgorithm);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (hash == null) {</span>
<span class="nc" id="L225">            logger.warn(&quot;Filter cannot be used, {} not computed on {}&quot;, myPreferredAlgorithm, fname);</span>
<span class="nc" id="L226">            return false;</span>
        }
<span class="fc" id="L228">        return binaryFileSearch(hash, csum.getCrc());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>