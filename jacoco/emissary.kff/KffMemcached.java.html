<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KffMemcached.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.kff</a> &gt; <span class="el_source">KffMemcached.java</span></div><h1>KffMemcached.java</h1><pre class="source lang-java linenums">package emissary.kff;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.util.Hexl;

import jakarta.annotation.Nullable;
import net.spy.memcached.ConnectionFactoryBuilder;
import net.spy.memcached.ConnectionFactoryBuilder.Protocol;
import net.spy.memcached.FailureMode;
import net.spy.memcached.MemcachedClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * KffMemcached checks Emissary hashes against a set of external memcached servers. If a given Emissary hash does not
 * hit in memcached, it is added to the memcached. The value stored is however the input is identified (notionally, some
 * type of id). Only one type of hash can be checked against memcached (i.e. SHA-1...not SHA-1 &lt;i&gt;and&lt;/i&gt; SHA-256). See
 * the PREF_ALG configuration option.
 *
 * If the option MEMCACHED_STORE_ID_DUPE is set to true, if an Emissary hash already exists in memcached, the id will
 * also be loaded into memcached as a &lt;i&gt;key&lt;/i&gt;. The purpose of this is for other follow-on processes (non-Emissary) to
 * query memcached and determine if a given id is a duplicate (i.e. if it is present).
 *
 * If a server goes down, this code will wait and try to reconnect with increasingly long intervals between retries.
 * Under this mode of operation, it is expected someone will bring the server back online.
 *
 * Configuration file options are:
 *
 * MEMCACHED_SERVER: one line for each server, optional : separated port MEMCACHED_AGEOFF: how long to hold an object in
 * memcached before expiring MEMCACHED_OP_TIMEOUT_MILLIS: how long to wait before timing out a memcached operation
 * MEMCACHED_IGNORE_VALUE_PATTERN: do not store values that contain this pattern (non-regexO MEMCACHED_FAILURE_MODE:
 * what to do in case of server failure MEMCACHED_STORE_ID_DUPE: boolean to store the id if it's hash is already
 * contained in memcached PREF_ALG: Which Emissary hash to use as the key stored in memcached
 */
public class KffMemcached implements KffFilter {

    /**
     * Logger
     */
    private final Logger logger;

    /**
     * The hash to use as the key
     */
<span class="fc" id="L54">    protected String preferredAlgorithm = &quot;SHA-1&quot;;</span>

    /**
     * String logical name for this filter
     */
<span class="fc" id="L59">    protected String filterName = &quot;UNKNOWN&quot;;</span>

    /**
     * Filter type
     */
<span class="fc" id="L64">    protected FilterType ftype = FilterType.UNKNOWN;</span>

    /**
     * The age-off in the memcached client
     */
<span class="fc" id="L69">    protected int ageoff = 86400;</span>

    /**
     * The timeout on any given network operation in milliseconds
     */
<span class="fc" id="L74">    protected long opTimeoutMillis = 2500L;</span>

    /**
     * What to do in case there is a failure contacting a given server
     */
<span class="fc" id="L79">    protected FailureMode failMode = FailureMode.Cancel;</span>

    /**
     * Do not store values that contain these substrings exactly (this is not treated as a regex)
     */
<span class="fc" id="L84">    @Nullable</span>
    protected Set&lt;String&gt; ignorePatterns = null;

    /**
     * If this is set to true, if an Emissary hash already exists in memcached, the id will also be loaded into memcached as
     * a &lt;i&gt;key&lt;/i&gt;. The purpose of this is for other follow-on processes (non-Emissary) to query memcached and determine if
     * a given id is a duplicate (i.e. if it is present).
     */
<span class="fc" id="L92">    protected boolean storeIdDupe = false;</span>

    /**
     * Whether or not to use the memcached binary protocol
     */
<span class="fc" id="L97">    protected boolean useBinaryProtocol = false;</span>

    /**
     * A handle to the set of servers
     */
    protected MemcachedClient client;

    /**
     *
     * @param filename Unused
     * @param filterName Name of the filter (typically sent in by KffChainLoader)
     * @param ftype Filter type (again, sent in by KffChainLoader)
     * @throws IOException is thrown if either the file cannot be read of memcached cannot be contacted
     */
    public KffMemcached(String filename, String filterName, FilterType ftype) throws IOException {
<span class="nc" id="L112">        this(filename, filterName, ftype, null);</span>

<span class="nc" id="L114">    }</span>

    /**
     *
     * @param testIdWithSpaces Unused
     * @param filterName Name of the filter (typically sent in by KffChainLoader)
     * @param duplicate Filter type (again, sent in by KffChainLoader)
     * @param testClient Memcached client to be used if specified (will instantiate a client if null)
     * @throws IOException is thrown if either the file cannot be read of memcached cannot be contacted
     */
<span class="fc" id="L124">    public KffMemcached(String testIdWithSpaces, String filterName, FilterType duplicate, @Nullable MemcachedClient testClient) throws IOException {</span>
        // Set logger to run time class
<span class="fc" id="L126">        logger = LoggerFactory.getLogger(this.getClass().getName());</span>
        // Set the logger impl to use log4j
<span class="fc" id="L128">        System.setProperty(&quot;net.spy.log.LoggerImpl&quot;, &quot;net.spy.memcached.compat.log.Log4JLogger&quot;);</span>

        // testIdWithSpaces is not used
<span class="fc" id="L131">        this.ftype = duplicate;</span>
<span class="fc" id="L132">        this.filterName = filterName;</span>

<span class="fc" id="L134">        Configurator configG = ConfigUtil.getConfigInfo(KffMemcached.class);</span>

        // Load up the list of servers
<span class="fc" id="L137">        Set&lt;String&gt; serversFromConfig = configG.findEntriesAsSet(&quot;MEMCACHED_SERVER&quot;);</span>
<span class="fc" id="L138">        List&lt;InetSocketAddress&gt; servers = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (String serverFromConfig : serversFromConfig) {</span>
            // Transform to an InetSocketAddress
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            if (serverFromConfig.contains(&quot;:&quot;)) {</span>
<span class="nc" id="L142">                String[] serverTokens = serverFromConfig.split(&quot;:&quot;);</span>
<span class="nc" id="L143">                String host = serverTokens[0];</span>
<span class="nc" id="L144">                int port = Integer.parseInt(serverTokens[1]);</span>
<span class="nc" id="L145">                servers.add(new InetSocketAddress(host, port));</span>
<span class="nc" id="L146">            } else {</span>
                // In this case, assume port is 11211
<span class="fc" id="L148">                servers.add(new InetSocketAddress(serverFromConfig, 11211));</span>
            }
<span class="fc" id="L150">        }</span>

<span class="fc" id="L152">        logger.debug(&quot;The following memcached servers are configured:&quot;);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        for (InetSocketAddress server : servers) {</span>
<span class="fc" id="L154">            logger.debug(&quot;Server configured: {}&quot;, server);</span>
<span class="fc" id="L155">        }</span>

        // Default to 24 hours timeout
<span class="fc" id="L158">        ageoff = configG.findIntEntry(&quot;MEMCACHED_AGEOFF&quot;, 86400);</span>

        // Set the preferred algorithm
<span class="fc" id="L161">        preferredAlgorithm = configG.findStringEntry(&quot;PREF_ALG&quot;);</span>

        // Set the preferred algorithm
<span class="fc" id="L164">        ignorePatterns = configG.findEntriesAsSet(&quot;MEMCACHED_IGNORE_VALUE_PATTERN&quot;);</span>

        // Whether or not to keep track of dupe IDs in memcached
<span class="fc" id="L167">        storeIdDupe = configG.findBooleanEntry(&quot;MEMCACHED_STORE_ID_DUPE&quot;, false);</span>

        // Set whether to use the binary protocol or not
<span class="fc" id="L170">        useBinaryProtocol = configG.findBooleanEntry(&quot;MEMCACHED_USE_BINARY_PROTOCOL&quot;, useBinaryProtocol);</span>

        // Set the operation timeout
<span class="fc" id="L173">        opTimeoutMillis = configG.findLongEntry(&quot;MEMCACHED_OP_TIMEOUT_MILLIS&quot;, opTimeoutMillis);</span>

<span class="fc" id="L175">        String failModeAsString = configG.findStringEntry(&quot;MEMCACHED_FAILURE_MODE&quot;, &quot;Cancel&quot;);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (failModeAsString.equalsIgnoreCase(&quot;cancel&quot;)) {</span>
<span class="fc" id="L177">            failMode = FailureMode.Cancel;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        } else if (failModeAsString.equalsIgnoreCase(&quot;retry&quot;)) {</span>
<span class="nc" id="L179">            failMode = FailureMode.Retry;</span>
        }

        // Finally, setup the client. ConnectionFactoryBuilder ultimately
        // creates a DefaultConnectionFactory with the values set below
<span class="fc" id="L184">        ConnectionFactoryBuilder cfb = new ConnectionFactoryBuilder();</span>
<span class="fc" id="L185">        cfb.setDaemon(true); // Just to keep the process from hanging</span>
<span class="fc" id="L186">        cfb.setFailureMode(failMode); // How to handle operations when they fail</span>
<span class="fc" id="L187">        cfb.setMaxReconnectDelay(60); // At most, wait 1 minute for attempting to reconnect to a server</span>
<span class="fc" id="L188">        cfb.setOpTimeout(opTimeoutMillis); // Use the same for the connection as the concurrent Future object</span>

<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (useBinaryProtocol) {</span>
<span class="nc" id="L191">            cfb.setProtocol(Protocol.BINARY);</span>
        }

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (testClient == null) {</span>
<span class="nc" id="L195">            client = new MemcachedClient(cfb.build(), servers);</span>
        } else {
<span class="fc" id="L197">            client = testClient;</span>
        }

        // logger.debug(client.toString());
<span class="fc" id="L201">    }</span>

    /**
     * Contact the memcached server and lookup the hash. If it is found, then return true. If it is not found, store it and
     * return false. If it matches a special ignore pattern, return false. If the server is down or any other problems throw
     * an exception
     */
    @Override
    public boolean check(String id, ChecksumResults sums) throws Exception {

<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (sums == null) {</span>
<span class="nc" id="L212">            throw new Exception(&quot;Poorly formed input to check() in sums&quot;);</span>
        }

<span class="pc bpc" id="L215" title="2 of 4 branches missed.">        if ((id == null) || (id.length() == 0)) {</span>
<span class="nc" id="L216">            throw new Exception(&quot;Poorly formed input to check() in fname&quot;);</span>
        }

        // Ignore any IDs that contain the ignorePatterns string verbatim
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (ignorePatterns != null) {</span>
            // Loop through all patterns to see if any match
<span class="fc bfc" id="L222" title="All 2 branches covered.">            for (String ignorePattern : ignorePatterns) {</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                if (id.contains(ignorePattern)) {</span>
<span class="nc" id="L224">                    return false;</span>
                }
<span class="fc" id="L226">            }</span>
        }

<span class="fc" id="L229">        byte[] hash = sums.getHash(preferredAlgorithm);</span>

<span class="pc bpc" id="L231" title="2 of 4 branches missed.">        if ((hash == null) || (hash.length == 0)) {</span>
<span class="nc" id="L232">            throw new Exception(&quot;Poorly formed input to check() in hash&quot;);</span>
        }

<span class="fc" id="L235">        String key = Hexl.toUnformattedHexString(hash);</span>

        // Send the query
<span class="fc" id="L238">        Future&lt;Object&gt; future = client.asyncGet(key);</span>


        // Let the TimeoutException propagate up
<span class="fc" id="L242">        Object result = future.get(opTimeoutMillis, TimeUnit.MILLISECONDS);</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (result != null) {</span>
<span class="pc bpc" id="L245" title="1 of 4 branches missed.">            if (storeIdDupe &amp;&amp; !result.equals(id)) {</span>
                // As long as the id is not the same as what was already stored, then
                // store it on its own
<span class="fc" id="L248">                var unused = client.set(id, ageoff, key);</span>
                // logger.debug(&quot;Storing duplicate Id: {} with value (hash) {}&quot;, id, key);
            }
            // logger.debug(&quot;Found key: {} with value {}&quot;, key, (String) result);
            // Found the key
<span class="fc" id="L253">            return true;</span>
        }
        // logger.debug(&quot;Did not find key: {}&quot;, key);
        // Did not find the key...store it and move on
<span class="fc" id="L257">        var unused = client.set(key, ageoff, id);</span>
<span class="fc" id="L258">        return false;</span>


    }

    public String getPreferredAlgorithm() {
<span class="fc" id="L264">        return preferredAlgorithm;</span>
    }

    public void setPreferredAlgorithm(String preferredAlgorithm) {
<span class="fc" id="L268">        this.preferredAlgorithm = preferredAlgorithm;</span>
<span class="fc" id="L269">    }</span>

    @Override
    public String getName() {
<span class="fc" id="L273">        return filterName;</span>
    }

    @Override
    public FilterType getFilterType() {
<span class="fc" id="L278">        return ftype;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>