<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BufferedChannelFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.core.channels</a> &gt; <span class="el_source">BufferedChannelFactory.java</span></div><h1>BufferedChannelFactory.java</h1><pre class="source lang-java linenums">package emissary.core.channels;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.Validate;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;

/**
 * Creates a SeekableByteChannel cache of a defined size analogous to BufferedInputStream.
 */
public final class BufferedChannelFactory {
    private BufferedChannelFactory() {}

    /**
     * Creates a SeekableByteChannelFactory that caches the bytes of the passed in SeekableByteChannelFactory.
     * 
     * @param seekableByteChannelFactory to be cached.
     * @param maxBufferSize maximum size of the buffer of bytes (BufferSize = Math.min(sbcf.size(), maxBufferSize)).
     * @return the caching SeekableByteChannelFactory.
     */
    public static SeekableByteChannelFactory create(final SeekableByteChannelFactory seekableByteChannelFactory,
            final int maxBufferSize) {
<span class="fc" id="L25">        return new BufferedChannelFactoryImpl(seekableByteChannelFactory, maxBufferSize);</span>
    }

    /**
     * A SeekableByteChannelFactory that caches the bytes of the passed in SeekableByteChannelFactory.
     */
    private static class BufferedChannelFactoryImpl implements SeekableByteChannelFactory {
        /**
         * The SeekableByteChannel to cache.
         */
        private final SeekableByteChannelFactory seekableByteChannelFactory;
        /**
         * The size of the buffer of bytes.
         */
        private final int bufferSize;

        /**
         * Creates a SeekableByteChannelFactory that caches the bytes of the passed in SeekableByteChannelFactory.
         * 
         * @param seekableByteChannelFactory to be cached.
         * @param maxBufferSize of the buffer of bytes.
         */
        public BufferedChannelFactoryImpl(final SeekableByteChannelFactory seekableByteChannelFactory,
<span class="fc" id="L48">                final int maxBufferSize) {</span>
<span class="fc" id="L49">            Validate.notNull(seekableByteChannelFactory, &quot;Required: seekableByteChannelFactory not null!&quot;);</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">            Validate.isTrue(maxBufferSize &gt; 0, &quot;Required: maxBufferSize &gt; 0&quot;);</span>

<span class="fc" id="L52">            this.seekableByteChannelFactory = seekableByteChannelFactory;</span>

<span class="fc" id="L54">            int b = maxBufferSize;</span>
<span class="fc" id="L55">            try (SeekableByteChannel sbc = seekableByteChannelFactory.create()) {</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">                if (sbc.size() &lt; maxBufferSize) {</span>
<span class="fc" id="L57">                    b = (int) sbc.size();</span>
                }
<span class="nc" id="L59">            } catch (IOException ignored) {</span>
                // Leave b as maxBufferSize.
<span class="fc" id="L61">            }</span>

<span class="fc" id="L63">            this.bufferSize = b;</span>
<span class="fc" id="L64">        }</span>

        @Override
        public SeekableByteChannel create() {
<span class="fc" id="L68">            return new BufferedSeekableByteChannel(seekableByteChannelFactory.create(), bufferSize);</span>
        }
    }

    /**
     * SeekableByteChannel that caches the bytes of the passed in SeekableByteChannel
     */
    private static class BufferedSeekableByteChannel extends AbstractSeekableByteChannel {
        /**
         * The SeekableByteChannel to cache.
         */
        private final SeekableByteChannel seekableByteChannel;
        /**
         * The size of the buffer of bytes.
         */
        private final int bufferSize;
        /**
         * The buffer of bytes.
         */
        private final ByteBuffer buffer;

        /**
         * The starting offset of the current buffer.
         */
<span class="fc" id="L92">        private long bufferStart = -1;</span>
        /**
         * The number of valid bytes in the current buffer.
         */
<span class="fc" id="L96">        private int bufferValidBytes = -1;</span>

        /**
         * Creates a SeekableByteChannel cache where there is a single buffer of bytes aligned on bufferSize boundaries.
         * 
         * @param seekableByteChannel to be cached.
         * @param bufferSize of the buffer of bytes.
         */
<span class="fc" id="L104">        public BufferedSeekableByteChannel(final SeekableByteChannel seekableByteChannel, final int bufferSize) {</span>
<span class="fc" id="L105">            this.seekableByteChannel = seekableByteChannel;</span>
<span class="fc" id="L106">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L107">            this.buffer = ByteBuffer.allocate(bufferSize);</span>
<span class="fc" id="L108">        }</span>

        @Override
        protected void closeImpl() throws IOException {
<span class="fc" id="L112">            seekableByteChannel.close();</span>
<span class="fc" id="L113">        }</span>

        @Override
        protected int readImpl(final ByteBuffer byteBuffer) throws IOException {
            // Determines the start of the buffer that contains the current position.
<span class="fc" id="L118">            final long bufferStartFromPosition = position() / bufferSize * bufferSize;</span>

<span class="fc bfc" id="L120" title="All 2 branches covered.">            if (bufferStartFromPosition != bufferStart) {</span>
<span class="fc" id="L121">                buffer.position(0);</span>
<span class="fc" id="L122">                seekableByteChannel.position(bufferStartFromPosition);</span>

<span class="fc" id="L124">                bufferValidBytes = IOUtils.read(seekableByteChannel, buffer);</span>
<span class="fc" id="L125">                bufferStart = bufferStartFromPosition;</span>
            }

<span class="fc" id="L128">            final int bufferStartOffset = (int) (position() % bufferSize);</span>
<span class="fc" id="L129">            final int bytesToReturn = Math.min(byteBuffer.remaining(), bufferValidBytes - bufferStartOffset);</span>

<span class="fc" id="L131">            byteBuffer.put(buffer.array(), bufferStartOffset, bytesToReturn);</span>

<span class="fc" id="L133">            return bytesToReturn;</span>
        }

        @Override
        protected long sizeImpl() throws IOException {
<span class="fc" id="L138">            return seekableByteChannel.size();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>