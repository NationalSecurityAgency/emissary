<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RollableFileOutputStream.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util.roll</a> &gt; <span class="el_source">RollableFileOutputStream.java</span></div><h1>RollableFileOutputStream.java</h1><pre class="source lang-java linenums">package emissary.util.roll;

import emissary.roll.Rollable;
import emissary.util.io.FileNameGenerator;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Closeable;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Allows for use within the Emissary Rolling framework. Keeps track of bytes written and is thread safe.
 */
public class RollableFileOutputStream extends OutputStream implements Rollable {
<span class="fc" id="L25">    private static final Logger LOG = LoggerFactory.getLogger(RollableFileOutputStream.class);</span>
    /** Locks for protecting writes to underlying stream */
<span class="fc" id="L27">    final ReentrantLock lock = new ReentrantLock();</span>
    /** Flag to let callers know if this class is currently rolling */
    volatile boolean rolling;
    /** Current output stream we're writing to */
    @Nullable
    FileOutputStream fileOutputStream;
    /** Current File we're writing to */
    @Nullable
    File currentFile;
    /** File Name Generator for creating unique file names */
    FileNameGenerator namegen;
    /** Directory we're writing to */
    private final File dir;
    /** Number of bytes written to file */
    long bytesWritten;
    /** Whether to delete a zero byte file */
<span class="fc" id="L43">    boolean deleteZeroByteFiles = true;</span>
    /**
     * internal sequencer in case FileNameGenerator does not obey contract. Present for defense only
     */
<span class="fc" id="L47">    private final AtomicLong seq = new AtomicLong();</span>

<span class="fc" id="L49">    public RollableFileOutputStream(FileNameGenerator namegen, File dir) throws IOException {</span>
<span class="pc bpc" id="L50" title="3 of 6 branches missed.">        if (dir == null || !dir.exists() || !dir.isDirectory()) {</span>
<span class="nc" id="L51">            throw new IllegalArgumentException(&quot;Directory is invalid: &quot; + dir);</span>
        }
<span class="fc" id="L53">        this.namegen = namegen;</span>
<span class="fc" id="L54">        this.dir = dir;</span>
<span class="fc" id="L55">        handleOrphanedFiles();</span>
<span class="fc" id="L56">        open();</span>
<span class="fc" id="L57">    }</span>

    public RollableFileOutputStream(FileNameGenerator namegen) throws IOException {
<span class="nc" id="L60">        this(namegen, new File(&quot;.&quot;));</span>
<span class="nc" id="L61">    }</span>

    private void handleOrphanedFiles() {
        // Create FilenameFilter
<span class="fc" id="L65">        FilenameFilter filter = (directory, name) -&gt; name.startsWith(&quot;.&quot;);</span>

        // Look for any dot files in directory
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (File file : this.dir.listFiles(filter)) {</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">            if (file.isFile()) {</span>
<span class="fc" id="L70">                LOG.info(&quot;Renaming orphaned file, {}, to non-dot file.&quot;, file.getName());</span>
<span class="fc" id="L71">                rename(file);</span>
            }
        }
<span class="fc" id="L74">    }</span>

    private void open() throws IOException {
<span class="fc" id="L77">        File newFile = getNewFile();</span>
<span class="fc" id="L78">        currentFile = newFile;</span>
<span class="fc" id="L79">        fileOutputStream = new FileOutputStream(newFile, true);</span>
<span class="fc" id="L80">    }</span>

    private File getNewFile() {
<span class="fc" id="L83">        String newName = namegen.nextFileName();</span>
<span class="fc" id="L84">        String dotFile = &quot;.&quot; + newName;</span>
<span class="fc" id="L85">        String seqFname = &quot;.&quot; + seq.get() + &quot;_&quot; + newName;</span>
<span class="pc bpc" id="L86" title="2 of 6 branches missed.">        if (currentFile != null &amp;&amp; (dotFile.equals(currentFile.getName()) || seqFname.equals(currentFile.getName()))) {</span>
<span class="nc" id="L87">            LOG.warn(&quot;Duplicate file name returned from {}. Using internal sequencer to uniquify.&quot;, namegen.getClass());</span>
<span class="nc" id="L88">            dotFile = &quot;.&quot; + seq.getAndIncrement() + &quot;_&quot; + newName;</span>
        }
<span class="fc" id="L90">        return new File(dir, dotFile);</span>
    }

    private void closeAndRename() throws IOException {
<span class="fc" id="L94">        fileOutputStream.flush();</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (!internalClose(fileOutputStream)) {</span>
<span class="nc" id="L96">            LOG.error(&quot;Error closing file {}&quot;, currentFile.getAbsolutePath());</span>
        }
<span class="fc" id="L98">        rename(currentFile);</span>
<span class="fc" id="L99">        bytesWritten = 0L;</span>
<span class="fc" id="L100">    }</span>

    private void rename(File f) {
<span class="pc bpc" id="L103" title="1 of 4 branches missed.">        if (f.length() == 0L &amp;&amp; deleteZeroByteFiles) {</span>
            try {
<span class="fc" id="L105">                LOG.debug(&quot;Deleting Zero Byte File {}&quot;, f.getAbsolutePath());</span>
<span class="fc" id="L106">                Files.delete(f.toPath());</span>
<span class="nc" id="L107">            } catch (IOException e) {</span>
<span class="nc" id="L108">                LOG.error(&quot;Failed to delete zero byte file {}&quot;, f.getAbsolutePath(), e);</span>
<span class="fc" id="L109">            }</span>
<span class="fc" id="L110">            return;</span>
        }
        // drop the dot...
<span class="fc" id="L113">        String nonDot = f.getName().substring(1);</span>
<span class="fc" id="L114">        File nd = new File(dir, nonDot);</span>
        // This shouldn't happen
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (nd.exists()) {</span>
<span class="nc" id="L117">            LOG.error(&quot;Non dot file {} already exists. Forcing unique name.&quot;, nd.getAbsolutePath());</span>
<span class="nc" id="L118">            nd = new File(dir, nonDot + UUID.randomUUID());</span>
        }
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (!f.renameTo(nd)) {</span>
<span class="nc" id="L121">            LOG.error(&quot;Rename from {} to {} failed.&quot;, f.getAbsolutePath(), nd.getAbsolutePath());</span>
        }
<span class="fc" id="L123">    }</span>

    /**
     * Rolls current file. Exact workflow is closing of the underlying output, renaming the file to it's final name, and
     * opening a new file.
     */
    @Override
    public void roll() {
<span class="fc" id="L131">        lock.lock();</span>
        try {
<span class="fc" id="L133">            rolling = true;</span>
<span class="fc" id="L134">            closeAndRename();</span>

<span class="fc" id="L136">            open();</span>
<span class="nc" id="L137">        } catch (IOException e) {</span>
<span class="nc" id="L138">            LOG.error(&quot;Exception during roll of &quot; + currentFile, e);</span>
        } finally {
<span class="fc" id="L140">            rolling = false;</span>
<span class="fc" id="L141">            lock.unlock();</span>
        }
<span class="fc" id="L143">    }</span>

    /**
     * True is this object is in the middle of a roll.
     * 
     * @return true if rolling
     */
    @Override
    public boolean isRolling() {
<span class="nc" id="L152">        return rolling;</span>
    }

    private static boolean internalClose(@Nullable Closeable c) {
        try {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">            if (c != null) {</span>
<span class="fc" id="L158">                c.close();</span>
            }
<span class="nc" id="L160">        } catch (Exception e) {</span>
<span class="nc" id="L161">            LOG.warn(&quot;Error occurred while closing file&quot;, e);</span>
<span class="nc" id="L162">            return false;</span>
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">        return true;</span>
    }

    /**
     * Closes the underlying outputs and renames the current file to its final name. A new file is NOT opened. Further use
     * of the instance of this class is not guaranteed to function after calling this method.
     */
    @Override
    public void close() throws IOException {
<span class="fc" id="L173">        lock.lock();</span>
        try {
<span class="fc" id="L175">            closeAndRename();</span>
<span class="fc" id="L176">            fileOutputStream = null;</span>
<span class="fc" id="L177">            currentFile = null;</span>
        } finally {
<span class="fc" id="L179">            lock.unlock();</span>
        }
<span class="fc" id="L181">    }</span>

    /**
     * Thread safe write of a byte
     * 
     * @param b byte to write
     */
    @Override
    public void write(int b) throws IOException {
<span class="fc" id="L190">        lock.lock();</span>
        try {
<span class="fc" id="L192">            fileOutputStream.write(b);</span>
<span class="fc" id="L193">            bytesWritten++;</span>
        } finally {
<span class="fc" id="L195">            lock.unlock();</span>
        }

<span class="fc" id="L198">    }</span>

    /**
     * Thread safe write of byte array.
     * 
     * @param b the data
     * @param off the start offset of the data
     * @param len the number of bytes to write
     */
    @Override
    public void write(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L209">        lock.lock();</span>
        try {
<span class="fc" id="L211">            fileOutputStream.write(b, off, len);</span>
<span class="fc" id="L212">            bytesWritten += len;</span>
        } finally {
<span class="fc" id="L214">            lock.unlock();</span>
        }
<span class="fc" id="L216">    }</span>

    /**
     * Number of bytes written to current output file. This value is reset once roll() is called.
     * 
     * @return the number of bytes written
     */
    public long getBytesWritten() {
<span class="nc" id="L224">        return bytesWritten;</span>
    }

    /**
     * Whether zero byte files will be deleted.
     * 
     * @return true is zero byte files will be deleted
     */
    public boolean isDeleteZeroByteFiles() {
<span class="nc" id="L233">        return deleteZeroByteFiles;</span>
    }

    /**
     * Determines whether to delete zero byte files on a roll. If true, both bytes written and the size of the output file
     * are checked. If both are zero, and deleteZeroByteFiles is true, the file is deleted.
     */
    public void setDeleteZeroByteFiles(boolean deleteZeroByteFiles) {
<span class="fc" id="L241">        this.deleteZeroByteFiles = deleteZeroByteFiles;</span>
<span class="fc" id="L242">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>