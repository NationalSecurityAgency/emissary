<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteTokenizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util.search</a> &gt; <span class="el_source">ByteTokenizer.java</span></div><h1>ByteTokenizer.java</h1><pre class="source lang-java linenums">package emissary.util.search;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * The byte tokenizer class allows an application to break a byte buffer into tokens. This was modified from the
 * java.util.StringTokenizer implementation. Note that all characters in the delimiter set are considered to be
 * characters in the range 0 - 255. In other words the ISO8859-1 encoding is used to match the delimiters to the byte
 * array.
 */
public class ByteTokenizer implements Iterator&lt;String&gt; {
    private int currentPosition;
    private int newPosition;
    private final int maxPosition;
    private final byte[] data;
    private String delimiters;
    private final boolean retDelims;
    private boolean delimsChanged;
    private String encoding;

<span class="fc" id="L27">    private static final Logger logger = LoggerFactory.getLogger(ByteTokenizer.class);</span>

    /**
     * maxDelimChar stores the value of the delimiter character with the highest value. It is used to optimize the detection
     * of delimiter characters.
     */
    private char maxDelimChar;

    /**
     * Set maxDelimChar to the highest char in the delimiter set.
     */
    private void setMaxDelimChar() {
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">        if (delimiters == null) {</span>
<span class="nc" id="L40">            maxDelimChar = 0;</span>
<span class="nc" id="L41">            return;</span>
        }

<span class="fc" id="L44">        char m = 0;</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">        for (int i = 0; i &lt; delimiters.length(); i++) {</span>
<span class="fc" id="L46">            char c = delimiters.charAt(i);</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">            if (m &lt; c) {</span>
<span class="fc" id="L48">                m = c;</span>
            }
        }
<span class="fc" id="L51">        maxDelimChar = m;</span>
<span class="fc" id="L52">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array. All characters in the &lt;code&gt;delim&lt;/code&gt; argument are the
     * delimiters for separating tokens. Characters must be in the range of 0 - 255.
     * &lt;p&gt;
     * If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as
     * tokens. Each delimiter is returned as a byte[] or String of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the
     * delimiter characters are skipped and only serve as separators between tokens.
     *
     * @param bytes a byte array to be parsed.
     * @param start the first byte in the array
     * @param len the number of bytes to parse
     * @param delim the delimiters.
     * @param returnDelims flag indicating whether to return the delimiters as tokens.
     */
<span class="fc" id="L68">    public ByteTokenizer(byte[] bytes, int start, int len, String delim, boolean returnDelims) {</span>
<span class="fc" id="L69">        currentPosition = start;</span>
<span class="fc" id="L70">        newPosition = -1;</span>
<span class="fc" id="L71">        delimsChanged = false;</span>
<span class="fc" id="L72">        data = bytes;</span>
<span class="fc" id="L73">        maxPosition = start + len;</span>
<span class="fc" id="L74">        delimiters = delim;</span>
<span class="fc" id="L75">        retDelims = returnDelims;</span>
<span class="fc" id="L76">        setMaxDelimChar();</span>
<span class="fc" id="L77">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array using the specified encoding.
     *
     * @param bytes a byte array to be parsed.
     * @param start the first byte in the array
     * @param len the number of bytes to parse
     * @param delim the delimiters.
     * @param returnDelims flag indicating whether to return the delimiters as tokens.
     * @param encoding the encoding for which to return the bytes.
     * @exception UnsupportedEncodingException thrown if the supplied encoding is unsupported.
     */
    public ByteTokenizer(byte[] bytes, int start, int len, String delim, boolean returnDelims, String encoding) throws UnsupportedEncodingException {
<span class="fc" id="L91">        this(bytes, start, len, delim, returnDelims);</span>
        try {
<span class="fc" id="L93">            Charset c = Charset.forName(encoding);</span>
<span class="fc" id="L94">            logger.debug(&quot;Loaded charset {}&quot;, c);</span>
<span class="fc" id="L95">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L96">            throw new UnsupportedEncodingException(ex.toString());</span>
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">        this.encoding = encoding;</span>
<span class="fc" id="L99">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array. The characters in the &lt;code&gt;delim&lt;/code&gt; argument are the
     * delimiters for separating tokens. Delimiter characters themselves will not be treated as tokens.
     *
     * @param bytes a byte array to be parsed.
     * @param start the first byte in the array
     * @param len the number of bytes to parse
     * @param delim the delimiters.
     */
    public ByteTokenizer(byte[] bytes, int start, int len, String delim) {
<span class="nc" id="L111">        this(bytes, start, len, delim, false);</span>
<span class="nc" id="L112">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array using the specified encoding.
     *
     * @param bytes a byte array to be parsed.
     * @param start the first byte in the array
     * @param len the number of bytes to parse
     * @param delim the delimiters.
     * @param encoding the encoding for which to return the bytes.
     * @exception UnsupportedEncodingException thrown if the supplied encoding is unsupported.
     */
    public ByteTokenizer(byte[] bytes, int start, int len, String delim, String encoding) throws UnsupportedEncodingException {
<span class="fc" id="L125">        this(bytes, start, len, delim, false, encoding);</span>
<span class="fc" id="L126">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array. The tokenizer uses the default delimiter set, which is
     * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character, the tab character, the newline character, the
     * carriage-return character, and the form-feed character. Delimiter characters themselves will not be treated as
     * tokens.
     *
     * @param bytes a byte array to be parsed.
     * @param start the first byte in the array
     * @param len the number of bytes to parse
     */
    public ByteTokenizer(byte[] bytes, int start, int len) {
<span class="nc" id="L139">        this(bytes, start, len, &quot; \t\n\r\f&quot;, false);</span>
<span class="nc" id="L140">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array. All characters in the &lt;code&gt;delim&lt;/code&gt; argument are the
     * delimiters for separating tokens. Characters must be in the range of 0 - 255.
     * &lt;p&gt;
     * If the &lt;code&gt;returnDelims&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then the delimiter characters are also returned as
     * tokens. Each delimiter is returned as a byte[] or String of length one. If the flag is &lt;code&gt;false&lt;/code&gt;, the
     * delimiter characters are skipped and only serve as separators between tokens.
     *
     * @param bytes a byte array to be parsed.
     * @param delim the delimiters.
     * @param returnDelims flag indicating whether to return the delimiters as tokens.
     */
    public ByteTokenizer(byte[] bytes, String delim, boolean returnDelims) {
<span class="nc" id="L155">        this(bytes, 0, bytes.length, delim, returnDelims);</span>
<span class="nc" id="L156">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array using the specified encoding.
     *
     * @param bytes a byte array to be parsed.
     * @param delim the delimiters.
     * @param returnDelims flag indicating whether to return the delimiters as tokens.
     * @param encoding the encoding for which to return the bytes.
     * @exception UnsupportedEncodingException thrown if the supplied encoding is unsupported.
     */
    public ByteTokenizer(byte[] bytes, String delim, boolean returnDelims, String encoding) throws UnsupportedEncodingException {
<span class="nc" id="L168">        this(bytes, 0, bytes.length, delim, returnDelims, encoding);</span>
<span class="nc" id="L169">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array. The characters in the &lt;code&gt;delim&lt;/code&gt; argument are the
     * delimiters for separating tokens. Delimiter characters themselves will not be treated as tokens.
     *
     * @param bytes a byte array to be parsed.
     * @param delim the delimiters.
     */
    public ByteTokenizer(byte[] bytes, String delim) {
<span class="nc" id="L179">        this(bytes, 0, bytes.length, delim);</span>
<span class="nc" id="L180">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array using the specified encoding.
     *
     * @param bytes a byte array to be parsed.
     * @param delim the delimiters.
     * @param encoding the encoding for which to return the bytes.
     * @exception UnsupportedEncodingException thrown if the supplied encoding is unsupported.
     */
    public ByteTokenizer(byte[] bytes, String delim, String encoding) throws UnsupportedEncodingException {
<span class="nc" id="L191">        this(bytes, 0, bytes.length, delim, encoding);</span>
<span class="nc" id="L192">    }</span>

    /**
     * Constructs a byte tokenizer for the specified byte array. The tokenizer uses the default delimiter set, which is
     * &lt;code&gt;&quot;&amp;nbsp;&amp;#92;t&amp;#92;n&amp;#92;r&amp;#92;f&quot;&lt;/code&gt;: the space character, the tab character, the newline character, the
     * carriage-return character, and the form-feed character. Delimiter characters themselves will not be treated as
     * tokens.
     *
     * @param bytes a byte array to be parsed.
     */
    public ByteTokenizer(byte[] bytes) {
<span class="nc" id="L203">        this(bytes, 0, bytes.length);</span>
<span class="nc" id="L204">    }</span>

    /**
     * Skips delimiters starting from the specified position. If retDelims is false, returns the index of the first
     * non-delimiter character at or after startPos. If retDelims is true, startPos is returned.
     */
    private int skipDelimiters(int startPos) {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (delimiters == null) {</span>
<span class="nc" id="L212">            throw new NullPointerException();</span>
        }

<span class="fc" id="L215">        int position = startPos;</span>
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">        while (!retDelims &amp;&amp; position &lt; maxPosition) {</span>
<span class="fc" id="L217">            char c = (char) (0xFF &amp; data[position]);</span>
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">            if ((c &gt; maxDelimChar) || (delimiters.indexOf(c) &lt; 0)) {</span>
<span class="nc" id="L219">                break;</span>
            }
<span class="fc" id="L221">            position++;</span>
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">        return position;</span>
    }

    /**
     * Skips ahead from startPos and returns the index of the next delimiter character encountered, or maxPosition if no
     * such delimiter is found.
     */
    private int scanToken(int startPos) {
<span class="fc" id="L231">        int position = startPos;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        while (position &lt; maxPosition) {</span>
<span class="fc" id="L233">            char c = (char) (0xFF &amp; data[position]);</span>
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">            if ((c &lt;= maxDelimChar) &amp;&amp; (delimiters.indexOf(c) &gt;= 0)) {</span>
<span class="fc" id="L235">                break;</span>
            }
<span class="fc" id="L237">            position++;</span>
<span class="fc" id="L238">        }</span>
<span class="pc bpc" id="L239" title="3 of 4 branches missed.">        if (retDelims &amp;&amp; (startPos == position)) {</span>
<span class="nc" id="L240">            char c = (char) (0xFF &amp; data[position]);</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">            if ((c &lt;= maxDelimChar) &amp;&amp; (delimiters.indexOf(c) &gt;= 0)) {</span>
<span class="nc" id="L242">                position++;</span>
            }
        }
<span class="fc" id="L245">        return position;</span>
    }

    /**
     * Tests if there are more tokens available from this tokenizer's string. If this method returns &lt;code&gt;true&lt;/code&gt;, then
     * a subsequent call to &lt;code&gt;next&lt;/code&gt; with no argument will successfully return a token.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if and only if there is at least one token in the string after the current position;
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    @Override
    public boolean hasNext() {
        /*
         * Temporary store this position and use it in the following next() method only if the delimiters haven't been changed
         * in that next() invocation.
         */
<span class="nc" id="L261">        newPosition = skipDelimiters(currentPosition);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        return newPosition &lt; maxPosition;</span>
    }

    /**
     * Returns the next token from this string tokenizer.
     *
     * @return the next token from this string tokenizer.
     * @exception NoSuchElementException if there are no more tokens in this tokenizer's string.
     */
    @Override
    public String next() {
        /*
         * If next position already computed in hasMoreElements() and delimiters have changed between the computation and this
         * invocation, then use the computed value.
         */

<span class="nc bnc" id="L278" title="All 4 branches missed.">        currentPosition = (newPosition &gt;= 0 &amp;&amp; !delimsChanged) ? newPosition : skipDelimiters(currentPosition);</span>

        /* Reset these anyway */
<span class="nc" id="L281">        delimsChanged = false;</span>
<span class="nc" id="L282">        newPosition = -1;</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (currentPosition &gt;= maxPosition) {</span>
<span class="nc" id="L285">            throw new NoSuchElementException();</span>
        }
<span class="nc" id="L287">        int start = currentPosition;</span>
<span class="nc" id="L288">        currentPosition = scanToken(currentPosition);</span>

<span class="nc" id="L290">        String token = null;</span>
        try {
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (encoding != null) {</span>
<span class="nc" id="L293">                token = new String(data, start, currentPosition - start, encoding);</span>
            } else {
<span class="nc" id="L295">                token = new String(data, start, currentPosition - start);</span>
            }
<span class="nc" id="L297">        } catch (UnsupportedEncodingException ignored) {</span>
            // cannot happen...we already verified in constructor
<span class="nc" id="L299">        }</span>
<span class="nc" id="L300">        return token;</span>
    }

    /**
     * Returns the next token in this string tokenizer's string. First, the set of characters considered to be delimiters by
     * this &lt;code&gt;ByteTokenizer&lt;/code&gt; object is changed to be the characters in the string &lt;code&gt;delim&lt;/code&gt;. Then the
     * next token in the string after the current position is returned. The current position is advanced beyond the
     * recognized token. The new delimiter set remains the default after this call.
     *
     * @param delim the new delimiters.
     * @return the next token, after switching to the new delimiter set.
     * @exception NoSuchElementException if there are no more tokens in this tokenizer's string.
     */
    public String next(String delim) {
<span class="nc" id="L314">        delimiters = delim;</span>

        /* delimiter string specified, so set the appropriate flag. */
<span class="nc" id="L317">        delimsChanged = true;</span>

<span class="nc" id="L319">        setMaxDelimChar();</span>
<span class="nc" id="L320">        return next();</span>
    }

    /**
     * Calculates the number of times that this tokenizer's &lt;code&gt;next&lt;/code&gt; method can be called before it generates an
     * exception. The current position is not advanced.
     *
     * @return the number of tokens remaining in the string using the current delimiter set.
     * @see ByteTokenizer#next()
     */
    public int countTokens() {
<span class="fc" id="L331">        int count = 0;</span>
<span class="fc" id="L332">        int currpos = currentPosition;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        while (currpos &lt; maxPosition) {</span>
<span class="fc" id="L334">            currpos = skipDelimiters(currpos);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (currpos &gt;= maxPosition) {</span>
<span class="nc" id="L336">                break;</span>
            }
<span class="fc" id="L338">            currpos = scanToken(currpos);</span>
<span class="fc" id="L339">            count++;</span>
        }
<span class="fc" id="L341">        return count;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>