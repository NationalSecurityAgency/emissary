<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JournaledChannelPool.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.output.roller.journal</a> &gt; <span class="el_source">JournaledChannelPool.java</span></div><h1>JournaledChannelPool.java</h1><pre class="source lang-java linenums">package emissary.output.roller.journal;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.UUID;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Pool implementation that utilizes a Journal to durably track state out written data. The implementation will create
 * up to the maximum configured output channels. Channels are lazily initialized to minimize resource utilization. The
 * Journal is only updated when files are created and committed.
 */
public class JournaledChannelPool implements AutoCloseable {
    public static final String EXTENSION = &quot;.bgpart&quot;;
<span class="fc" id="L24">    private static final Logger LOG = LoggerFactory.getLogger(JournaledChannelPool.class);</span>
    public static final int DEFAULT_MAX = 10;
<span class="fc" id="L26">    private final ReentrantLock lock = new ReentrantLock();</span>
<span class="fc" id="L27">    private final Condition freeCondition = this.lock.newCondition();</span>
    final int max;
    final Path directory;
    final String key;
<span class="fc" id="L31">    private final Deque&lt;JournaledChannel&gt; free = new ArrayDeque&lt;&gt;();</span>
    private int created;
    @Nullable
    private JournaledChannel[] allchannels;

    @SuppressWarnings(&quot;CheckedExceptionNotThrown&quot;)
<span class="fc" id="L37">    public JournaledChannelPool(final Path directory, final String key, final int max) throws IOException {</span>
<span class="fc" id="L38">        this.max = max;</span>
<span class="fc" id="L39">        this.directory = directory;</span>
<span class="fc" id="L40">        this.key = key;</span>
<span class="fc" id="L41">        this.allchannels = new JournaledChannel[max];</span>
<span class="fc" id="L42">    }</span>

    int getFreeSize() {
<span class="fc" id="L45">        return this.free.size();</span>
    }

    int getCreatedCount() {
<span class="fc" id="L49">        return this.created;</span>
    }

    /**
     * Supplied key to identify the pool.
     * 
     * @return key
     */
    public String getKey() {
<span class="fc" id="L58">        return this.key;</span>
    }

    /**
     * Returns an available output from the pool. This method will block if there are no free objects available and the max
     * number of outputs has been created.
     * 
     * @return an available KeyedOutput from the pool
     * @throws IOException If there is some I/O problem.
     * @throws InterruptedException If interrupted.
     */
    public KeyedOutput getFree() throws InterruptedException, IOException {
<span class="fc" id="L70">        JournaledChannel jc = null;</span>
<span class="fc" id="L71">        this.lock.lock();</span>
        try {
<span class="fc" id="L73">            checkClosed();</span>
<span class="fc" id="L74">            jc = findFree();</span>
<span class="fc" id="L75">            jc.setPosition();</span>
<span class="fc" id="L76">            return new KeyedOutput(this, jc);</span>
<span class="nc" id="L77">        } catch (Throwable t) {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (jc != null) {</span>
<span class="nc" id="L79">                LOG.debug(&quot;Throwable occurred while obtaining channel. Returning to the pool. {}&quot;, jc.path, t);</span>
<span class="nc" id="L80">                free(jc);</span>
            }
<span class="nc" id="L82">            throw t;</span>
        } finally {
<span class="fc" id="L84">            this.lock.unlock();</span>
        }
    }

    /**
     * Flushes underlying channel and writes journal entry, updating current position.
     * 
     * @param jc the JournaledChannel to flush
     */
    void free(final JournaledChannel jc) {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (jc == null) {</span>
<span class="nc" id="L95">            throw new IllegalArgumentException(&quot;Cannot return a null JournaledChannel.&quot;);</span>
        }
<span class="fc" id="L97">        this.lock.lock();</span>
        try {
<span class="pc bpc" id="L99" title="2 of 4 branches missed.">            if (this.free.contains(jc) || !this.free.offer(jc)) {</span>
<span class="nc" id="L100">                LOG.warn(&quot;Could not return the channel to the pool {}&quot;, this.key);</span>
            }
            // signal everyone since close and find may be waiting
<span class="fc" id="L103">            this.freeCondition.signalAll();</span>
        } finally {
<span class="fc" id="L105">            this.lock.unlock();</span>
        }
<span class="fc" id="L107">    }</span>

    /**
     * Closes the underlying pool. This method will block if any resources have not been returned.
     * 
     * @throws InterruptedException If interrupted.
     * @throws IOException If there is some I/O problem.
     */
    @Override
    public void close() throws InterruptedException, IOException {
<span class="fc" id="L117">        this.lock.lock();</span>
        try {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">            while (this.free.size() &lt; this.created) {</span>
<span class="nc" id="L120">                LOG.debug(&quot;Waiting for leased {} objects.&quot;, this.created - this.free.size());</span>
<span class="nc" id="L121">                this.freeCondition.await();</span>
            }
<span class="fc bfc" id="L123" title="All 2 branches covered.">            for (final JournaledChannel fc : this.free) {</span>
<span class="fc" id="L124">                this.allchannels[fc.index].close();</span>
<span class="fc" id="L125">            }</span>
<span class="fc" id="L126">            this.allchannels = null;</span>
        } finally {
<span class="fc" id="L128">            this.lock.unlock();</span>
        }
<span class="fc" id="L130">    }</span>

    private void checkClosed() throws ClosedChannelException {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (this.allchannels == null) {</span>
<span class="nc" id="L134">            throw new ClosedChannelException();</span>
        }
<span class="fc" id="L136">    }</span>

    private JournaledChannel findFree() throws InterruptedException, IOException {
        // if nothing is available, and we can create additional channels, do it
        // could get closed when we await
<span class="fc bfc" id="L141" title="All 2 branches covered.">        while (this.free.isEmpty()) {</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if (this.created &lt; this.max) {</span>
<span class="fc" id="L143">                createChannel();</span>
            } else {
<span class="nc" id="L145">                this.freeCondition.await();</span>
<span class="nc" id="L146">                checkClosed();</span>
            }
        }
<span class="fc" id="L149">        return this.free.poll();</span>
    }

    private void createChannel() throws IOException {
<span class="fc" id="L153">        final Path p = Paths.get(this.directory.toString(), this.key + &quot;_&quot; + UUID.randomUUID().toString() + EXTENSION);</span>
<span class="fc" id="L154">        final JournaledChannel ko = new JournaledChannel(p, this.key, this.created);</span>
<span class="fc" id="L155">        this.allchannels[this.created++] = ko;</span>
<span class="fc" id="L156">        this.free.add(ko);</span>
<span class="fc" id="L157">    }</span>

    Path getDirectory() {
<span class="fc" id="L160">        return this.directory;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>