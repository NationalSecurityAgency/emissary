<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyManipulator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.directory</a> &gt; <span class="el_source">KeyManipulator.java</span></div><h1>KeyManipulator.java</h1><pre class="source lang-java linenums">package emissary.directory;

import emissary.place.IServiceProviderPlace;

import jakarta.annotation.Nullable;

import java.io.Serializable;

/**
 * A class of utility methods for manipulating dictionary keys. Keys are stored in the dictionary with the following
 * format:
 *
 * &lt;code&gt;dataType.serviceName.serviceType.location$expense&lt;/code&gt;
 * 
 * Example: UNKNOWN.servicename.ID.tcp://host.dom.com:8001/FilePlace$5050
 * 
 * &lt;table&gt;
 * &lt;caption&gt;For the example key above the return values are as follows:&lt;/caption&gt;
 * &lt;tr&gt;
 * &lt;td&gt;routine&lt;/td&gt;
 * &lt;td&gt;return value&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;dataType&lt;/td&gt;
 * &lt;td&gt;UNKOWN&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;serviceName&lt;/td&gt;
 * &lt;td&gt;servicename&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;serviceType&lt;/td&gt;
 * &lt;td&gt;ID&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;serviceHost&lt;/td&gt;
 * &lt;td&gt;host.dom.com:8001&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;serviceHostURL&lt;/td&gt;
 * &lt;td&gt;http://host.dom.com:8001/&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;serviceLocation&lt;/td&gt;
 * &lt;td&gt;http://host.dom.com:8001/FilePlace&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;expense&lt;/td&gt;
 * &lt;td&gt;5050&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;serviceClassname&lt;/td&gt;
 * &lt;td&gt;FilePlace&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;dataID&lt;/td&gt;
 * &lt;td&gt;UNKOWN::ID&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr&gt;
 * &lt;td&gt;defaultDirectoryKey&lt;/td&gt;
 * &lt;td&gt;*.*.*.http://host.dom.com:8001/DirectoryPlace&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/table&gt;
 *
 */
public class KeyManipulator implements Serializable {

    // Serializable
    static final long serialVersionUID = 2456659383313218695L;

    /**
     * How we separate portions of the key
     */
    public static final char SEPARATOR = '.';
    public static final char HOSTSEPARATOR = ':';
    public static final char CLASSSEPARATOR = '/';
    public static final String DOLLAR = &quot;$&quot;;
    public static final String DATAIDSEPARATOR = &quot;::&quot;;
    public static final String WILDCARD_THREE = &quot;*.*.*.&quot;;

    /**
     * How many portions (separated by SEPARATOR) are in a complete key
     */
    public static final int NUMTUPLES = 4;

    private static final String doubleSlash = &quot;//&quot;;

    /**
     * Make a key from parts
     *
     * @param dataType the first part of the key
     * @param serviceName the second part of the key
     * @param serviceType the third part of the key
     * @param serviceLocation the fourth part of the key
     */
    public static String makeKey(final String dataType, final String serviceName, final String serviceType, final String serviceLocation) {
<span class="fc" id="L97">        return dataType + SEPARATOR + serviceName + SEPARATOR + serviceType + SEPARATOR + serviceLocation;</span>
    }

    /**
     * Return the data type field from a dictionary formatted key.
     */
    public static String getDataType(final String key) {
<span class="fc" id="L104">        final int firstSeparator = key.indexOf(SEPARATOR);</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (firstSeparator &gt;= 0) {</span>
<span class="fc" id="L107">            return key.substring(0, firstSeparator);</span>
        }
<span class="fc" id="L109">        return &quot;&quot;;</span>
    }

    public static String getDataId(final String key) {
<span class="fc" id="L113">        return getDataType(key) + DATAIDSEPARATOR + getServiceType(key);</span>
    }

    public static String getServiceTypeFromDataId(final String dataid) {
<span class="fc" id="L117">        final int pos = dataid.indexOf(DATAIDSEPARATOR);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (pos &gt; -1) {</span>
<span class="fc" id="L119">            return dataid.substring(pos + DATAIDSEPARATOR.length());</span>
        }
<span class="fc" id="L121">        return &quot;&quot;;</span>
    }

    /**
     * Performs wildcard (? | *) string matching for dictionary key searches.
     */
    public static boolean gmatch(final String s, final String p) {
<span class="fc" id="L128">        return gmatch2(s.toCharArray(), p.toCharArray(), 0, 0);</span>
    }

    /**
     * Performs wildcard (? | *) character array matching for dictionary key searches.
     */
    public static boolean gmatch(final char[] s, final char[] p) {
<span class="fc" id="L135">        return gmatch2(s, p, 0, 0);</span>
    }

    private static boolean gmatch2(final char[] s, final char[] p, final int spos, final int ppos) {
        // fastest interpreted version
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (p.length == ppos) {</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            return s.length == spos;</span>
        }
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (s.length == spos) {</span>
<span class="fc" id="L144">            return false;</span>
        }
<span class="fc" id="L146">        final char scc = s[spos];</span>
<span class="fc" id="L147">        final char c = p[ppos];</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (c == '?') {</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (scc &gt; 0) {</span>
<span class="fc" id="L150">                return gmatch2(s, p, spos + 1, ppos + 1);</span>
            }
<span class="nc" id="L152">            return false;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        } else if (c == '*') {</span>
<span class="fc" id="L154">            final int ppos2 = ppos + 1;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (p.length == ppos2) {</span>
<span class="fc" id="L156">                return true;</span>
            }
<span class="fc" id="L158">            int spos2 = spos;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            while (s.length &gt; ++spos2) {</span>
<span class="fc bfc" id="L160" title="All 4 branches covered.">                if (p[ppos2] == s[spos2] &amp;&amp; gmatch2(s, p, spos2, ppos2)) {</span>
<span class="fc" id="L161">                    return true;</span>
                }
            }
<span class="fc" id="L164">            return false;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        } else if (c == scc) {</span>
<span class="fc" id="L166">            return gmatch2(s, p, spos + 1, ppos + 1);</span>
        } else {
<span class="fc" id="L168">            return false;</span>
        }
    }

    /**
     * Return whether the key passed in is complete or not This is useful in determining if the key must be wildcarded for a
     * query.
     *
     * @param key the key to check
     */
    public static boolean isKeyComplete(final String key) {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (numTuplesInKey(key) &lt; KeyManipulator.NUMTUPLES) {</span>
<span class="fc" id="L180">            return false;</span>
        }
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (getServiceHost(key).length() == 0) {</span>
<span class="fc" id="L183">            return false;</span>
        }
<span class="fc" id="L185">        return true;</span>
    }

    /**
     * Return the number of tuples in the Key passed in
     */
    public static int numTuplesInKey(final String key) {
<span class="fc" id="L192">        int count = 0;</span>
<span class="fc" id="L193">        final byte[] keyBytes = key.getBytes();</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (int i = 0; i &lt; keyBytes.length; i++) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (keyBytes[i] == KeyManipulator.SEPARATOR) {</span>
<span class="fc" id="L197">                count++;</span>
            }
            // Dont count separators in the hostname portion
<span class="fc bfc" id="L200" title="All 6 branches covered.">            if ((i &gt; 0) &amp;&amp; (keyBytes[i] == CLASSSEPARATOR) &amp;&amp; (keyBytes[i - 1] == CLASSSEPARATOR)) {</span>
<span class="fc" id="L201">                break;</span>
            }
        }

        // There is one more tuple than separators x.x.x.x
<span class="fc" id="L206">        return count + 1;</span>
    }

    /**
     * Attempt to set out some rules for a key to allow validation
     *
     * @param key the putative key
     * @return true if key is valid
     */
    public static boolean isValid(@Nullable final String key) {
<span class="pc bpc" id="L216" title="1 of 4 branches missed.">        return (key != null) &amp;&amp; (numTuplesInKey(key) == 4);</span>
    }

    /**
     * Returns the class name from a dictionary formatted key
     */
    public static String getServiceClassname(final String key) {
<span class="fc" id="L223">        final String location = getServiceLocation(key);</span>
<span class="fc" id="L224">        final int sep = location.lastIndexOf(CLASSSEPARATOR);</span>

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (sep &gt;= 0) {</span>
<span class="fc" id="L227">            return location.substring(sep + 1);</span>
        }
<span class="nc" id="L229">        return &quot;&quot;;</span>
    }

    /**
     * Returns the hostname:port from a dictionary formatted key
     */
    public static String getServiceHost(final String key) {
<span class="fc" id="L236">        final String location = getServiceLocation(key);</span>
<span class="fc" id="L237">        final int ds = location.indexOf(doubleSlash);</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (ds &gt; -1) {</span>
<span class="fc" id="L240">            final int cs = location.indexOf(CLASSSEPARATOR, ds + 2);</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (cs &gt; -1) {</span>
<span class="fc" id="L243">                return location.substring(ds + 2, cs);</span>
            }
<span class="fc" id="L245">            return &quot;&quot;;</span>
        }
<span class="fc" id="L247">        return &quot;&quot;;</span>
    }

    /**
     * Returns the protocol://hostname:port/ from a dictionary formatted key
     */
    public static String getServiceHostUrl(final String key) {
<span class="fc" id="L254">        final String location = getServiceLocation(key);</span>
<span class="fc" id="L255">        final int ds = location.lastIndexOf(CLASSSEPARATOR);</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (ds &gt; -1) {</span>
<span class="fc" id="L258">            return location.substring(0, ds + 1);</span>
        }
<span class="fc" id="L260">        return &quot;&quot;;</span>
    }

    /**
     * Returns true if k1 and k2 are local to each other
     *
     * @param k1 key for first place
     * @param k2 key for second place
     * @return true if local to each other
     */
    public static boolean isLocalTo(final String k1, final String k2) {
<span class="fc" id="L271">        return getServiceHostUrl(k1).equals(getServiceHostUrl(k2));</span>
    }

    /**
     * Returns the service location (host:port/className) field from a dictionary formatted key.
     */
    public static String getServiceLocation(final String key) {
<span class="fc" id="L278">        final int firstSeparator = key.indexOf(SEPARATOR);</span>
<span class="fc" id="L279">        final int secondSeparator = key.indexOf(SEPARATOR, firstSeparator + 1);</span>
<span class="fc" id="L280">        final int thirdSeparator = key.indexOf(SEPARATOR, secondSeparator + 1);</span>
<span class="fc" id="L281">        final int fourthSeparator = key.indexOf(DOLLAR, thirdSeparator + 1);</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (thirdSeparator &gt;= 0) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (fourthSeparator &gt; 0) {</span>
<span class="fc" id="L285">                return key.substring(thirdSeparator + 1, fourthSeparator);</span>
            }
<span class="fc" id="L287">            return key.substring(thirdSeparator + 1);</span>
        }
<span class="fc" id="L289">        return &quot;&quot;;</span>
    }

    /**
     * Return the expense of the service
     */
    public static int getExpense(final String key) {
<span class="fc" id="L296">        return getExpense(key, -1);</span>
    }

    public static int getExpense(final String key, final int dflt) {
<span class="fc" id="L300">        final int pos = key.lastIndexOf(DOLLAR);</span>
<span class="fc" id="L301">        int expense = dflt;</span>
        try {
<span class="fc" id="L303">            expense = Integer.parseInt(key.substring(pos + 1));</span>
<span class="fc" id="L304">        } catch (NumberFormatException ignored) {</span>
            // It's optional...
<span class="fc" id="L306">        }</span>
<span class="fc" id="L307">        return expense;</span>
    }

    /**
     * Add expense record onto a key
     */
    public static String addExpense(final String key, final int expense) {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (getExpense(key, -99) == expense) {</span>
<span class="fc" id="L315">            return key;</span>
        }

<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (key.indexOf(DOLLAR) &gt; -1) {</span>
<span class="fc" id="L319">            return key.substring(0, key.lastIndexOf(DOLLAR) + 1) + expense;</span>
        }

<span class="fc" id="L322">        return key + DOLLAR + expense;</span>
    }

    /**
     * Strip the expense from a key if present
     *
     * @param key any key
     * @return the modified key
     */
    public static String removeExpense(final String key) {
<span class="fc" id="L332">        final int pos = key.indexOf(DOLLAR);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (pos != -1) {</span>
<span class="fc" id="L334">            return key.substring(0, pos);</span>
        }
<span class="fc" id="L336">        return key;</span>
    }

    /**
     * Returns the service name field from a dictionary formatted key.
     */
    public static String getServiceName(final String key) {
<span class="fc" id="L343">        final int firstSeparator = key.indexOf(SEPARATOR);</span>
<span class="fc" id="L344">        final int secondSeparator = key.indexOf(SEPARATOR, firstSeparator + 1);</span>

<span class="pc bpc" id="L346" title="1 of 4 branches missed.">        if ((firstSeparator &gt;= 0) &amp;&amp; (secondSeparator &gt;= 0)) {</span>
<span class="fc" id="L347">            return key.substring(firstSeparator + 1, secondSeparator);</span>
        }
<span class="fc" id="L349">        return &quot;&quot;;</span>
    }

    /**
     * Returns the service type field from a dictionary formatted key.
     */
    public static String getServiceType(final String key) {
<span class="fc" id="L356">        final int firstSeparator = key.indexOf(SEPARATOR);</span>
<span class="fc" id="L357">        final int secondSeparator = key.indexOf(SEPARATOR, firstSeparator + 1);</span>
<span class="fc" id="L358">        final int thirdSeparator = key.indexOf(SEPARATOR, secondSeparator + 1);</span>

<span class="pc bpc" id="L360" title="1 of 4 branches missed.">        if ((secondSeparator &gt;= 0) &amp;&amp; (thirdSeparator &gt;= 0)) {</span>
<span class="fc" id="L361">            return key.substring(secondSeparator + 1, thirdSeparator);</span>
        }
<span class="fc" id="L363">        return &quot;&quot;;</span>
    }

    /**
     * Add in the remote overhead to the &quot;to&quot; key if it was a move
     *
     * @param from the key we came from
     * @param to the key we went to
     * @return the &amp;quot;to&amp;quot; key with remote overhead or as it was
     */
    public static String addRemoteCostIfMoved(final String from, final String to) {

        // If no move, just return the &quot;to&quot; key
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (getServiceHost(from).equals(getServiceHost(to))) {</span>
<span class="fc" id="L377">            return to;</span>
        }

        // Add remote overhead to the &quot;to&quot; key
<span class="fc" id="L381">        return addExpense(to, getExpense(to) + IDirectoryPlace.REMOTE_EXPENSE_OVERHEAD);</span>
    }

    /**
     * Mangle origKey such that the host on proxyKey becomes a proxy for it
     *
     * @param origKey the original key
     * @param proxyKey the key representing the place that wants to proxy
     * @param dfltExp default expense to use if origKey has none or -1 for no dflt
     * @return a key with the original data type, service type and service name and expense but the new place location from
     *         proxyKey
     */
    public static String makeProxyKey(final String origKey, final String proxyKey, final int dfltExp) {
<span class="fc bfc" id="L394" title="All 4 branches covered.">        if (isLocalTo(origKey, proxyKey) &amp;&amp; dfltExp &gt; -1) {</span>
<span class="fc" id="L395">            return addExpense(origKey, getExpense(origKey, dfltExp));</span>
        }
<span class="fc" id="L397">        final int newExp = getExpense(origKey, dfltExp);</span>
<span class="fc" id="L398">        return getDataType(origKey) + SEPARATOR + getServiceName(origKey) + SEPARATOR + getServiceType(origKey) + SEPARATOR</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                + getServiceLocation(proxyKey) + (newExp &gt; -1 ? (DOLLAR + newExp) : &quot;&quot;);</span>
    }

    /**
     * Build a key to the directory of the place represented by the key
     *
     * @param key the key of the place to find a directory for
     */
    public static String getDefaultDirectoryKey(final String key) {
<span class="fc" id="L408">        return WILDCARD_THREE + KeyManipulator.getServiceHostUrl(key) + &quot;DirectoryPlace&quot;;</span>
    }


    public static String getHostMatchKey(final String key) {
<span class="fc" id="L413">        return WILDCARD_THREE + KeyManipulator.getServiceHostUrl(key) + &quot;*&quot;;</span>
    }

    public static String makeSproutKey(final String placeKey) {
<span class="fc" id="L417">        return &quot;*.*.&quot; + IServiceProviderPlace.SPROUT_KEY + &quot;.&quot; + getServiceLocation(placeKey) + DOLLAR + &quot;0&quot;;</span>
    }

    /** This class is not meant to be instantiated. */
    private KeyManipulator() {}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>