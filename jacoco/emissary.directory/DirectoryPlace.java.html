<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirectoryPlace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.directory</a> &gt; <span class="el_source">DirectoryPlace.java</span></div><h1>DirectoryPlace.java</h1><pre class="source lang-java linenums">package emissary.directory;

import emissary.config.Configurator;
import emissary.core.EmissaryException;
import emissary.core.IBaseDataObject;
import emissary.core.Namespace;
import emissary.log.MDCConstants;
import emissary.place.ServiceProviderPlace;
import emissary.place.ServiceProviderRefreshablePlace;
import emissary.server.mvc.adapters.DirectoryAdapter;

import jakarta.annotation.Nullable;
import org.slf4j.MDC;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * The DirectoryPlace class is used to store information relating to Places/Services in the Emissary Agent-Based
 * architecture. When a Place comes up it calls the method addPlace passing in all the relevant information to store in
 * the Directory. Agents query the directory by calling the method nextKeys which requires a query String search
 * pattern.
 *
 * &lt;p&gt;
 * We try to support some network topographic constructions by providing a set of peer directories. Peers are monitored
 * and checked automatically by HeartbeatManager and the peer network is assumed to be fully connected. Peer directories
 * are a fairly-static list of peer directories read from a config file. At least one host must be listed in order to
 * bootstrap the network.
 *
 * &lt;p&gt;
 * Emissary directory instances are also observable with respect to Peer activities, and Place activities. Peer
 * observers will be called with a list of current members of the peer group (including this directory) whenever the
 * peer group loses or gains members. Place observers will be called with a key that matches the pattern supplied on
 * their subscription and an indication of whether it is a register or deregister or cost change.
 *
 */
public class DirectoryPlace extends ServiceProviderPlace implements IRemoteDirectory {

    /**
     * Map of DirectoryEntryList objects by data id. This map contains the actual advertisements seen by this directory and
     * available for MobilAgent/Place use via nextKeys
     */
<span class="fc" id="L50">    protected DirectoryEntryMap entryMap = new DirectoryEntryMap();</span>

    /** Peer directories to this one */
<span class="fc" id="L53">    protected Set&lt;DirectoryEntry&gt; peerDirectories = new CopyOnWriteArraySet&lt;&gt;();</span>

    /**
     * Statically configured peers. Remember them even when they shut down. A subset of peerDirectories
     */
<span class="fc" id="L58">    protected Set&lt;String&gt; staticPeers = new HashSet&lt;&gt;();</span>

    /** Heartbeat manager for checking up on remote directories */
    protected HeartbeatManager heartbeat;

    /** Manage observers */
    protected DirectoryObserverManager observerManager;

    /** True if this directory is a rendezvous peer */
<span class="fc" id="L67">    protected boolean rdvPeer = false;</span>

    /** True is this directory is shutdown */
<span class="fc" id="L70">    protected boolean shutdownInitiated = false;</span>

    /** True if this directory is running */
<span class="fc" id="L73">    protected boolean running = false;</span>

    /** Emissary node configuration for network topology */
    protected EmissaryNode emissaryNode;

    /**
     * Window of slop between asking for a zone and purging &quot;stale&quot; entries from the entry map. Since there is a window of
     * time when the remote directory might be spewing out addPlace calls while we are asking for the zone transfer we can't
     * just remove all entries once we get the zone, demarshall it and decide (finally) that it's ready to put into our map.
     * We have to allow things somewhat recent to stay around also. This time window looks back from the beginning of the
     * zone transfer request to provide some leniency.
     */
<span class="fc" id="L85">    protected long zoneSlopWindowMillis = 30000; // 30 sec</span>

    /**
     * Create a new empty directory using this location and no parent
     *
     * @param placeLoc string key to register this directory
     * @param node EmissaryNode for this directory place
     * 
     * @throws IOException when configuration fails
     */
    public DirectoryPlace(final String placeLoc, EmissaryNode node) throws IOException {
<span class="fc" id="L96">        super(placeLoc);</span>
<span class="fc" id="L97">        this.emissaryNode = node;</span>
<span class="fc" id="L98">        setupDirectory();</span>
<span class="fc" id="L99">    }</span>

    /**
     * Create a new directory as specified by the config info with a parent for relaying through.
     *
     * @param configStream config info
     * @param parentDir the parent directory or null if none
     * @param placeLoc key for this place
     * @param node node configuration details or null for defaults
     * @throws IOException when configuration fails
     */
    public DirectoryPlace(final InputStream configStream, final String parentDir, final String placeLoc, final EmissaryNode node) throws IOException {
<span class="fc" id="L111">        super(configStream, parentDir, placeLoc);</span>
<span class="fc" id="L112">        this.emissaryNode = node;</span>
<span class="fc" id="L113">        setupDirectory();</span>
<span class="fc" id="L114">    }</span>

    /**
     * Create a new child directory as specified by the config info
     *
     * @param configInfo our config file to read
     * @param placeLoc string key to register this directory
     * @param node node configuration details or null for defaults
     * @throws IOException when configuration fails
     */
    public DirectoryPlace(final String configInfo, final String placeLoc, final EmissaryNode node) throws IOException {
<span class="fc" id="L125">        super(configInfo, placeLoc);</span>
<span class="fc" id="L126">        this.emissaryNode = node;</span>
<span class="fc" id="L127">        setupDirectory();</span>
<span class="fc" id="L128">    }</span>

    /**
     * Create a new directory as specified by the config info
     *
     * @param configStream config info
     * @param placeLoc key for this place
     * @param node node configuration details or null for defaults
     * @throws IOException when configuration fails
     */
    public DirectoryPlace(final InputStream configStream, final String placeLoc, final EmissaryNode node) throws IOException {
<span class="fc" id="L139">        super(configStream, placeLoc);</span>
<span class="fc" id="L140">        this.emissaryNode = node;</span>
<span class="fc" id="L141">        setupDirectory();</span>
<span class="fc" id="L142">    }</span>

    /**
     * Shared code for all the constructors to take advantage of in initializing directory services Configuration items read
     * here are
     * &lt;ul&gt;
     * &lt;li&gt;HEARTBEAT_DELAY_SECONDS, default is 30&lt;/li&gt;
     * &lt;li&gt;HEARTBEAT_INTERVAL_SECONDS, default is 30&lt;/li&gt;
     * &lt;li&gt;HEARTBEAT_FAILURE_THRESHOLD, set transient failure count, default owned by HeartbeatManager&lt;/li&gt;
     * &lt;li&gt;HEARTBEAT_PERMANENT_FAILURE_THRESHOLD, set permanent failure count, default owned by HeartbeatManager&lt;/li&gt;
     * &lt;/ul&gt;
     */
    private void setupDirectory() {
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">        if (this.emissaryNode.isValid() &amp;&amp; !this.emissaryNode.isStandalone()) {</span>
            // Start a heart beat manager with initial and interval seconds
<span class="fc" id="L157">            final int initialSeconds = configG.findIntEntry(&quot;HEARTBEAT_DELAY_SECONDS&quot;, 30);</span>
<span class="fc" id="L158">            final int intervalSeconds = configG.findIntEntry(&quot;HEARTBEAT_INTERVAL_SECONDS&quot;, 30);</span>

<span class="fc" id="L160">            this.heartbeat = new HeartbeatManager(myKey, initialSeconds, intervalSeconds);</span>

<span class="fc" id="L162">            final int heartbeatFailureThreshold = configG.findIntEntry(&quot;HEARTBEAT_FAILURE_THRESHOLD&quot;, -1);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (heartbeatFailureThreshold &gt; 0) {</span>
<span class="nc" id="L164">                this.heartbeat.setFailThreshold(heartbeatFailureThreshold);</span>
            }

<span class="fc" id="L167">            final int heartbeatPermanentFailure = configG.findIntEntry(&quot;HEARTBEAT_PERMANENT_FAILURE_THRESHOLD&quot;, -1);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">            if (heartbeatPermanentFailure &gt; 0) {</span>
<span class="nc" id="L169">                this.heartbeat.setPermanentFailThreshold(heartbeatPermanentFailure);</span>
            }
        }

        // Set up deferred stuff from ServiceProviderPlace
        // for directories only we are our own localDirPlace
        // and the key is our own key
<span class="fc" id="L176">        localDirPlace = this;</span>
<span class="fc" id="L177">        dirPlace = myKey;</span>

        // Start an observer manager
<span class="fc" id="L180">        this.observerManager = new DirectoryObserverManager(myKey);</span>

        // Configure my initial rendezvous peers
<span class="fc" id="L183">        configureNetworkTopology();</span>

        // Add an entry representing myself into the
        // local entry map. This allows observers to
        // work for this case, and allows Jetty instances
        // with just a DirectoryPlace and some bunches
        // of other non-Place code to function well and trigger
        // the peer discovery mechanism when they zone transfer
        // this entry
<span class="fc" id="L192">        final List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L193">        list.add(keys.get(0));</span>
<span class="fc" id="L194">        addPlaces(list);</span>
<span class="fc" id="L195">        this.running = true;</span>
<span class="fc" id="L196">    }</span>

    /**
     * Find an optional peer config stream or file and initialize tracking of the peers found there.
     * &lt;p&gt;
     * We don't actually contact any of the remote directories here, so we can get the heck out of the constructor code and
     * get this place registered in the namespace quick! so other directories can find us in a timely fashion.
     */
    private void configureNetworkTopology() {
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (!this.emissaryNode.isValid()) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (this.emissaryNode.isStandalone()) {</span>
<span class="nc" id="L207">                logger.debug(&quot;Running as a standalone emissary node&quot;);</span>
            } else {
<span class="nc" id="L209">                logger.debug(&quot;Not configured as an emissary node&quot;);</span>
            }
<span class="nc" id="L211">            return;</span>
        }

<span class="fc" id="L214">        logger.debug(&quot;Emissary node info: {}&quot;, this.emissaryNode);</span>

        try {
            // Peer network configuration is from peer.cfg
<span class="fc" id="L218">            final Configurator peerConfig = this.emissaryNode.getPeerConfigurator();</span>
<span class="fc" id="L219">            final Set&lt;String&gt; peers = peerConfig.findEntriesAsSet(&quot;RENDEZVOUS_PEER&quot;);</span>
<span class="fc" id="L220">            this.staticPeers.addAll(peers);</span>
<span class="fc" id="L221">            addPeerDirectories(peers, true);</span>

<span class="fc" id="L223">            logger.debug(&quot;Configured {} rendezvous peers from {} config entries.&quot;, this.peerDirectories.size(), peers.size());</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            logger.debug(&quot;This directory is {}a rendezvous peer.&quot;, this.rdvPeer ? &quot;&quot; : &quot;NOT (yet) &quot;);</span>
<span class="nc" id="L225">        } catch (IOException iox) {</span>
<span class="nc" id="L226">            logger.debug(&quot;There is no peer.cfg data available&quot;);</span>
<span class="fc" id="L227">        }</span>
<span class="fc" id="L228">    }</span>

    /**
     * Determine if the key is local to this directory
     *
     * @param key the key to query for
     * @return true iff the key host and port are the same (jvm locality test)
     */
    private boolean isLocal(final String key) {
<span class="fc" id="L237">        return KeyManipulator.isLocalTo(key, myKey);</span>
    }

    /**
     * Determine if the entry is local to this directory
     *
     * @param entry the entry to query for
     * @return true iff the entry key host and port are the same (jvm locality test)
     */
    private boolean isLocal(final DirectoryEntry entry) {
<span class="fc" id="L247">        return isLocal(entry.getKey());</span>
    }

    /**
     * Add a Set of peer directory to this one
     *
     * @param keys set of string key for peer directories
     */
    @Override
    public void irdAddPeerDirectories(@Nullable final Set&lt;String&gt; keys) {
        // Validate contract
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">        if ((keys == null) || keys.isEmpty()) {</span>
<span class="nc" id="L259">            logger.warn(&quot;Ignoring irdAddPeerDirectories called with null or no keys&quot;);</span>
<span class="nc" id="L260">            return;</span>
        }

        // Validate remote parameters
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (final String key : keys) {</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">            if (!KeyManipulator.isValid(key)) {</span>
<span class="nc" id="L266">                logger.warn(&quot;Ignoring irdAddPeerDirectories called with {} keys, invalid key {}&quot;, keys.size(), key);</span>
<span class="nc" id="L267">                return;</span>
            }
<span class="fc" id="L269">        }</span>
<span class="fc" id="L270">        addPeerDirectories(keys, false);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Add a Set of peer directory to this one
     *
     * @param keys set of string key for peer directories
     * @param initPhase true if during place initialization
     */
    // TODO Look at DirectoryPlaceTest at the cases where spied methods are used
    public void addPeerDirectories(final Set&lt;String&gt; keys, final boolean initPhase) {

<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (this.shutdownInitiated) {</span>
<span class="fc" id="L283">            logger.error(&quot;Shutdown has been initiated. Cannot add peer directories in this state.&quot;);</span>
<span class="fc" id="L284">            return;</span>
        }

<span class="fc" id="L287">        boolean changeMade = false;</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (final String key : keys) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            if (isLocal(key)) {</span>
                // I am listed as a rendezvous for someone
<span class="fc" id="L292">                this.rdvPeer = true;</span>
<span class="fc" id="L293">                continue;</span>
            }

<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (this.emissaryNode.isStandalone()) {</span>
<span class="fc" id="L297">                logger.debug(&quot;Not adding peers in standalone nodes&quot;);</span>
<span class="fc" id="L298">                continue;</span>
            }

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            if (!isStaticPeer(key)) {</span>
<span class="nc" id="L302">                logger.warn(&quot;Unknown peer requesting to be added: {}&quot;, key);</span>
<span class="nc" id="L303">                continue;</span>
            }

<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (!isKnownPeer(key)) {</span>
<span class="fc" id="L307">                this.peerDirectories.add(new DirectoryEntry(key));</span>
<span class="fc" id="L308">                logger.debug(&quot;Added peer directory {}&quot;, key);</span>

                // Setup heartbeat to new peer directory
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">                if (initPhase) {</span>
                    // not contacted yet
<span class="fc" id="L313">                    this.heartbeat.addRemoteDirectory(key, HeartbeatManager.NO_CONTACT);</span>
                } else {
                    // already contacted
<span class="nc" id="L316">                    this.heartbeat.addRemoteDirectory(key, HeartbeatManager.IS_ALIVE);</span>

                    // Initial transfer of remote directory info here
                    // It may not be up yet, so be resilient
<span class="nc" id="L320">                    loadPeerEntries(key);</span>
                }


<span class="fc" id="L324">                changeMade = true;</span>
            } else {
<span class="fc" id="L326">                logger.debug(&quot;We already knew about peer {}&quot;, key);</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">                if (!this.heartbeat.isAlive(key)) {</span>
<span class="fc" id="L328">                    logger.debug(&quot;Forcing peer {} alive due to arriving registration&quot;, key);</span>
<span class="fc" id="L329">                    this.heartbeat.setHealthStatus(key, HeartbeatManager.IS_ALIVE, &quot;Received peer registration&quot;);</span>
<span class="fc" id="L330">                    loadPeerEntries(key);</span>
                }
            }
<span class="fc" id="L333">        }</span>

        // Notify all observers
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (changeMade) {</span>
<span class="fc" id="L337">            this.observerManager.peerUpdate(new HashSet&lt;&gt;(this.peerDirectories));</span>
        }
<span class="fc" id="L339">    }</span>

    /**
     * Retrieve and load (zone transfer) all the entries from the specified peer directory. Zone transfers do not trigger
     * observables like addPlaces does
     *
     * @param peerKey the key of the peer directory
     */
    protected void loadPeerEntries(final String peerKey) {

<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (this.emissaryNode.isStandalone()) {</span>
<span class="nc" id="L350">            logger.debug(&quot;Cannot load peer entries in standalone nodes&quot;);</span>
<span class="nc" id="L351">            return;</span>
        }

<span class="fc" id="L354">        logger.debug(&quot;Doing zone transfer with peer {}&quot;, peerKey);</span>
        // TODO See DirectoryPlace for spy example which needs to be addressed
<span class="fc" id="L356">        final DirectoryEntryMap newEntries = loadRemoteEntries(peerKey, this.entryMap);</span>
<span class="pc bpc" id="L357" title="3 of 4 branches missed.">        if ((newEntries == null) || newEntries.isEmpty()) {</span>
<span class="fc" id="L358">            logger.debug(&quot;We got nothing back from the peer zone xfer&quot;);</span>
<span class="fc" id="L359">            return;</span>
        }

        // We just did this guy remove his stuff
<span class="nc" id="L363">        newEntries.removeAllOnDirectory(peerKey);</span>

        // Remove local stuff
<span class="nc" id="L366">        newEntries.removeAllOnDirectory(myKey);</span>

        // Make note of any possible new peer directory
        // We should only be seeing peers here
<span class="nc" id="L370">        final Set&lt;String&gt; newPeers = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        for (final DirectoryEntry newEntry : newEntries.allEntries()) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (!isLocal(newEntry)) {</span>
<span class="nc" id="L373">                final String possiblePeer = KeyManipulator.getDefaultDirectoryKey(newEntry.getKey());</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">                if (!isKnownPeer(possiblePeer) &amp;&amp; !newPeers.contains(possiblePeer)) {</span>
<span class="nc" id="L375">                    logger.debug(&quot;Discovered new peer {} from {} during zt with {}&quot;, possiblePeer, newEntry.getKey(), peerKey);</span>
<span class="nc" id="L376">                    newPeers.add(possiblePeer);</span>
                }
            }
<span class="nc" id="L379">        }</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (!newPeers.isEmpty()) {</span>
<span class="nc" id="L381">            logger.debug(&quot;Adding {} new peers from zt with {}&quot;, newPeers.size(), peerKey);</span>
<span class="nc" id="L382">            addPeerDirectories(newPeers, false);</span>
        }
<span class="nc" id="L384">    }</span>

    /**
     * Retrieve and load (zone transfer) all the entries from specified remote directory into the specified map. Remove any
     * stale entries from the destination map if one is specified and merge in the new entries. Zone transfers do not
     * trigger observables like addPlaces does
     *
     * @param key key of the remote directory to transfer from
     * @param loadMap the map to load into or null for no load. Observers are notified if loadMap is not null
     * @return the new entries
     */
    @Nullable
    private DirectoryEntryMap loadRemoteEntries(final String key, @Nullable final DirectoryEntryMap loadMap) {

<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (this.emissaryNode.isStandalone()) {</span>
<span class="nc" id="L399">            logger.debug(&quot;Cannot load remote entries in standalone nodes&quot;);</span>
<span class="nc" id="L400">            return null;</span>
        }

<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (!isStaticPeer(key)) {</span>
<span class="nc" id="L404">            logger.debug(&quot;Ignoring non-configured peer {}&quot;, key);</span>
<span class="nc" id="L405">            return null;</span>
        }

        // Track how long the zone transfer takes and use that
        // info along with the slop window to help determine if
        // there are stale entries and what they might be.

<span class="fc" id="L412">        final long startZone = System.currentTimeMillis();</span>
<span class="fc" id="L413">        DirectoryEntryMap map = null;</span>
        try {
            // Also registers as a peer with them
            // TODO should we need to get the current EmissaryClient to ensure parameters are set correctly
<span class="fc" id="L417">            final DirectoryAdapter da = new DirectoryAdapter();</span>
<span class="nc" id="L418">            map = da.outboundRegisterPeer(key, myKey);</span>

<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L421">                logger.debug(&quot;Retrieved {} entries in zone transfer from {} in {} millis&quot;, map.entryCount(), key,</span>
<span class="nc" id="L422">                        System.currentTimeMillis() - startZone);</span>
            }

            // No entries mean we got the remote message,
            // and they just don't have any places registered yet
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (map.isEmpty()) {</span>
<span class="nc" id="L428">                return map;</span>
            }

<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (loadMap != null) {</span>

                // Remove and notify of any stale entries in loadMap
<span class="nc" id="L434">                removeStaleEntries(loadMap, key, startZone - this.zoneSlopWindowMillis, map, true);</span>

                // Remove any duplicate entries from map
                // so that they don't get double notified to observers
                // do the load and notify all observers
<span class="nc" id="L439">                cleanLoadNotifyEntries(map, loadMap, myKey, REMOTE_COST_OVERHEAD);</span>
            } else {
<span class="nc" id="L441">                logger.debug(&quot;Skipping load of {} new entries from {} returning list to caller&quot;, map.entryCount(), key);</span>
            }
<span class="fc" id="L443">        } catch (Exception ex) {</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L445">                logger.debug(&quot;Unable to zone transfer with {}&quot;, key, ex);</span>
            } else {
<span class="fc" id="L447">                logger.info(&quot;Unable to zone transfer with {}&quot;, key);</span>
            }
            // Failure condition. Trigger state change in heartbeat manager
<span class="fc" id="L450">            this.heartbeat.setHealthStatus(key, HeartbeatManager.NO_CONTACT, &quot;Remote directory failed zone transfer&quot;);</span>
<span class="nc" id="L451">        }</span>

<span class="fc" id="L453">        return map;</span>
    }

    /**
     * Remove stale entries from the specified map and notify any observers Nothing older than checkpoint time can be
     * considered stale and nothing that is on the incming newEntries list can be considered stale since we would just be
     * adding it back again. Duplicates (non-stale entries) are removed from the newEntries map to avoid further confusion
     * but only if the cost is the same. Otherwise, we leave it so that a cost-change event can propagete from later code
     * but still avoid triggering a place removed event.
     *
     * @param loadMap the map we are removing from
     * @param key the key of the directory whose entries might be stale
     * @param checkpoint the time window to determine possible staleness
     * @param newEntries the new map arriving
     * @param performNotification only use observerManager if true
     * @return list of entries that were removed
     */
    private List&lt;DirectoryEntry&gt; removeStaleEntries(final DirectoryEntryMap loadMap, final String key, final long checkpoint,
            @Nullable final DirectoryEntryMap newEntries, final boolean performNotification) {

<span class="nc" id="L473">        final List&lt;DirectoryEntry&gt; staleEntries = new ArrayList&lt;&gt;();</span>

        // Nothing newer than the checkpoint time can be stale
        // Nothing that is in teh loadMap but also duplicated in
        // the newEntries map can be stale either. This helps eliminate
        // the problem of removing it just so we can add it back.
        // This uses a mark and sweep to prevent concurrent mod exceptions
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (final DirectoryEntry d : loadMap.collectAllMatching(key)) {</span>
            // is it old enough to be possibly stale
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (d.getAge() &lt; checkpoint) {</span>
                // is it missing from the new list
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (newEntries != null) {</span>
<span class="nc" id="L485">                    final List&lt;DirectoryEntry&gt; matches = newEntries.collectAllMatching(d.getKey());</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                    if (matches.isEmpty()) {</span>
<span class="nc" id="L487">                        logger.debug(&quot;Marking stale entry {}&quot;, d.getKey());</span>
<span class="nc" id="L488">                        staleEntries.add(d);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                    } else if (matches.size() == 1) {</span>
                        // remove from newEntries if exact dup
<span class="nc" id="L491">                        final DirectoryEntry me = matches.get(0);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                        if (me.getFullKey().equals(d.getFullKey())) {</span>
<span class="nc" id="L493">                            logger.debug(&quot;Removing duplcate key from incoming map {}&quot;, me.getKey());</span>
<span class="nc" id="L494">                            newEntries.removeEntry(me.getKey());</span>
                        }
                    }
<span class="nc" id="L497">                } else {</span>
                    // must be stale if no newEntries
<span class="nc" id="L499">                    logger.debug(&quot;Marking stale entry (no new entries){}&quot;, d.getKey());</span>
<span class="nc" id="L500">                    staleEntries.add(d);</span>
                }
            }
<span class="nc" id="L503">        }</span>

        // Remove and notify
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (!staleEntries.isEmpty()) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            for (final DirectoryEntry stale : staleEntries) {</span>
<span class="nc" id="L508">                logger.debug(&quot;Removing stale entry {}&quot;, stale.getKey());</span>
<span class="nc" id="L509">                loadMap.removeEntry(stale.getKey());</span>
<span class="nc" id="L510">            }</span>

<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (performNotification) {</span>
<span class="nc" id="L513">                logger.debug(&quot;Notifying observers of {} stale entry removals&quot;, staleEntries.size());</span>
<span class="nc" id="L514">                this.observerManager.placeRemoveEntries(staleEntries);</span>
            }
        } else {
<span class="nc" id="L517">            logger.debug(&quot;There were no stale entries to remove&quot;);</span>
        }

<span class="nc" id="L520">        return staleEntries;</span>
    }

    /**
     * Grok the details of a new entry list and figure out which observers need to be notified. Remove any entries that are
     * not going to end up being added anyway.
     *
     * @param map the new entries to understand
     * @param loadMap the map the entries will be loaded into
     * @param purgeKey remove any keys matching
     * @param costBump add cost to incoming
     */
    private void cleanLoadNotifyEntries(final DirectoryEntryMap map, @Nullable final DirectoryEntryMap loadMap, @Nullable final String purgeKey,
            final int costBump) {
        // Remove local entries from the new map
        // We already know about our local stuff.
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (purgeKey != null) {</span>
<span class="nc" id="L537">            final List&lt;DirectoryEntry&gt; removed = map.removeAllOnDirectory(purgeKey);</span>
<span class="nc" id="L538">            logger.debug(&quot;Clean/load removed {} entries based on {} remaining = {}&quot;, removed.size(), purgeKey, map.entryCount());</span>
        }

        // Add remote overhead to remaining
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (costBump &gt; 0) {</span>
<span class="nc" id="L543">            map.addCostToMatching(&quot;*.*.*.*&quot;, costBump);</span>
<span class="nc" id="L544">            logger.debug(&quot;Clean/load did cost-bump of {} on {} entries&quot;, costBump, map.entryCount());</span>
        }

<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (loadMap != null) {</span>
<span class="nc" id="L548">            final DirectoryEntryMap newEntries = new DirectoryEntryMap();</span>
<span class="nc" id="L549">            final DirectoryEntryMap costChangeEntries = new DirectoryEntryMap();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            for (final DirectoryEntry e : map.allEntries()) {</span>
<span class="nc" id="L551">                final List&lt;DirectoryEntry&gt; matches = loadMap.collectAllMatching(e.getKey());</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                if (matches.isEmpty()) {</span>
<span class="nc" id="L553">                    newEntries.addEntry(e);</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">                } else if ((matches.size() == 1) &amp;&amp; e.isBetterThan(matches.get(0))) {</span>
<span class="nc" id="L555">                    costChangeEntries.addEntry(e);</span>
                }
<span class="nc" id="L557">            }</span>

            // Merge remaining truly new entries and notify observers
<span class="nc" id="L560">            final int newCount = newEntries.entryCount();</span>
<span class="nc" id="L561">            final int cceCount = costChangeEntries.entryCount();</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            if (newCount &gt; 0) {</span>
<span class="nc" id="L563">                logger.debug(&quot;Loading {} new entries&quot;, newCount);</span>
<span class="nc" id="L564">                loadMap.addEntries(newEntries);</span>
<span class="nc" id="L565">                this.observerManager.placeAdd(newEntries.allEntryKeys());</span>
            } else {
<span class="nc" id="L567">                logger.debug(&quot;Nothing truly new from {} entries&quot;, map.entryCount());</span>
            }

            // .. and cost change entries
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (cceCount &gt; 0) {</span>
<span class="nc" id="L572">                logger.debug(&quot;Loading {} better cost entries&quot;, cceCount);</span>
<span class="nc" id="L573">                loadMap.addEntries(costChangeEntries);</span>
<span class="nc" id="L574">                this.observerManager.placeCostChange(costChangeEntries.allEntryKeys());</span>
            } else {
<span class="nc" id="L576">                logger.debug(&quot;No cost change entries from {} entries&quot;, map.entryCount());</span>
            }

            // Now let the map that gets returned have just the new
            // and cost changed entries, no already known stuff
<span class="nc bnc" id="L581" title="All 2 branches missed.">            if ((newCount + cceCount) &lt; map.entryCount()) {</span>
<span class="nc" id="L582">                map.clear();</span>
<span class="nc" id="L583">                map.addEntries(costChangeEntries);</span>
<span class="nc" id="L584">                map.addEntries(newEntries);</span>
<span class="nc" id="L585">                map.sort();</span>
            }
<span class="nc" id="L587">        } else {</span>
<span class="nc" id="L588">            logger.debug(&quot;Clean/load got a null loadMap so skipping the load for {} entries&quot;, map.entryCount());</span>
        }
<span class="nc" id="L590">    }</span>


    /**
     * Get a list of the keys of all the peer directories known here
     *
     * @return set of string names of peer directory keys
     */
    @Override
    public Set&lt;String&gt; getPeerDirectories() {
<span class="fc" id="L600">        final Set&lt;String&gt; l = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">        for (final DirectoryEntry sde : this.peerDirectories) {</span>
<span class="fc" id="L602">            l.add(sde.getKey());</span>
<span class="fc" id="L603">        }</span>
<span class="fc" id="L604">        return l;</span>
    }

    /**
     * Add a list of entries to the directory Entries are kept in a Hash by &quot;datatype::serviceType&quot; Each entry is a List of
     * sorted DirectoryEntries sorted order on cost and then quality, held in a DirectoryEntryList object
     *
     * @param entryList the new entries to add
     */
    protected void addEntries(final List&lt;DirectoryEntry&gt; entryList) {
<span class="fc" id="L614">        logger.debug(&quot;Adding {} new entries&quot;, entryList.size());</span>

        // add them
<span class="fc" id="L617">        this.entryMap.addEntries(entryList);</span>

        // notify all observers
<span class="fc" id="L620">        this.observerManager.placeAddEntries(entryList);</span>

<span class="fc" id="L622">        final Set&lt;String&gt; peerSet = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">        for (final DirectoryEntry newEntry : entryList) {</span>
            // Make a note of any possible new peer directory
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (!isLocal(newEntry)) {</span>
<span class="fc" id="L626">                final String peerKey = KeyManipulator.getDefaultDirectoryKey(newEntry.getKey());</span>
<span class="pc bpc" id="L627" title="1 of 4 branches missed.">                if (!isKnownPeer(peerKey) &amp;&amp; !peerSet.contains(peerKey)) {</span>
<span class="fc" id="L628">                    logger.debug(&quot;Discovered new peer {} from  addEntries {}&quot;, peerKey, newEntry.getKey());</span>
<span class="fc" id="L629">                    peerSet.add(peerKey);</span>
                } else {
<span class="fc" id="L631">                    logger.debug(&quot;No new peer implications to {} from {}&quot;, peerKey, newEntry.getKey());</span>
                }
            }
<span class="fc" id="L634">        }</span>

<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (!peerSet.isEmpty()) {</span>
<span class="fc" id="L637">            logger.debug(&quot;Adding {} newly discovered peer entries&quot;, peerSet.size());</span>
<span class="fc" id="L638">            addPeerDirectories(peerSet, false);</span>
        }
<span class="fc" id="L640">    }</span>

    /**
     * Add an entry to the directory Entries are kept in a Hash by &quot;datatype::serviceType&quot; Each entry is a List of sorted
     * DirectoryEntries sorted order on cost and then quality, held in a DirectoryEntryList object
     *
     * @param newEntry the new entry to add
     */
    protected void addEntry(final DirectoryEntry newEntry) {
<span class="fc" id="L649">        logger.debug(&quot;Adding single new entry {}&quot;, newEntry.getKey());</span>
<span class="fc" id="L650">        final List&lt;DirectoryEntry&gt; entryList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L651">        entryList.add(newEntry);</span>
<span class="fc" id="L652">        addEntries(entryList);</span>
<span class="fc" id="L653">    }</span>

    /**
     * Determine if key represents a configured peer
     */
    public boolean isStaticPeer(final String key) {
<span class="fc" id="L659">        return this.staticPeers.contains(key);</span>
    }

    /**
     * Determine if key represents a known peer
     */
    private boolean isKnownPeer(final String key) {
<span class="fc bfc" id="L666" title="All 2 branches covered.">        for (final DirectoryEntry sde : this.peerDirectories) {</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">            if (KeyManipulator.isLocalTo(sde.getKey(), key)) {</span>
<span class="fc" id="L668">                return true;</span>
            }
<span class="fc" id="L670">        }</span>
<span class="fc" id="L671">        return false;</span>
    }

    /**
     * Remove a peer from the peer list
     *
     * @param key the peer to remove
     */
    @Nullable
    private DirectoryEntry removePeer(final String key) {
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (this.emissaryNode.isStandalone()) {</span>
<span class="nc" id="L682">            logger.debug(&quot;Cannot remove peers from standalone nodes&quot;);</span>
<span class="nc" id="L683">            return null;</span>
        }

<span class="nc" id="L686">        DirectoryEntry expeer = null;</span>

        // Find it
<span class="nc bnc" id="L689" title="All 2 branches missed.">        for (final DirectoryEntry sde : this.peerDirectories) {</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (KeyManipulator.isLocalTo(sde.getKey(), key)) {</span>
                // nb. COW Set does not support iterator.remove
<span class="nc" id="L692">                expeer = sde;</span>
<span class="nc" id="L693">                break;</span>
            }
<span class="nc" id="L695">        }</span>

        // Nuke it
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (expeer != null) {</span>
            // Remove from COW set
<span class="nc" id="L700">            this.peerDirectories.remove(expeer);</span>

            // Remove from heartbeat manager
<span class="nc" id="L703">            this.heartbeat.removeRemoteDirectory(expeer.getKey());</span>

            // Notify all observers, but don't give them
            // access to our own Set object
<span class="nc" id="L707">            this.observerManager.peerUpdate(new HashSet&lt;&gt;(this.peerDirectories));</span>

            // Remove the entries if any remain
<span class="nc" id="L710">            removePlaces(Collections.singletonList(KeyManipulator.getHostMatchKey(expeer.getKey())));</span>
        }

<span class="nc" id="L713">        return expeer;</span>
    }

    /**
     * Remove directory. Called from the heartbeat manager and from the EmissaryClient
     *
     * @param key string key of failed directory
     * @param permanent true if from a normal shutdown rather than a transient error
     * @return count of how many places were removed locally
     */
    @Override
    public int irdFailDirectory(final String key, final boolean permanent) {

<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if (this.emissaryNode.isStandalone()) {</span>
<span class="fc" id="L727">            logger.debug(&quot;Cannot fail remotes in standalone nodes&quot;);</span>
<span class="fc" id="L728">            return 0;</span>
        }

        // Validate remote input
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (!KeyManipulator.isValid(key)) {</span>
<span class="nc" id="L733">            logger.warn(&quot;Ignoring, called with invalid key {}&quot;, key);</span>
<span class="nc" id="L734">            return 0;</span>
        }

<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (this.shutdownInitiated) {</span>
<span class="nc" id="L738">            logger.debug(&quot;Remote {} reported as failed, in shutdown&quot;, key);</span>
<span class="nc" id="L739">            return 0;</span>
        }

        // Reports of my demise are premature...
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (isLocal(key)) {</span>
<span class="nc" id="L744">            logger.warn(</span>
                    &quot;Someone reported me as failed, but I appear to be still running. Refusing to remove my own entries and propagate this filthy lie.&quot;);
<span class="nc" id="L746">            return 0;</span>
        }

<span class="nc" id="L749">        final String dirKey = KeyManipulator.getDefaultDirectoryKey(key);</span>
<span class="nc" id="L750">        final String hmKey = KeyManipulator.getHostMatchKey(key);</span>
<span class="nc" id="L751">        int count = 0;</span>

<span class="nc bnc" id="L753" title="All 2 branches missed.">        logger.debug(&quot;irdFailDirectory {} {} permanent&quot;, key, permanent ? &quot;is&quot; : &quot;is not&quot;);</span>

        // Modify local entries for the failed remote directory
        // Permanent failure removes entries on failed directory.
        // Transient failure adjusts weight of entries on failed directory.
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (permanent) {</span>
<span class="nc" id="L759">            logger.debug(&quot;Permanent failure of remote {}&quot;, key);</span>
<span class="nc" id="L760">            count += removePlaces(Collections.singletonList(hmKey));</span>
        } else {
            // Change the cost for all places matching the
            // failed directory. This has the effect of causing them
            // not to be chosen as much.
<span class="nc" id="L765">            final List&lt;DirectoryEntry&gt; list = this.entryMap.collectAllMatching(hmKey);</span>
<span class="nc" id="L766">            this.observerManager.placeCostChangeEntries(list);</span>
        }

        // Handle permanent removal of remote directory
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (permanent) {</span>
            // Notify my heartbeat manager so that a normal deregistration
            // followed by a restart will trigger a state transition even
            // if under the timer check time
<span class="nc" id="L774">            this.heartbeat.setHealthStatus(key, HeartbeatManager.NO_CONTACT, &quot;Permanent deregistration&quot;);</span>

            // Remove from peer list
<span class="nc bnc" id="L777" title="All 2 branches missed.">            if (isKnownPeer(dirKey)) {</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">                if (!isStaticPeer(dirKey)) {</span>
<span class="nc" id="L779">                    logger.debug(&quot;Removing non-static peer {}&quot;, dirKey);</span>
<span class="nc" id="L780">                    removePeer(dirKey);</span>
                } else {
<span class="nc" id="L782">                    logger.debug(&quot;Static peer {} is deregistered but monitoring continues&quot;, dirKey);</span>
                }
            } else {
<span class="nc" id="L785">                logger.warn(&quot;Directory {} failed but it isn't a peer??&quot;, dirKey);</span>
            }
        }

<span class="nc" id="L789">        return count;</span>
    }

    /**
     * Send directory failure message to another directory
     *
     * @param directory the place to send the message
     * @param failKey the key of the one that failed
     * @param permanent true if this is from normal deregistrtion
     */
    protected void sendFailMessage(final DirectoryEntry directory, final String failKey, final boolean permanent) {

<span class="pc bpc" id="L801" title="1 of 2 branches missed.">        if (this.emissaryNode.isStandalone()) {</span>
<span class="nc" id="L802">            logger.debug(&quot;No remote failure messages generated in standalone node&quot;);</span>
<span class="nc" id="L803">            return;</span>
        }

        try {
<span class="fc" id="L807">            new DirectoryAdapter().outboundFailDirectory(directory.getKey(), failKey, permanent);</span>
<span class="nc" id="L808">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L809">            logger.error(&quot;Problem talking to directory {} to fail {}&quot;, directory.getKey(), failKey, ex);</span>
<span class="fc" id="L810">        }</span>
<span class="fc" id="L811">    }</span>

    /**
     * Established or re-established contact with a remote directory. Check for presence on peer and initiate zone transfer
     * if needed.
     *
     * @param key the key of the directory we contacted
     */
    void contactedRemoteDirectory(final String key) {
<span class="nc" id="L820">        MDC.put(MDCConstants.SERVICE_LOCATION, KeyManipulator.getServiceLocation(myKey));</span>
<span class="nc" id="L821">        logger.debug(&quot;Established contact with {}&quot;, key);</span>

<span class="nc bnc" id="L823" title="All 4 branches missed.">        if (isStaticPeer(key) &amp;&amp; isKnownPeer(key)) {</span>
<span class="nc" id="L824">            loadPeerEntries(key);</span>
        } else {
<span class="nc" id="L826">            logger.warn(&quot;Contact established with {} but it is not a peer&quot;, key);</span>
        }
<span class="nc" id="L828">        MDC.remove(MDCConstants.SERVICE_LOCATION);</span>
<span class="nc" id="L829">    }</span>

    /**
     * Register a place with all of its complete keys
     *
     * @param keys list of complete keys with expense
     */
    @Override
    public void addPlaces(@Nullable final List&lt;String&gt; keys) {
        // Validate contract
<span class="pc bpc" id="L839" title="3 of 6 branches missed.">        if ((keys == null) || keys.isEmpty() || (keys.get(0) == null)) {</span>
<span class="nc" id="L840">            logger.error(&quot;addPlaces skipping place with no keys&quot;);</span>
<span class="nc" id="L841">            return;</span>
        }

        // Build a list of DirectoryEntry out of these
<span class="fc" id="L845">        final List&lt;DirectoryEntry&gt; del = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">        for (final String key : keys) {</span>
<span class="fc" id="L847">            final DirectoryEntry d = new DirectoryEntry(key);</span>
<span class="fc" id="L848">            del.add(d);</span>
<span class="fc" id="L849">        }</span>

<span class="fc" id="L851">        irdAddPlaces(del, false);</span>
<span class="fc" id="L852">    }</span>

    /**
     * Register a list of entries. This signature only meant to be called from within EmissaryClient code. Each entry will
     * have a separate key, cost and quality but should all be local to each other.
     *
     * @param entryList list of directoryEntry to add
     * @param propagating true if going back down the directory chain
     */
    @Override
    public void irdAddPlaces(@Nullable final List&lt;DirectoryEntry&gt; entryList, final boolean propagating) {

<span class="pc bpc" id="L864" title="2 of 4 branches missed.">        if ((entryList == null) || entryList.isEmpty()) {</span>
<span class="nc" id="L865">            logger.debug(&quot;irdAddPlaces called with null or empty entryList!&quot;);</span>
<span class="nc" id="L866">            return;</span>
        }

        // Validate remote input
<span class="fc bfc" id="L870" title="All 2 branches covered.">        for (final DirectoryEntry d : entryList) {</span>
<span class="pc bpc" id="L871" title="2 of 4 branches missed.">            if (d == null || !d.isValid()) {</span>
<span class="nc" id="L872">                logger.warn(&quot;Ignoring irdAddPlaces called with {} DirectoryEntry objects due to invalid key in {}&quot;, entryList.size(), d);</span>
<span class="nc" id="L873">                return;</span>
            }
<span class="fc" id="L875">        }</span>

        // These keys better all be from the same emissary node
        // We should check that they are and throw if not
<span class="fc" id="L879">        final String place = entryList.get(0).getKey(); // !!</span>
<span class="fc" id="L880">        final boolean isLocal = isLocal(place);</span>

<span class="pc bpc" id="L882" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L883">            logger.debug(&quot;Starting irdAddPlaces with {} entries for {} place  - place={}, myKey={}&quot;, entryList.size(),</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                    isLocal ? &quot;local&quot; : &quot;non-local&quot;, place, myKey);</span>
        }

        // make a defensive deep copy of the incoming list, so we
        // can safely proxy and adjust cost as needed
<span class="fc" id="L889">        final List&lt;DirectoryEntry&gt; entries = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">        for (final DirectoryEntry d : entryList) {</span>
<span class="fc" id="L891">            entries.add(new DirectoryEntry(d, DirectoryEntry.PRESERVE_TIME));</span>
<span class="fc" id="L892">        }</span>

        // Let each directory add this non-local component to the cost
        // based on the place locality. This should be enough to
        // dwarf any cost variants among truly local places
<span class="fc bfc" id="L897" title="All 2 branches covered.">        if (!isLocal) {</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">            for (final DirectoryEntry d : entries) {</span>
<span class="fc" id="L899">                d.addCost(REMOTE_COST_OVERHEAD);</span>
<span class="fc" id="L900">            }</span>
        }

<span class="fc" id="L903">        logger.debug(&quot;Doing addEntries for {} new entries&quot;, entries.size());</span>
<span class="fc" id="L904">        addEntries(entries);</span>

        // Notify peers if entries are being added locally
<span class="fc bfc" id="L907" title="All 4 branches covered.">        if (isLocal &amp;&amp; !this.peerDirectories.isEmpty()) {</span>
            // This may fail if the peer is not up yet. That is normal.
<span class="fc bfc" id="L909" title="All 2 branches covered.">            for (final DirectoryEntry peer : this.peerDirectories) {</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">                if (this.heartbeat.isAlive(peer.getKey())) {</span>
<span class="nc" id="L911">                    registerWith(peer, entries, false);</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">                } else if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L913">                    logger.debug(&quot;Not registering {} with peer {}, not alive right now&quot;, entries.size(), peer.getKey());</span>
                }
<span class="fc" id="L915">            }</span>
        }
<span class="fc" id="L917">    }</span>

    /**
     * Private helper to register directories. This method handles multiple directory entries, each can have separate key,
     * description, cost, and quality
     *
     * @param dir the place entry to register
     * @param entryList the new entries
     * @param propagating true if propagating back down from higher level directory
     */
    protected void registerWith(final DirectoryEntry dir, final List&lt;DirectoryEntry&gt; entryList, final boolean propagating) {
<span class="nc bnc" id="L928" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L929">            logger.debug(&quot;registerWith({},{},{})&quot;, dir.getKey(), entryList, propagating);</span>
        }

        try {
<span class="nc" id="L933">            new DirectoryAdapter().outboundAddPlaces(dir.getKey(), entryList, propagating);</span>
<span class="nc" id="L934">            logger.debug(&quot;registration succeeded&quot;);</span>
<span class="nc" id="L935">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L936">            logger.warn(&quot;DirectoryPlace.registerWith: Problem talking to directory {} to add {} entries&quot;, dir.getKey(), entryList.size(), ex);</span>
<span class="nc" id="L937">        }</span>
<span class="nc" id="L938">    }</span>

    /**
     * Called by mobile agent to get a destination for a payload
     *
     * @param dataId key to entryMap, dataType::serviceType, e.g. UNKNOWN::ID
     * @param payload the payload being evaluated
     * @param lastPlace place agent visited last, this is not stateless
     * @return List of DirectoryEntry with next place to go or empty list if none
     */
    @Override
    public List&lt;DirectoryEntry&gt; nextKeys(final String dataId, final IBaseDataObject payload, final DirectoryEntry lastPlace) {
        // Normal lookup in public entry map
<span class="fc bfc" id="L951" title="All 2 branches covered.">        logger.debug(&quot;nextKey called with dataId='{}', and lastPlace={}&quot;, dataId, lastPlace == null ? &quot;null&quot; : lastPlace.getFullKey());</span>

<span class="fc" id="L953">        List&lt;DirectoryEntry&gt; entries = nextKeys(dataId, payload, lastPlace, this.entryMap);</span>
<span class="pc bpc" id="L954" title="5 of 6 branches missed.">        if (logger.isDebugEnabled() &amp;&amp; (entries != null) &amp;&amp; !entries.isEmpty()) {</span>
<span class="nc" id="L955">            logger.debug(&quot;nextKey produced {} entries from main map {}&quot;, entries.size(), entries);</span>
        }
<span class="fc" id="L957">        return entries;</span>
    }

    /**
     * Get tne next logical entry based on current dataId and last place visited
     *
     * @param dataId key to entryMap, dataType::serviceType, e.g. UNKNOWN::ID
     * @param payload the payload being routed
     * @param lastPlace place agent visited last, this is not stateless
     * @param entries map of DirectoryEntry stored in this directory
     * @return List of DirectoryEntry with next place to go or empty list if none
     */
    protected List&lt;DirectoryEntry&gt; nextKeys(final String dataId, final IBaseDataObject payload, @Nullable final DirectoryEntry lastPlace,
            final DirectoryEntryMap entries) {
        // Find the entry list for the type being requested
<span class="fc" id="L972">        final DirectoryEntryList currentList = getWildcardedEntryList(dataId, entries);</span>

        // Nothing for the dataId or any wildcarded versions, we are done
<span class="pc bpc" id="L975" title="1 of 4 branches missed.">        if ((currentList == null) || currentList.isEmpty()) {</span>
<span class="fc" id="L976">            logger.debug(&quot;nextKey - nothing found here for {}&quot;, dataId);</span>
<span class="fc" id="L977">            return List.of();</span>
        }

        // remove denied entries
<span class="fc bfc" id="L981" title="All 4 branches covered.">        currentList.removeIf(de -&gt; de.getLocalPlace() != null &amp;&amp; de.getLocalPlace().isDenied(payload.currentForm()));</span>

        // test for invalidated places
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        currentList.stream().filter(e -&gt; e.getLocalPlace() instanceof ServiceProviderRefreshablePlace</span>
<span class="pc bnc" id="L985" title="All 2 branches missed.">                &amp;&amp; ((ServiceProviderRefreshablePlace) e.getLocalPlace()).isInvalidated())</span>
<span class="fc" id="L986">                .forEach(this::handleEntryRefresh);</span>

<span class="fc bfc" id="L988" title="All 2 branches covered.">        if (currentList.isEmpty()) {</span>
<span class="fc" id="L989">            logger.debug(&quot;nextKeys - no non-DENIED entries found here for {}&quot;, dataId);</span>
<span class="fc" id="L990">            return List.of();</span>
        }
        // The list we are building for return to the caller
<span class="fc" id="L993">        final List&lt;DirectoryEntry&gt; keyList = new ArrayList&lt;&gt;();</span>

        // The dataId this time is different from the last place
        // visited, so we can just choose from the list of the lowest
        // expense places and get on with it
<span class="fc" id="L998">        DirectoryEntry trialEntry = currentList.getEntry(0);</span>
<span class="fc bfc" id="L999" title="All 6 branches covered.">        if (lastPlace == null || (!lastPlace.getDataId().equals(dataId) &amp;&amp; !trialEntry.getServiceLocation().equals(lastPlace.getServiceLocation()))) {</span>
<span class="fc" id="L1000">            logger.debug(&quot;doing first in list for {}&quot;, trialEntry);</span>
<span class="fc" id="L1001">            keyList.add(currentList.pickOneOf(trialEntry.getExpense()));</span>
        } else {
            // Trying a particular &quot;dataType::serviceType&quot; pair again
<span class="fc bfc" id="L1004" title="All 2 branches covered.">            for (int i = 0; i &lt; currentList.size(); i++) {</span>
<span class="fc" id="L1005">                trialEntry = currentList.getEntry(i);</span>

                // Skip entry if less/same expensive. Includes the obvious
                // test, plus evaluation of whether we would choose a
                // particular non-local place if it was here. If we wouldn't
                // choose it if it was here, we certainly aren't willing
                // to move to get it.
<span class="fc" id="L1012">                final int te = trialEntry.getExpense() % REMOTE_EXPENSE_OVERHEAD;</span>
<span class="fc" id="L1013">                final int le = lastPlace.getExpense() % REMOTE_EXPENSE_OVERHEAD;</span>

                // Always skip service cheaper than what we already did
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                if (te &lt; le) {</span>
<span class="fc" id="L1017">                    logger.debug(&quot;nextKey skip lower cost {}&quot;, trialEntry.getFullKey());</span>
<span class="fc" id="L1018">                    continue;</span>
                }

                // If relaying, we want to be hopping closer to the target
<span class="pc bpc" id="L1022" title="1 of 4 branches missed.">                if ((te == le) &amp;&amp; (trialEntry.getExpense() &gt;= lastPlace.getExpense())</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">                        &amp;&amp; !trialEntry.getServiceHostUrl().equals(lastPlace.getServiceHostUrl())) {</span>
<span class="nc" id="L1024">                    logger.debug(&quot;nextKey skip equal cost {}&quot;, trialEntry.getFullKey());</span>
<span class="nc" id="L1025">                    continue;</span>
                }

                // If equal or lower cost, no point in using the entry
<span class="pc bpc" id="L1029" title="1 of 4 branches missed.">                if ((trialEntry.getExpense() &lt;= lastPlace.getExpense()) &amp;&amp; trialEntry.getServiceHostUrl().equals(lastPlace.getServiceHostUrl())) {</span>
<span class="fc" id="L1030">                    logger.debug(&quot;nextKey skip lower cost not relaying {}&quot;, trialEntry.getFullKey());</span>
<span class="fc" id="L1031">                    continue;</span>
                }

                // Entry is more expense and different service
<span class="fc" id="L1035">                logger.debug(&quot;nextKey - doing next in list&quot;);</span>
<span class="fc" id="L1036">                keyList.add(currentList.pickOneOf(trialEntry.getExpense()));</span>
<span class="fc" id="L1037">                break;</span>
            }

        }

<span class="fc" id="L1042">        return keyList;</span>
    }

    protected synchronized void handleEntryRefresh(final DirectoryEntry entry) {
        // attempt to see if the place has been refreshed already
<span class="nc" id="L1047">        entry.clearLocalPlace();</span>

<span class="nc" id="L1049">        final ServiceProviderRefreshablePlace place = (ServiceProviderRefreshablePlace) entry.getLocalPlace();</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if (place.isInvalidated()) {</span>
<span class="nc" id="L1051">            logger.debug(&quot;{} has been invalidated, attempting refresh ....&quot;, entry);</span>
<span class="nc" id="L1052">            place.refresh();</span>
<span class="nc" id="L1053">            entry.clearLocalPlace();</span>
<span class="nc" id="L1054">            logger.debug(&quot;{} has been refreshed&quot;, entry);</span>
        }
<span class="nc" id="L1056">    }</span>

    /**
     * Get the possibly wildcarded DirectoryEntryList for the dataId
     *
     * @param dataId the type of data being queried
     * @param entries the entry map to use
     * @return DirectoryEntryList or null if none
     */
    protected DirectoryEntryList getWildcardedEntryList(final String dataId, final DirectoryEntryMap entries) {
        // Ids of the form FOO-BAR(ASCII)-BAZ will be wildcarded as:
        // FOO-BAR(ASCII)-BAZ
        // FOO-BAR(*)-BAZ
        // FOO-BAR(*)-*
        // FOO-*
        // See WildcardEntry for a more thorough example
<span class="fc" id="L1072">        return WildcardEntry.getWildcardedEntry(dataId, entries);</span>
    }

    /**
     * Payloads that need to traverse the relay gateway can visit here to be forwarded on to the correct destination
     * &lt;p&gt;
     * The payload will have the simple current form that caused this relay point to be selected replace with the full
     * four-tupled key of the place matching the request on the proper side of this relay point.
     *
     * @param d the payload to be inspected
     */
    @Override
    public void process(final IBaseDataObject d) {
<span class="nc bnc" id="L1085" title="All 2 branches missed.">        if (d.currentForm().equals(this.myKey)) {</span>
<span class="nc" id="L1086">            logger.debug(&quot;Probe routing has been removed&quot;);</span>
        } else {
<span class="nc" id="L1088">            logger.debug(&quot;Doing routing on '{}'&quot;, d.shortName());</span>
<span class="nc" id="L1089">            handleRouting(d);</span>
        }
<span class="nc" id="L1091">    }</span>

    /**
     * Handle the routing for a payload
     *
     * @param d the visiting payload
     */
    protected void handleRouting(final IBaseDataObject d) {
        // The source entry we are interested in is the one that got us
        // here. The &quot;lastPlaceVisited&quot; should be my own key, so we want
        // the one before that.
<span class="nc" id="L1102">        DirectoryEntry sourceEntry = d.getPenultimatePlaceVisited();</span>

        // Source entry still null?
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        if (sourceEntry == null) {</span>
<span class="nc" id="L1106">            logger.debug(&quot;Payload had no source entry and no places visited. &quot; + &quot;Using my own directory key, which is probably wrong.&quot;);</span>
<span class="nc" id="L1107">            sourceEntry = this.getDirectoryEntry();</span>
        }

        // Last place visited shows the key that cause the payload
        // to arrive at this place since it is logged into the history
        // just before calling this method. The dataId on this entry
        // is the entry that finally was selected for use, so we reuse
        // it here in the proper entry map.
<span class="nc" id="L1115">        final DirectoryEntry thisEntry = d.getLastPlaceVisited();</span>
<span class="nc" id="L1116">        final String dataId = thisEntry.getDataId();</span>

<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1119">            logger.debug(&quot;Relay payload '{}' arrived with form {} coming from {} arrival entry {} arrival dataId={}&quot;, d.shortName(), d.currentForm(),</span>
<span class="nc" id="L1120">                    sourceEntry.getKey(), thisEntry.getKey(), dataId);</span>
        }

        // Where we want to go from here
<span class="nc" id="L1124">        List&lt;DirectoryEntry&gt; destination = nextKeys(dataId, d, sourceEntry);</span>

<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1127">            logger.debug(&quot;Selected {} entries {} from incoming {} and data id {} current form={}&quot;, destination.size(), destination,</span>
<span class="nc" id="L1128">                    sourceEntry.getKey(), dataId, d.currentForm());</span>
        }

        // Replace the current form with the full key version of same
<span class="nc" id="L1132">        d.popCurrentForm();</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">        for (final DirectoryEntry destEntry : destination) {</span>
<span class="nc" id="L1134">            d.pushCurrentForm(destEntry.getKey());</span>
<span class="nc" id="L1135">        }</span>

<span class="nc bnc" id="L1137" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1138">            logger.debug(&quot;Leaving relay gateway with current form {}&quot;, d.getAllCurrentForms());</span>
        }
<span class="nc" id="L1140">    }</span>

    /**
     * Make directory contents available for debug or display and analysis
     *
     * @return List of DirectoryEntry (copies)
     */
    @Override
    public List&lt;DirectoryEntry&gt; getEntries() {
<span class="fc" id="L1149">        final List&lt;DirectoryEntry&gt; entries = this.entryMap.allEntries();</span>
<span class="fc" id="L1150">        return DirectoryEntryList.deepCopy(entries, true);</span>
    }

    /**
     * Get list of DirectoryEntry that match the key pattern
     *
     * @param pattern a key pattern to match
     * @return List of DirectoryEntry (copies)
     */
    @Override
    public List&lt;DirectoryEntry&gt; getMatchingEntries(final String pattern) {
<span class="fc" id="L1161">        final List&lt;DirectoryEntry&gt; entries = this.entryMap.collectAllMatching(pattern);</span>
<span class="fc" id="L1162">        return DirectoryEntryList.deepCopy(entries, true);</span>
    }

    /**
     * Make directory contents entry keys available for display and transfer
     *
     * @return Set of String in the DataId format DATATYPE::SERVICETYPE
     */
    @Override
    public Set&lt;String&gt; getEntryKeys() {
<span class="fc" id="L1172">        return new TreeSet&lt;&gt;(this.entryMap.keySet());</span>
    }

    /**
     * Get the requested directory entry
     *
     * @param dataId the key to the entry Map set of DirectoryEntryList objects
     * @return a DirectoryEntryList object for the key or null if none
     */
    @Override
    public DirectoryEntryList getEntryList(final String dataId) {
<span class="fc" id="L1183">        final DirectoryEntryList value = this.entryMap.get(dataId);</span>
<span class="fc" id="L1184">        return new DirectoryEntryList(value, DirectoryEntryList.DEEP_COPY, DirectoryEntryList.PRESERVE_TIME);</span>
    }

    /**
     * Deregister places removing all keys for the specified places.
     *
     * @param keys four-tuple key for the place
     * @return count of how many keys removed
     */
    @Override
    public int removePlaces(final List&lt;String&gt; keys) {
<span class="nc" id="L1195">        return irdRemovePlaces(keys, false);</span>
    }

    /**
     * Deregister places removing all keys for the specified places. Should only be called externally from EmissaryClient
     *
     * @see #removePlaces(List)
     * @param keys four-tuple key for the place
     * @param propagating true if going down the line
     * @return count of how many keys removed
     */
    @Override
    public int irdRemovePlaces(@Nullable final List&lt;String&gt; keys, final boolean propagating) {

<span class="pc bpc" id="L1209" title="2 of 4 branches missed.">        if ((keys == null) || keys.isEmpty()) {</span>
<span class="nc" id="L1210">            logger.warn(&quot;Ignoring null or empty key list for irdRemovePlaces&quot;);</span>
<span class="nc" id="L1211">            return 0;</span>
        }

        // Validate remote input
<span class="fc bfc" id="L1215" title="All 2 branches covered.">        for (final String key : keys) {</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">            if (!KeyManipulator.isValid(key)) {</span>
<span class="fc" id="L1217">                logger.warn(&quot;Ignoring irdRemovePlaces called with {} keys due to invalid key {}&quot;, keys.size(), key);</span>
<span class="fc" id="L1218">                return 0;</span>
            }
<span class="fc" id="L1220">        }</span>

        // Note we don't just pull the dataId from the map
        // because we anticipate the incoming keys will be
        // wildcarded as places go away rather than individual
        // service proxy keys
<span class="fc" id="L1226">        final List&lt;DirectoryEntry&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">        for (final String key : keys) {</span>
<span class="fc" id="L1228">            final List&lt;DirectoryEntry&gt; m = this.entryMap.removeAllMatching(key);</span>
<span class="fc" id="L1229">            matches.addAll(m);</span>
<span class="fc" id="L1230">        }</span>

<span class="fc" id="L1232">        final int count = matches.size();</span>
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1234">            logger.debug(&quot;Found {} entries for removal matching {} keys={}&quot;, count, keys.size(), keys);</span>
        }

        // Nothing do to, nothing to propagate
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L1239">            return 0;</span>
        }

<span class="fc" id="L1242">        int localCount = 0;</span>

        // Count the locals and hit the observers
<span class="fc bfc" id="L1245" title="All 2 branches covered.">        for (final DirectoryEntry e : matches) {</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">            if (isLocal(e.getKey())) {</span>
<span class="fc" id="L1247">                localCount++;</span>
            }
            // Notify observers of entry removal
<span class="fc" id="L1250">            this.observerManager.placeRemove(e.getFullKey());</span>
<span class="fc" id="L1251">        }</span>

        // Notify peers if local entries are being removed
<span class="pc bpc" id="L1254" title="2 of 4 branches missed.">        if (!this.peerDirectories.isEmpty() &amp;&amp; (localCount &gt; 0)) {</span>
            // This may fail if the peer is not up. That is normal.
<span class="fc bfc" id="L1256" title="All 2 branches covered.">            for (final DirectoryEntry peer : this.peerDirectories) {</span>
<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">                if (this.heartbeat.isAlive(peer.getKey())) {</span>
<span class="nc" id="L1258">                    logger.debug(&quot;Deregistering {} keys from peer {}&quot;, keys.size(), peer);</span>
<span class="nc" id="L1259">                    deregisterFrom(peer, keys, false);</span>
                }
<span class="fc" id="L1261">            }</span>
        }

<span class="fc" id="L1264">        final List&lt;String&gt; localKeys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">        for (final DirectoryEntry match : matches) {</span>
<span class="fc" id="L1266">            final String key = match.getKey();</span>
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">            if (isLocal(key)) {</span>
<span class="fc" id="L1268">                logger.debug(&quot;Removed {} putting in local bucket&quot;, key);</span>
<span class="fc" id="L1269">                localKeys.add(key);</span>
            }
<span class="fc" id="L1271">        }</span>

<span class="fc" id="L1273">        return localKeys.size();</span>
    }

    /**
     * Private helper to deregister entry from directories
     *
     * @param dir the remote directory to deregister from
     * @param keys the list of keys the place can handle (SERVICE_PROXY)
     * @param propagating true if propagating across levels
     */
    protected void deregisterFrom(final DirectoryEntry dir, final List&lt;String&gt; keys, final boolean propagating) {
        try {
            // Follow the logic to irdRemovePlaces on the remote side
<span class="nc" id="L1286">            new DirectoryAdapter().outboundRemovePlaces(dir.getKey(), keys, propagating);</span>
<span class="nc" id="L1287">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L1288">            logger.error(&quot;DirectoryPlace.deregisterFrom: &quot; + &quot;Problem talking to directory &quot; + dir.getKey() + &quot; to deregister keys&quot;, ex);</span>
<span class="nc" id="L1289">        }</span>
<span class="nc" id="L1290">    }</span>

    /**
     * Shutdown this place and deregister and notify any peers and observers that this directory is closing
     */
    @Override
    public void shutDown() {
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">        if (this.shutdownInitiated) {</span>
<span class="nc" id="L1298">            return;</span>
        }
<span class="fc" id="L1300">        this.shutdownInitiated = true;</span>
<span class="fc" id="L1301">        this.running = false;</span>

<span class="fc" id="L1303">        logger.debug(&quot;Initiating directory shutdown&quot;);</span>

<span class="fc bfc" id="L1305" title="All 2 branches covered.">        if (this.heartbeat != null) {</span>
<span class="fc" id="L1306">            this.heartbeat.shutDown();</span>
        }

<span class="fc bfc" id="L1309" title="All 2 branches covered.">        if (!this.emissaryNode.isStandalone()) {</span>

            // Notify peers of my demise
<span class="fc bfc" id="L1312" title="All 2 branches covered.">            for (final DirectoryEntry peer : this.peerDirectories) {</span>
<span class="fc" id="L1313">                logger.debug(&quot;Sending fail msg to peer {}&quot;, peer);</span>
<span class="fc" id="L1314">                sendFailMessage(peer, myKey, true);</span>
<span class="fc" id="L1315">            }</span>
        }

        // Remove all entries and notify all observers
<span class="fc" id="L1319">        final List&lt;DirectoryEntry&gt; matches = this.entryMap.collectAllMatching(&quot;*.*.*.*&quot;);</span>
<span class="fc bfc" id="L1320" title="All 2 branches covered.">        for (final DirectoryEntry e : matches) {</span>
<span class="fc" id="L1321">            this.observerManager.placeRemove(e.getFullKey());</span>
<span class="fc" id="L1322">        }</span>

        // Nuke em
<span class="fc" id="L1325">        this.entryMap.clear();</span>

        // Remove peers and Notify all observers that we are leaving the group
<span class="fc" id="L1328">        this.peerDirectories.clear();</span>
<span class="fc" id="L1329">        this.observerManager.peerUpdate(this.peerDirectories);</span>

<span class="fc" id="L1331">        unbindFromNamespace();</span>
<span class="fc" id="L1332">        logger.info(&quot;Done shutting down DirectoryPlace&quot;);</span>

<span class="fc" id="L1334">    }</span>

    /**
     * Add an observer for one of the observable activities in the directory The runtime class of the observer determines
     * what is being observed
     *
     * @param observer the new DirectoryObserver to add
     */
    @Override
    public void addObserver(final DirectoryObserver observer) {
<span class="fc" id="L1344">        this.observerManager.addObserver(observer);</span>
<span class="fc" id="L1345">        logger.debug(&quot;We now have {} observers registered&quot;, this.observerManager.getObserverCount());</span>
<span class="fc" id="L1346">    }</span>

    /**
     * Remove an observer previously registered with this directory
     *
     * @param observer the object to remove
     * @return true if it was found on the list
     */
    @Override
    public boolean deleteObserver(final DirectoryObserver observer) {
<span class="nc" id="L1356">        final boolean removed = this.observerManager.deleteObserver(observer);</span>
<span class="nc" id="L1357">        logger.debug(&quot;We now have {} observers registered&quot;, this.observerManager.getObserverCount());</span>
<span class="nc" id="L1358">        return removed;</span>
    }

    /**
     * Pull the local directory from the namespace and return it. This does not work in some test scenarios where we have
     * multiple non-local directories in a single JVM.
     *
     * @return the local directory instance
     * @throws EmissaryException when directory does not exist in namespace
     */
    public static IDirectoryPlace lookup() throws EmissaryException {
<span class="fc" id="L1369">        final String name = &quot;DirectoryPlace&quot;;</span>

<span class="fc" id="L1371">        final Object nsval = Namespace.lookup(name);</span>
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">        if (nsval instanceof IDirectoryPlace) {</span>
<span class="fc" id="L1373">            return (IDirectoryPlace) nsval;</span>
        }

<span class="nc" id="L1376">        throw new EmissaryException(&quot;Bad directory place lookup found &quot; + nsval);</span>
    }

    /**
     * Get the sync status of a remote directory as seen from this directory. Note that this method only can return true for
     * things that the HeartbeatManager is tracking, i.e. peer directories of this instance.
     *
     * @param key the key of the remote directory
     * @return true if remote is reported as being up, false otherwise
     */
    @Override
    public boolean isRemoteDirectoryAvailable(final String key) {
<span class="nc bnc" id="L1388" title="All 4 branches missed.">        return (this.heartbeat != null) &amp;&amp; this.heartbeat.isHealthy(key);</span>
    }

    /**
     * Force a heartbeat with a particular directory represented by key does not necessarily need to be one that the
     * HeartbeatManager is already tracking and calling this method will not add it permanently to any list to be tracked.
     * This is a one time event and can be used at the caller's discretion. Note however,that if the key is not a peer of
     * this directory, a warning will be issued here when the success or failure action is taken by the heartbeat manager.
     * It can be ignored in this case. Note also, that a true return from this method merely means that the remote directory
     * responded to the heartbeat method, not that the remote directory is in sync yet with this one.
     *
     * @see #isRemoteDirectoryAvailable(String)
     * @param key the key of the remote directory
     * @return true if remote is up, false otherwise
     */
    @Override
    public boolean heartbeatRemoteDirectory(final String key) {
<span class="nc bnc" id="L1405" title="All 4 branches missed.">        return (this.heartbeat != null) &amp;&amp; this.heartbeat.heartbeat(key);</span>
    }

    /**
     * Indicate if directory is running
     *
     * @return true if running
     */
    @Override
    public boolean isRunning() {
<span class="fc" id="L1415">        return this.running;</span>
    }

    /**
     * Indicate whether shutdown has been initiated
     *
     * @return true if shutdown initiated
     */
    @Override
    public boolean isShutdownInitiated() {
<span class="nc" id="L1425">        return this.shutdownInitiated;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>