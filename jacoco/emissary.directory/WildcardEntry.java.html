<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WildcardEntry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.directory</a> &gt; <span class="el_source">WildcardEntry.java</span></div><h1>WildcardEntry.java</h1><pre class="source lang-java linenums">package emissary.directory;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

/**
 * Handle the details of a wildcard directory entry including iterating through the possible directory match strings A
 * dataId will be wildcarded like this, based on dash and paren markings in the dataType.
 * &lt;ul&gt;
 * &lt;li&gt;FOO-BAR(ASCII-TRANSLIT)-BAZ(SHAZAM)-BAM_MESSAGE&lt;/li&gt;
 * &lt;li&gt;FOO-BAR(ASCII-TRANSLIT)-BAZ(*)-BAM_MESSAGE&lt;/li&gt;
 * &lt;li&gt;FOO-BAR(*)-BAZ(*)-BAM_MESSAGE&lt;/li&gt;
 * &lt;li&gt;FOO-BAR(*)-BAZ(*)-*&lt;/li&gt;
 * &lt;li&gt;FOO-BAR(*)-*&lt;/li&gt;
 * &lt;li&gt;FOO-*&lt;/li&gt;
 * &lt;li&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;ol&gt;
 * &lt;li&gt;The complete unchanged entry is returned first, so an exact match will work like it always has worked
 * before.&lt;/li&gt;
 * &lt;li&gt;Next the parenthetical expressions are wildcarded out starting from the right and moving left until all have been
 * changed to wildcards. Each step wildcards another parenthetical expression without reverting the previous one. So you
 * currently cannot get a wildcard match on the non-rightmost expression without every one to the right of it also being
 * wildcarded.&lt;/li&gt;
 * &lt;li&gt;Finally, each dash delimited expression is wildcarded, then eliminated starting from the right until there is
 * nothing left but the pure wildcard entry &amp;quot;*&amp;quot;. The wildcarded parenthetical expressions are left wildcarded
 * for this stage, so as things are dropped off, you can only match wildcarded parentheticals that are still remaining
 * to the left.&lt;/li&gt;
 * &lt;/ol&gt;
 */
public class WildcardEntry {

<span class="fc" id="L41">    private static final Logger logger = LoggerFactory.getLogger(WildcardEntry.class);</span>

    String dataType;
    @Nullable
    String serviceType;
<span class="fc" id="L46">    @Nullable</span>
    List&lt;String&gt; wc = null;

    private static final char DASH = '-';
    private static final char OPEN = '(';
    private static final char CLOS = ')';
    private static final String KSEP = KeyManipulator.DATAIDSEPARATOR;
<span class="fc" id="L53">    private static final int KSPL = KSEP.length();</span>

    private static final String DASH_WC = &quot;-*&quot;; // DASH Wildcard
    private static final String PAREN_WC = &quot;(*)&quot;; // PAREN Wildcard
    private static final String PURE_WC = &quot;*&quot;; // PURE Wildcard

<span class="fc" id="L59">    public WildcardEntry(final String s) {</span>
<span class="fc" id="L60">        parseEntry(s);</span>
<span class="fc" id="L61">    }</span>

    /**
     * Parse the entry into the ordered list of wildcard entries
     */
    private synchronized void parseEntry(final String entry) {
<span class="fc" id="L67">        final int pos = entry.indexOf(KSEP);</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (pos &gt; 0) {</span>
<span class="fc" id="L69">            this.dataType = entry.substring(0, pos);</span>
<span class="fc" id="L70">            this.serviceType = entry.substring(pos + KSPL);</span>
        } else {
<span class="fc" id="L72">            this.dataType = entry;</span>
<span class="fc" id="L73">            this.serviceType = null;</span>
        }
<span class="fc" id="L75">    }</span>

    /**
     * Iterator over the wildcard entries in order
     */
    public Iterator&lt;String&gt; iterator() {
<span class="fc" id="L81">        load();</span>
<span class="fc" id="L82">        return this.wc.iterator();</span>
    }

    /**
     * Get the results of parsing as a set
     */
    public Set&lt;String&gt; asSet() {
<span class="fc" id="L89">        load();</span>
<span class="fc" id="L90">        return new HashSet&lt;&gt;(this.wc);</span>
    }

    /**
     * Lazy load of the list containing wildcarded parts
     */
    private synchronized void load() {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (this.wc == null) {</span>
<span class="fc" id="L98">            this.wc = new ArrayList&lt;&gt;();</span>

            // Put the original on the list first
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (this.serviceType != null) {</span>
<span class="fc" id="L102">                this.wc.add(this.dataType + KSEP + this.serviceType);</span>
            } else {
<span class="fc" id="L104">                this.wc.add(this.dataType);</span>
            }

            // Replace paren parts one at a time from the right
<span class="fc" id="L108">            String dt = this.dataType;</span>
<span class="fc" id="L109">            int lastOpen = this.dataType.length();</span>
<span class="fc" id="L110">            boolean done = false;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            while (!done) {</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                for (int i = lastOpen - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                    if (dt.charAt(i) == OPEN) {</span>
<span class="fc" id="L114">                        final int clos = dt.indexOf(CLOS, i);</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                        if (clos &gt; i) {</span>
<span class="fc" id="L116">                            dt = dt.substring(0, i) + PAREN_WC + dt.substring(clos + 1);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">                            if (this.serviceType != null) {</span>
<span class="fc" id="L118">                                this.wc.add(dt + KSEP + this.serviceType);</span>
                            } else {
<span class="fc" id="L120">                                this.wc.add(dt);</span>
                            }
<span class="fc" id="L122">                            lastOpen = i;</span>
<span class="fc" id="L123">                            break;</span>
                        }
<span class="nc" id="L125">                        done = true;</span>
<span class="nc" id="L126">                        break;</span>
                    }
<span class="fc bfc" id="L128" title="All 2 branches covered.">                    if (i == 0) {</span>
<span class="fc" id="L129">                        done = true;</span>
                    }
                }
            }

            // Now working with the totally replaced paren string
            // handle the dashed parts

<span class="fc bfc" id="L137" title="All 2 branches covered.">            for (int i = dt.length() - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">                if (dt.charAt(i) == DASH) {</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">                    if (this.serviceType != null) {</span>
<span class="fc" id="L140">                        this.wc.add(dt.substring(0, i) + DASH_WC + KSEP + this.serviceType);</span>
                    } else {
<span class="fc" id="L142">                        this.wc.add(dt.substring(0, i) + DASH_WC);</span>
                    }
                }
            }
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (this.serviceType != null) {</span>
<span class="fc" id="L147">                this.wc.add(PURE_WC + KSEP + this.serviceType);</span>
            } else {
<span class="fc" id="L149">                this.wc.add(PURE_WC);</span>
            }
        }
<span class="fc" id="L152">    }</span>

    /**
     * Select an entry from the map
     *
     * @param dataId the string to wildcard
     * @param map the map to choose from
     * @return the found entry
     */
    public static DirectoryEntryList getWildcardedEntry(final String dataId, final DirectoryEntryMap map) {

<span class="fc" id="L163">        final DirectoryEntryList matches = new DirectoryEntryList();</span>

<span class="fc" id="L165">        final WildcardEntry we = new WildcardEntry(dataId);</span>
<span class="fc" id="L166">        logger.debug(&quot;Got a set of size {} from {}&quot;, we.size(), dataId);</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (final String w : we.asSet()) {</span>
<span class="fc" id="L169">            final DirectoryEntryList found = map.get(w);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (found != null) {</span>
<span class="fc" id="L171">                logger.debug(&quot;Found a wildcard match on {} size={}&quot;, w, found.size());</span>
<span class="fc" id="L172">                matches.addAll(found);</span>
            } else {
<span class="fc" id="L174">                logger.debug(&quot;SKipping {} nothing in map&quot;, w);</span>
            }
<span class="fc" id="L176">        }</span>
<span class="fc" id="L177">        return matches;</span>
    }

    /**
     * Size of this wildcard entry set
     */
    public int size() {
<span class="fc" id="L184">        load();</span>
<span class="fc" id="L185">        return this.wc.size();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>