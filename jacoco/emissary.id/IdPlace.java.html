<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IdPlace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.id</a> &gt; <span class="el_source">IdPlace.java</span></div><h1>IdPlace.java</h1><pre class="source lang-java linenums">package emissary.id;

import emissary.config.Configurator;
import emissary.core.Form;
import emissary.core.IBaseDataObject;
import emissary.place.ServiceProviderPlace;

import jakarta.annotation.Nullable;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.Map;
import java.util.Set;

/**
 * Abstract class that is the parent of all places that operate in the ID phase of the workflow.
 */
public abstract class IdPlace extends ServiceProviderPlace {
    /** Set of final id forms that do not add unknown on top */
    protected Set&lt;String&gt; finalForms;

    /* Forms to rename */
    protected Map&lt;String, String&gt; renames;

    /* Forms to ignore */
    protected Set&lt;String&gt; ignores;

    /**
     * Create and register an id place with all default config information
     */
    protected IdPlace() throws IOException {
<span class="fc" id="L33">        super();</span>
<span class="fc" id="L34">        configureIdPlace();</span>
<span class="fc" id="L35">    }</span>

    /**
     * Create an Id Place and register it at the location specified
     * 
     * @param placeLoc the location for registering this place
     */
    protected IdPlace(final String placeLoc) throws IOException {
<span class="nc" id="L43">        super(placeLoc);</span>
<span class="nc" id="L44">        configureIdPlace();</span>
<span class="nc" id="L45">    }</span>

    /**
     * Create and register constructor, called from the place by super(x,y,z)
     * 
     * @param configFile the config location file or resource
     * @param theDir controlling directory
     * @param thePlaceLocation key to use in registration
     */
    protected IdPlace(final String configFile, final String theDir, final String thePlaceLocation) throws IOException {
<span class="nc" id="L55">        super(configFile, theDir, thePlaceLocation);</span>
<span class="nc" id="L56">        configureIdPlace();</span>
<span class="nc" id="L57">    }</span>

    /**
     * Create and register with default directory
     * 
     * @param configFile the config location file or resource
     * @param placeLocation key to use in registration
     */
    protected IdPlace(final String configFile, final String placeLocation) throws IOException {
<span class="nc" id="L66">        super(configFile, placeLocation);</span>
<span class="nc" id="L67">        configureIdPlace();</span>
<span class="nc" id="L68">    }</span>

    /**
     * Create an id place with config data from a stream
     * 
     * @param configStream stream of config data
     * @param theDir string name of our directory
     * @param thePlaceLocation string name of our location
     */
    protected IdPlace(final InputStream configStream, final String theDir, final String thePlaceLocation) throws IOException {
<span class="nc" id="L78">        super(configStream, theDir, thePlaceLocation);</span>
<span class="nc" id="L79">    }</span>

    /**
     * Construct with config data from a stream on the local directory
     * 
     * @param configStream stream of config data
     */
    protected IdPlace(final InputStream configStream) throws IOException {
<span class="nc" id="L87">        super(configStream);</span>
<span class="nc" id="L88">    }</span>

    /**
     * Save a list of all the forms that this place is a service proxy for and a list of final id determinations that this
     * place can make so that any new form being set can be differentiated as final or non-final and the stacks cleaned up
     * appropriately
     * &lt;ul&gt;
     * &lt;li&gt;FINAL_ID - current form values that do not get UNKNOWN pushed on top&lt;/li&gt;
     * &lt;li&gt;ID_RENAME_ - current form values to rename&lt;/li&gt;
     * &lt;li&gt;ID_IGNORE - current form values to ignore&lt;/li&gt;
     * &lt;/ul&gt;
     */
    public void configureIdPlace() {
        // FINAL_ID should be a subset of SERVICE_PROXY
<span class="fc" id="L102">        this.finalForms = configG.findEntriesAsSet(&quot;FINAL_ID&quot;);</span>
<span class="fc" id="L103">        this.renames = configG.findStringMatchMap(&quot;ID_RENAME_&quot;, Configurator.PRESERVE_CASE);</span>
<span class="fc" id="L104">        this.ignores = configG.findEntriesAsSet(&quot;ID_IGNORE&quot;);</span>
<span class="fc" id="L105">    }</span>

    /**
     * Before setting a non-final current form, pop everything this place is s proxy for, then push the new form onto the
     * currentForm() stack, then push UNKNOWN on right after it (unless the newForm itself is UNKNOWN).
     */
    public int setNonFinalCurrentForm(final IBaseDataObject d, @Nullable final String newForm) {

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (this.ignores.contains(newForm)) {</span>
<span class="nc" id="L114">            return d.currentFormSize();</span>
        }

<span class="fc" id="L117">        final Set&lt;String&gt; serviceProxies = getProxies();</span>
<span class="pc bpc" id="L118" title="1 of 4 branches missed.">        while (serviceProxies.contains(d.currentForm()) || d.currentForm().equals(newForm)) {</span>
<span class="fc" id="L119">            d.popCurrentForm();</span>
        }

<span class="fc" id="L122">        int sz = 0;</span>

<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (newForm != null) {</span>
<span class="fc" id="L125">            sz = d.pushCurrentForm(renamedForm(newForm));</span>
        }

<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (!Form.UNKNOWN.equals(newForm)) {</span>
<span class="fc" id="L129">            sz = d.pushCurrentForm(Form.UNKNOWN);</span>
        }

<span class="fc" id="L132">        return sz;</span>
    }

    /**
     * Return the form renamed if it is listed as a RENAME_ID otherwise just return as-id
     * 
     * @param form the form to check
     * @return the renamed form
     */
    protected String renamedForm(final String form) {
<span class="fc" id="L142">        return this.renames.getOrDefault(form, form);</span>
    }

    /**
     * Before setting a final current form, pop everything this place is a proxy for, then push the new form onto both the
     * currentForm() and destination() stack.
     */
    public int setFinalCurrentForm(final IBaseDataObject d, final String newForm) {

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (this.ignores.contains(newForm)) {</span>
<span class="nc" id="L152">            return d.currentFormSize();</span>
        }

<span class="fc" id="L155">        final Set&lt;String&gt; serviceProxies = getProxies();</span>
<span class="fc" id="L156">        final String nf = renamedForm(newForm);</span>
<span class="pc bpc" id="L157" title="1 of 4 branches missed.">        while (serviceProxies.contains(d.currentForm()) || d.currentForm().equals(nf)) {</span>
<span class="fc" id="L158">            d.popCurrentForm();</span>
        }

<span class="fc" id="L161">        return d.pushCurrentForm(nf);</span>
    }


    /**
     * Set the current form after deciding if it's a FINAL_ID or not
     */
    public int setCurrentForm(final IBaseDataObject d, @Nullable final String newForm) {

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (this.ignores.contains(newForm)) {</span>
<span class="fc" id="L171">            return d.currentFormSize();</span>
        }

        final int sz;
<span class="pc bpc" id="L175" title="2 of 6 branches missed.">        if (newForm != null &amp;&amp; (this.finalForms.contains(newForm) || this.finalForms.contains(&quot;*&quot;))) {</span>
<span class="fc" id="L176">            sz = setFinalCurrentForm(d, newForm);</span>
        } else {
<span class="fc" id="L178">            sz = setNonFinalCurrentForm(d, newForm);</span>
        }

<span class="fc" id="L181">        return sz;</span>
    }

    /**
     * Set a whole bunch of new forms. The top one may or may not be a FINAL_ID, all others are FINAL_ID de facto so that
     * extraneous UNKNOWNs are not put on the stack
     */
    public int setCurrentForm(final IBaseDataObject d, @Nullable final Collection&lt;String&gt; newForms) {

        final int sz;
<span class="nc bnc" id="L191" title="All 4 branches missed.">        if (newForms == null || newForms.isEmpty()) {</span>
<span class="nc" id="L192">            sz = setNonFinalCurrentForm(d, null);</span>
        } else {
<span class="nc" id="L194">            final String[] forms = newForms.toArray(new String[0]);</span>
            // Set all the but top dog as final
<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (int i = forms.length - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L197">                setFinalCurrentForm(d, forms[i]);</span>
            }

            // Only decide between final/non-final on the top dog
<span class="nc" id="L201">            sz = setCurrentForm(d, forms[0]);</span>
        }

<span class="nc" id="L204">        return sz;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>