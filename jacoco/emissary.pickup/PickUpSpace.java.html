<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PickUpSpace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.pickup</a> &gt; <span class="el_source">PickUpSpace.java</span></div><h1>PickUpSpace.java</h1><pre class="source lang-java linenums">package emissary.pickup;

import emissary.server.mvc.adapters.WorkSpaceAdapter;

import jakarta.annotation.Nullable;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Implementation of a pick up place that talks to a one or more WorkSpace instances for obtaining distributed work.
 */
public abstract class PickUpSpace extends PickUpPlace implements IPickUpSpace {
    // List of workspace instances to interact with
<span class="pc" id="L19">    protected List&lt;String&gt; openSpaceNames = new ArrayList&lt;&gt;();</span>

    // Map of how many consecutive take errors by workspace name
<span class="pc" id="L22">    protected Map&lt;String, Integer&gt; numConsecutiveTakeErrors = new HashMap&lt;&gt;();</span>

    // Comms adapter
<span class="pc" id="L25">    protected WorkSpaceAdapter tpa = new WorkSpaceAdapter();</span>

    // Map of last bundle size by workspace name
<span class="pc" id="L28">    protected Map&lt;String, Integer&gt; lastBundleSize = new HashMap&lt;&gt;();</span>

    // Map of pending bundles to workspace name to facilitate replying
<span class="pc" id="L31">    protected Map&lt;String, String&gt; pendingBundles = new HashMap&lt;&gt;();</span>

    // Number of consecutive take errors that cause space to close
    protected static final int TAKE_ERROR_MAX = 10;

    /**
     * Create using default configuration
     */
    public PickUpSpace() throws IOException {
<span class="nc" id="L40">        super();</span>
<span class="nc" id="L41">    }</span>

    /**
     * Create one
     * 
     * @param configInfo path to config file
     * @param dir string key of the directory to register with
     * @param placeLocation string key of this place
     */
    public PickUpSpace(String configInfo, @Nullable String dir, String placeLocation) throws IOException {
<span class="nc" id="L51">        super(configInfo, dir, placeLocation);</span>
<span class="nc" id="L52">    }</span>

    /**
     * Create one, figuring out the directory automatically
     * 
     * @param configInfo path to config file
     * @param placeLocation string key of this place
     */
    public PickUpSpace(String configInfo, String placeLocation) throws IOException {
<span class="nc" id="L61">        this(configInfo, null, placeLocation);</span>
<span class="nc" id="L62">    }</span>

    public PickUpSpace(InputStream configInfo) throws IOException {
<span class="nc" id="L65">        super(configInfo);</span>
<span class="nc" id="L66">    }</span>

    /**
     * Create one with stream config
     * 
     * @param configStream path to config file
     * @param theDir string key of the directory to register with
     * @param thePlaceLocation string key of this place
     */
    public PickUpSpace(InputStream configStream, String theDir, String thePlaceLocation) throws IOException {
<span class="fc" id="L76">        super(configStream, theDir, thePlaceLocation);</span>
<span class="fc" id="L77">    }</span>

    /**
     * Open a TreeSpace when told and start asking it for data
     * 
     * @param spaceName the remote name of the space to open
     */
    @Override
    public void openSpace(String spaceName) {
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if (openSpaceNames.contains(spaceName)) {</span>
<span class="nc" id="L87">            logger.debug(&quot;Open spaces already includes &quot; + spaceName);</span>
        } else {
<span class="fc" id="L89">            openSpaceNames.add(spaceName);</span>
<span class="fc" id="L90">            numConsecutiveTakeErrors.put(spaceName, 0);</span>
<span class="fc" id="L91">            lastBundleSize.put(spaceName, 0);</span>
<span class="fc" id="L92">            logger.debug(&quot;Added space &quot; + spaceName + &quot; (&quot; + openSpaceNames.size() + &quot;)&quot;);</span>
        }
<span class="fc" id="L94">    }</span>

    /**
     * Close down the named workspace
     */
    @Override
    public void closeSpace(String spaceName) {
<span class="nc" id="L101">        logger.info(&quot;Closing down connection to &quot; + spaceName);</span>
<span class="nc" id="L102">        openSpaceNames.remove(spaceName);</span>
<span class="nc" id="L103">        lastBundleSize.remove(spaceName);</span>
<span class="nc" id="L104">        numConsecutiveTakeErrors.remove(spaceName);</span>
<span class="nc" id="L105">    }</span>

    /**
     * Return name of the first space on the list or null if none
     */

    @Override
    @Nullable
    public String getSpaceName() {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (!openSpaceNames.isEmpty()) {</span>
<span class="nc" id="L115">            return openSpaceNames.get(0);</span>
        } else {
<span class="nc" id="L117">            return null;</span>
        }
    }

    /**
     * Return the names of all the spaces on the list
     */
    @Override
    public List&lt;String&gt; getSpaceNames() {
<span class="fc" id="L126">        return new ArrayList&lt;&gt;(openSpaceNames);</span>
    }

    /**
     * Return the count of how many spaces are on the list
     */
    @Override
    public int getSpaceCount() {
<span class="fc" id="L134">        return openSpaceNames.size();</span>
    }

    /**
     * Take up to one item from eacho space that is active This can result in workspace instances being removed from the
     * list if we get a close message from one or if the threshold of consecutive errors is crossed
     * 
     * @return true if we got at least one
     */
    @Override
    public boolean take() {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (openSpaceNames.isEmpty()) {</span>
<span class="nc" id="L146">            logger.debug(&quot;Cannot perform 'take' when no spaces are available&quot;);</span>
<span class="nc" id="L147">            return false;</span>
        }

        // Keep track of space we may have to close
<span class="nc" id="L151">        List&lt;String&gt; closers = new ArrayList&lt;&gt;();</span>

        // We will take up to one bundle per workspace
<span class="nc" id="L154">        int countTaken = 0;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        for (String openSpaceName : openSpaceNames) {</span>
<span class="nc" id="L156">            WorkBundle path = null;</span>
            try {
<span class="nc" id="L158">                path = tpa.outboundWorkSpaceTake(openSpaceName, myKey);</span>
<span class="nc" id="L159">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L160">                logger.error(&quot;Failed to take work from &quot; + openSpaceName, ex);</span>
<span class="nc" id="L161">            }</span>

<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (path == null) {</span>
                // Error, record it, but might be transient
<span class="nc" id="L165">                logger.error(&quot;Got a null WorkBundle from &quot; + openSpaceName);</span>
<span class="nc" id="L166">                numConsecutiveTakeErrors.put(openSpaceName, numConsecutiveTakeErrors.get(openSpaceName) + 1);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            } else if (path.size() == 0) {</span>
                // Close out message
<span class="nc" id="L169">                closers.add(openSpaceName);</span>
            } else {
<span class="nc" id="L171">                logger.debug(&quot;Received bundle of &quot; + path.size() + &quot; from &quot; + openSpaceName);</span>
<span class="nc" id="L172">                lastBundleSize.put(openSpaceName, path.size());</span>
<span class="nc" id="L173">                numConsecutiveTakeErrors.put(openSpaceName, 0);</span>
<span class="nc" id="L174">                pendingBundles.put(path.getBundleId(), openSpaceName);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (!enque(path)) {</span>
<span class="nc" id="L176">                    logger.error(&quot;Unable to enqueue bundle &quot; + path.getBundleId() + &quot; from &quot; + openSpaceName + &quot;, losing it.&quot;);</span>
                }
<span class="nc" id="L178">                countTaken++;</span>
            }
<span class="nc" id="L180">        }</span>
<span class="nc" id="L181">        cleanupFailedSpaces(closers);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        return countTaken &gt; 0;</span>
    }

    /**
     * Clean up any spaces that have crosse the consecutive error message threshold and any that are specified in the
     * argument
     * 
     * @param forceClosers additional spaces to close
     */
    protected void cleanupFailedSpaces(List&lt;String&gt; forceClosers) {
<span class="nc" id="L192">        List&lt;String&gt; closers = new ArrayList&lt;&gt;(forceClosers);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        for (String s : openSpaceNames) {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (getNumConsecutiveTakeErrors(s) &gt; TAKE_ERROR_MAX) {</span>
<span class="nc" id="L195">                logger.error(&quot;Closing down space &quot; + s + &quot; due to repeated errors&quot;);</span>
<span class="nc" id="L196">                closers.add(s);</span>
            }
<span class="nc" id="L198">        }</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">        for (String s : closers) {</span>
<span class="nc" id="L201">            closeSpace(s);</span>
<span class="nc" id="L202">        }</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (!closers.isEmpty()) {</span>
<span class="nc" id="L205">            logger.debug(&quot;Cleaned up &quot; + closers.size() + &quot; workspace instances, &quot; + openSpaceNames.size() + &quot; remaining&quot;);</span>
        }
<span class="nc" id="L207">    }</span>

    /**
     * Notify controlling space that a bundle is completed
     * 
     * @param bundleId the bundle that was completed
     * @param itWorked true if bundle processed normally
     */
    @Override
    public void bundleCompleted(String bundleId, boolean itWorked) {
<span class="nc" id="L217">        String openSpaceName = pendingBundles.get(bundleId);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (openSpaceName == null) {</span>
<span class="nc" id="L219">            logger.debug(&quot;Space is gone before we could notify &quot; + &quot; bundle completion for &quot; + bundleId);</span>
        } else {
<span class="nc" id="L221">            pendingBundles.remove(bundleId);</span>
<span class="nc" id="L222">            tpa.outboundBundleCompletion(openSpaceName, myKey, bundleId, itWorked);</span>
        }
<span class="nc" id="L224">    }</span>

    /**
     * Count consecutive times a WorkSpace.take() made an error
     */
    @Override
    public int getNumConsecutiveTakeErrors(String spaceName) {
<span class="nc" id="L231">        return numConsecutiveTakeErrors.get(spaceName);</span>
    }

    /**
     * The size of the last WorkBundle successfully received
     */
    @Override
    public int getBundleSize(String spaceName) {
<span class="nc" id="L239">        return lastBundleSize.get(spaceName);</span>
    }

    /**
     * Put a new WorkBundle on the queue
     * 
     * @param path the newly arrived WorkBundle object
     */
    @Override
    public abstract boolean enque(WorkBundle path);

    /**
     * Get the available size of the queue
     */
    public abstract int getQueSize();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>