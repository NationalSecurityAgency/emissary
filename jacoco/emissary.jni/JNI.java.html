<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JNI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.jni</a> &gt; <span class="el_source">JNI.java</span></div><h1>JNI.java</h1><pre class="source lang-java linenums">package emissary.jni;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.core.EmissaryException;
import emissary.core.Namespace;
import emissary.core.NamespaceException;
import emissary.directory.DirectoryEntry;
import emissary.directory.DirectoryPlace;
import emissary.directory.IDirectoryPlace;
import emissary.directory.KeyManipulator;

import jakarta.annotation.Nullable;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.rmi.RemoteException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Provide methods for retrieving native libraries from the repository The main entry point is loadLibrary. Places
 * wishing to loadLibraries from the JniRepositoryPlace should include this class via composition and invoke
 * this.loadLibrary rather than System.loadLibrary()
 */
@SuppressWarnings(&quot;AvoidObjectArrays&quot;)
public class JNI implements Serializable {

    static final long serialVersionUID = 3037911106823343480L;

    /**
     * A handle to the DirectoryPlace
     */
    private transient IDirectoryPlace theDir;

    /**
     * The mappings for SharedPrefix on native libraries
     */
<span class="nc" id="L47">    private final Map&lt;String, String&gt; sharedPrefix = new HashMap&lt;&gt;();</span>

    /**
     * The mappings for SharedSuffixes on native libraries
     */
<span class="nc" id="L52">    private final Map&lt;String, String&gt; sharedSuffix = new HashMap&lt;&gt;();</span>

    /**
     * The mappings for the correct version of each native library
     */
<span class="nc" id="L57">    private final Map&lt;String, String&gt; libVersions = new HashMap&lt;&gt;();</span>

    /**
     * The location we all agree to save library files retrieved from the repository osname-dependently
     */
<span class="nc" id="L62">    private final Map&lt;String, String&gt; savePath = new HashMap&lt;&gt;();</span>

    /**
     * Handle to the configG gives access to the config file entries
     */
    private final Configurator configG;

<span class="nc" id="L69">    protected static final Logger logger = LoggerFactory.getLogger(JNI.class);</span>

    /**
     * Public constructor when used as a utility class
     */
<span class="nc" id="L74">    public JNI() throws IOException {</span>
<span class="nc" id="L75">        this.configG = ConfigUtil.getConfigInfo(JNI.class);</span>
<span class="nc" id="L76">        configurePlace();</span>
<span class="nc" id="L77">    }</span>

    /**
     * Public constructor args are easy when called from ServiceProviderPlace
     */
<span class="nc" id="L82">    public JNI(@Nullable final String theDir, final Configurator configG) {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (theDir != null) {</span>
            try {
<span class="nc" id="L85">                this.theDir = (IDirectoryPlace) Namespace.lookup(theDir);</span>
<span class="nc" id="L86">            } catch (NamespaceException ne) {</span>
<span class="nc" id="L87">                logger.debug(&quot;Cannot get directory using {}: {}&quot;, theDir, ne.getLocalizedMessage());</span>
<span class="nc" id="L88">            }</span>
        }

<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (this.theDir == null) {</span>
            try {
<span class="nc" id="L93">                this.theDir = DirectoryPlace.lookup();</span>
<span class="nc" id="L94">            } catch (EmissaryException ex) {</span>
<span class="nc" id="L95">                logger.debug(&quot;Unable to lookup default directory&quot;, ex);</span>
<span class="nc" id="L96">            }</span>
        }

<span class="nc" id="L99">        this.configG = configG;</span>
<span class="nc" id="L100">        configurePlace();</span>
<span class="nc" id="L101">    }</span>

    /**
     * Configure the place based on the current {@link #configG} setting.
     */
    private void configurePlace() {

<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (this.configG == null) {</span>
<span class="nc" id="L109">            return;</span>
        }

<span class="nc" id="L112">        List&lt;String&gt; parms = this.configG.findEntries(&quot;SHARED_PREFIX&quot;);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        for (final String entry : parms) {</span>
<span class="nc" id="L114">            final int ndx = entry.indexOf(':');</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (ndx == -1) {</span>
<span class="nc" id="L116">                logger.warn(&quot;Invalid SHARED_PREFIX: {}&quot;, entry);</span>
<span class="nc" id="L117">                continue;</span>
            }

<span class="nc" id="L120">            final String arch = entry.substring(0, ndx);</span>
<span class="nc" id="L121">            String prefix = &quot;&quot;;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (ndx &lt; entry.length() - 1) {</span>
<span class="nc" id="L123">                prefix = entry.substring(ndx + 1);</span>
            }

<span class="nc" id="L126">            this.sharedPrefix.put(arch, prefix);</span>

            // Get the osname-dependent SAVE_PATH
<span class="nc" id="L129">            final List&lt;String&gt; iparms = this.configG.findEntries(arch + &quot;_LIBRARY_SAVE_PATH&quot;);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (CollectionUtils.isNotEmpty(iparms)) {</span>
<span class="nc" id="L131">                this.savePath.put(arch, iparms.get(0));</span>
            }
<span class="nc" id="L133">        }</span>

<span class="nc" id="L135">        parms = this.configG.findEntries(&quot;SHARED_SUFFIX&quot;);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        for (final String entry : parms) {</span>
<span class="nc" id="L137">            final int ndx = entry.indexOf(':');</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (ndx == -1) {</span>
<span class="nc" id="L139">                logger.warn(&quot;Invalid SHARED_SUFFIX: {}&quot;, entry);</span>
<span class="nc" id="L140">                continue;</span>
            }

<span class="nc" id="L143">            final String arch = entry.substring(0, ndx);</span>
<span class="nc" id="L144">            String suffix = &quot;&quot;;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (ndx &lt; entry.length() - 1) {</span>
<span class="nc" id="L146">                suffix = entry.substring(ndx + 1);</span>
            }
<span class="nc" id="L148">            this.sharedSuffix.put(arch, suffix);</span>
<span class="nc" id="L149">        }</span>

<span class="nc" id="L151">        parms = this.configG.findEntries(&quot;LIBRARY_VERSION&quot;);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        for (final String entry : parms) {</span>
<span class="nc" id="L153">            final int ndx = entry.indexOf(':');</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (ndx == -1) {</span>
<span class="nc" id="L155">                logger.warn(&quot;Invalid LIBRARY_VERSION: {}&quot;, entry);</span>
<span class="nc" id="L156">                continue;</span>
            }

<span class="nc" id="L159">            final String lib = entry.substring(0, ndx);</span>
<span class="nc" id="L160">            String ver = &quot;&quot;;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if (ndx &lt; entry.length() - 1) {</span>
<span class="nc" id="L162">                ver = entry.substring(ndx + 1);</span>
            }
<span class="nc" id="L164">            this.libVersions.put(lib, ver);</span>
<span class="nc" id="L165">        }</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L168">            logger.debug(&quot;JNI config save paths {}&quot;, this.savePath);</span>
<span class="nc" id="L169">            logger.debug(&quot;JNI config prefixes {}&quot;, this.sharedPrefix);</span>
<span class="nc" id="L170">            logger.debug(&quot;JNI config suffixes {}&quot;, this.sharedSuffix);</span>
<span class="nc" id="L171">            logger.debug(&quot;JNI config versions {}&quot;, this.libVersions);</span>
        }
<span class="nc" id="L173">    }</span>

    /**
     * Expand the root name of the library by the architecture and version constants.
     */
    private String expandLibraryName(final String name) {
<span class="nc" id="L179">        final String osarch = System.getProperty(&quot;os.arch&quot;).replace(' ', '_');</span>
<span class="nc" id="L180">        final String osname = System.getProperty(&quot;os.name&quot;).replace(' ', '_');</span>
        // String osver = System.getProperty(&quot;os.version&quot;).replace(' ','_');
<span class="nc" id="L182">        String libver = this.libVersions.get(name);</span>
<span class="nc" id="L183">        final String sep = &quot;-&quot;;</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (libver == null) {</span>
<span class="nc" id="L186">            libver = &quot;1.0&quot;;</span>
        }

<span class="nc" id="L189">        return name + sep + // foo-</span>
                osname + sep + // Solaris-
                osarch + sep + // sparc-
                // osver+sep+ // 2.x-
                libver; // v3.2
    }

    /**
     * Expand the full library name with the way it is stored in the file system. This method expects something like
     * foo-Solaris-sparc-2.x-v3.2 and returns libfoo-Solaris-sparc-2.x-v3.2.so
     */
    private String filesystemLibraryName(final String name) {
<span class="nc" id="L201">        final String osname = System.getProperty(&quot;os.name&quot;).replace(' ', '_');</span>
<span class="nc" id="L202">        String prefix = this.sharedPrefix.get(osname);</span>
<span class="nc" id="L203">        String suffix = this.sharedSuffix.get(osname);</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L206">            prefix = &quot;&quot;;</span>
        }

<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (suffix == null) {</span>
<span class="nc" id="L210">            suffix = &quot;&quot;;</span>
        }

<span class="nc" id="L213">        return prefix + name + suffix;</span>
    }

    /**
     * Load a native library, finding it if it isn't already here. First try to load the library and catch any exception.
     * Try to ask the directory place where the JniRepositoryPlace is and see if the repository has the library we are
     * looking for. If it comes back, save it to disk in the agreed upon location and then load it in the regular way. Throw
     * an UnsatisfiedLinkError if this doesn't work.
     * &lt;p&gt;
     * Note that System.loadLibrary expects the name as it comes back from expandLibraryName while the repository will
     * respond to the name as it comes from filesystemLibraryName.
     *
     * @throws UnsatisfiedLinkError If it fails to load.
     */
    public void loadLibrary(final String lib) {

<span class="nc" id="L229">        final String libname = expandLibraryName(lib);</span>
<span class="nc" id="L230">        final String filename = filesystemLibraryName(libname);</span>
<span class="nc" id="L231">        final String osname = System.getProperty(&quot;os.name&quot;).replace(' ', '_');</span>
<span class="nc" id="L232">        final String theLocation = this.savePath.get(osname);</span>
<span class="nc" id="L233">        final String fullPathName = theLocation + File.separator + filename;</span>

<span class="nc" id="L235">        logger.debug(&quot;In JNI.loadLibrary({})&quot;, lib);</span>
<span class="nc" id="L236">        logger.debug(&quot;loading library: {}&quot;, libname);</span>

        // Try it on the LD_LIBRARY_PATH or equivalent
        try {
<span class="nc" id="L240">            System.loadLibrary(libname);</span>
<span class="nc" id="L241">            return;</span>
<span class="nc" id="L242">        } catch (UnsatisfiedLinkError e) {</span>
<span class="nc" id="L243">            final String syspath = System.getProperty(&quot;java.library.path&quot;, &quot;&lt;none&gt;&quot;);</span>
<span class="nc" id="L244">            logger.debug(&quot;Unable to link local {} from incoming {} using system path {}&quot;, libname, lib, syspath, e);</span>
        }


        // Try it in the save area, in case it's not on the LD_LIBRARY_PATH
        try {
<span class="nc" id="L250">            System.load(fullPathName);</span>
<span class="nc" id="L251">            return;</span>
<span class="nc" id="L252">        } catch (UnsatisfiedLinkError e) {</span>
<span class="nc" id="L253">            logger.debug(&quot;Unable to link abs path {} from incoming {}&quot;, fullPathName, lib, e);</span>
        }

        // Retrieve the File and dependencies.
        // errorMsg valid only when return is false
<span class="nc" id="L258">        final String[] errorMsg = new String[1];</span>

        // Retrieve everything listed as a dependency of the requested library.
        // If the library was obtained via System.loadLibrary() or System.load()
        // above then we assume this has already been done (by a previous
        // incantation of this routine) and not needed again. Note there is
        // therefor NO versioning capability of the dependent libraries without
        // jacking the version number for the actual library being requested.
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (!retrieveDependencies(lib, errorMsg)) {</span>
<span class="nc" id="L267">            logger.debug(&quot;Unable to retrieve dependencies:{}&quot;, errorMsg[0]);</span>
<span class="nc" id="L268">            throw new UnsatisfiedLinkError(&quot;Unable to retrieve dependencies for &quot; + filename + &quot; : &quot; + errorMsg[0]);</span>
        }

<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (!retrieveFile(filename, errorMsg)) {</span>
<span class="nc" id="L272">            logger.debug(&quot;Unable to retrieve:{}&quot;, errorMsg[0]);</span>
<span class="nc" id="L273">            throw new UnsatisfiedLinkError(&quot;Unable to retrieve &quot; + filename + &quot; : &quot; + errorMsg[0]);</span>
        }

        // Loadlib the file we just retrieved and saved
        try {
<span class="nc" id="L278">            System.load(fullPathName);</span>
<span class="nc" id="L279">            logger.debug(&quot;LINK SUCCESS for {}&quot;, fullPathName);</span>
<span class="nc" id="L280">        } catch (UnsatisfiedLinkError e) {</span>
<span class="nc" id="L281">            logger.debug(&quot;Unable to link retrieved {}:{}&quot;, fullPathName, e.getLocalizedMessage());</span>

            // We have done all we can. Throw an exception and return
<span class="nc" id="L284">            throw new UnsatisfiedLinkError(&quot;Cannot link with retrieved library &quot; + fullPathName + &quot;:&quot; + e);</span>
<span class="nc" id="L285">        }</span>
<span class="nc" id="L286">    }</span>

    /**
     * Retrieve all the dependencies of a given library. For example if the incoming libname is foo, then the full path of
     * the lib might be libfoo-Solaris-:-2.x-v1.2.so and the dependencies would be listed in the config file as DEP_foo =
     * &quot;libdep1.so&quot; DEP_foo = &quot;libdep2.so&quot;
     */
    private boolean retrieveDependencies(final String libname, final String[] errmsg) {
<span class="nc" id="L294">        final List&lt;String&gt; deps = this.configG.findEntries(&quot;DEP_&quot; + libname);</span>

        // See if anything needs to be retrieved
<span class="nc bnc" id="L297" title="All 4 branches missed.">        if ((deps == null) || deps.isEmpty()) {</span>
<span class="nc" id="L298">            return true;</span>
        }

        // Use this string on error
<span class="nc" id="L302">        final String myErr = libname + &quot; dependencies are &quot; + deps;</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">        for (final String file : deps) {</span>
<span class="nc" id="L305">            logger.debug(&quot;JNI: Retrieving dependent file {}&quot;, file);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!retrieveFile(file, errmsg)) {</span>
<span class="nc" id="L307">                errmsg[0] = myErr + &quot;: failed on &quot; + file;</span>
<span class="nc" id="L308">                return false;</span>
            }
<span class="nc" id="L310">        }</span>
<span class="nc" id="L311">        return true;</span>
    }

    /**
     * Actually retrieve the byteStream of the native library over the network and save it to a diskfile.
     */
    public boolean retrieveFile(final String filename, final String[] errmsg) {

<span class="nc" id="L319">        final String osname = System.getProperty(&quot;os.name&quot;).replace(' ', '_');</span>
<span class="nc" id="L320">        final String theLocation = this.savePath.get(osname);</span>
<span class="nc" id="L321">        final String fullPathName = theLocation + File.separator + filename;</span>
<span class="nc" id="L322">        final byte[] libContents = returnFile(filename, errmsg);</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (libContents == null) {</span>
<span class="nc" id="L325">            return false;</span>
        }

        // Save the contents into the disk file
<span class="nc" id="L329">        try (FileOutputStream fos = new FileOutputStream(fullPathName);</span>
<span class="nc" id="L330">                BufferedOutputStream bos = new BufferedOutputStream(fos)) {</span>
<span class="nc" id="L331">            bos.write(libContents, 0, libContents.length);</span>
<span class="nc" id="L332">        } catch (IOException ioe) {</span>
<span class="nc" id="L333">            errmsg[0] = &quot;Cannot write retrieved JNI library to &quot; + fullPathName + &quot;: &quot; + ioe;</span>
<span class="nc" id="L334">            return false;</span>
<span class="nc" id="L335">        }</span>

<span class="nc" id="L337">        return true;</span>
    }

    /**
     * Look up the repository using our directory and retrieve the bytestream over the network with a synchronous call.
     */
    @Nullable
    public byte[] returnFile(final String filename, final String[] errmsg) {

<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (this.theDir == null) {</span>
            // Probably instantiated from a static main standalone constructor
            // which should have called returnFile(String,String[],String)
            // instead and specified the key
<span class="nc" id="L350">            errmsg[0] = &quot;No DirectoryPlace available&quot;;</span>
<span class="nc" id="L351">            return null;</span>
        }

        try {
<span class="nc" id="L355">            final List&lt;DirectoryEntry&gt; entries = this.theDir.nextKeys(&quot;JNI&quot;, null, null);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (CollectionUtils.isEmpty(entries)) {</span>
<span class="nc" id="L357">                errmsg[0] = &quot;No JNI place in directory for:&quot; + filename;</span>
<span class="nc" id="L358">                return null;</span>
            }

            // Just use the first one
<span class="nc" id="L362">            final DirectoryEntry entry = entries.get(0);</span>
<span class="nc" id="L363">            String repositoryKey = entry.getKey();</span>

            // No related place, try a bootstrapping repository
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (repositoryKey == null) {</span>
<span class="nc" id="L367">                repositoryKey = System.getProperty(&quot;emissary.repository&quot;);</span>
            }

            // No repository at all. Bail out
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (repositoryKey == null) {</span>
<span class="nc" id="L372">                errmsg[0] = &quot;JNI.returnFile: cannot retrieve files &quot; + &quot;without a repository.&quot;;</span>
<span class="nc" id="L373">                return null;</span>
            }

            // We have a repository of some sort, try using it
<span class="nc" id="L377">            return returnFile(filename, errmsg, repositoryKey);</span>

<span class="nc" id="L379">        } catch (RuntimeException ve) {</span>
<span class="nc" id="L380">            errmsg[0] = &quot;JNI.returnFile: &quot; + ve;</span>
<span class="nc" id="L381">            return null;</span>
        }
    }

    /**
     * Retrieve from the Repository with the specified Key. Can be used for bootstrapping when config files for directories
     * and Repositories might not exist. A non-related repository can be specified in this case and the system will
     * bootstrap from it.
     */
    @Nullable
    public byte[] returnFile(final String filename, final String[] errmsg, final String repositoryKey) {

<span class="nc" id="L393">        final String repositoryAddrString = KeyManipulator.getServiceLocation(repositoryKey);</span>

        IJniRepositoryPlace repositoryProxy;

        try {
<span class="nc" id="L398">            final String look = repositoryAddrString.substring(repositoryAddrString.indexOf(&quot;//&quot;));</span>

<span class="nc" id="L400">            repositoryProxy = (IJniRepositoryPlace) Namespace.lookup(look);</span>
<span class="nc" id="L401">        } catch (NamespaceException | RuntimeException e) {</span>
<span class="nc" id="L402">            errmsg[0] = &quot;JNI.returnFile: &quot; + e;</span>
<span class="nc" id="L403">            return null;</span>
<span class="nc" id="L404">        }</span>

        // Ask the repository to send the byte stream of the native
        // library contents
        final byte[] libContents;
        try {
<span class="nc" id="L410">            libContents = repositoryProxy.nativeLibraryDeliver(filename);</span>
<span class="nc" id="L411">        } catch (RemoteException | RuntimeException e) {</span>
<span class="nc" id="L412">            errmsg[0] = &quot;Error calling nativeLibraryDeliver: &quot; + e;</span>
<span class="nc" id="L413">            return null;</span>
<span class="nc" id="L414">        }</span>

<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (libContents == null) {</span>
<span class="nc" id="L417">            errmsg[0] = &quot;Unsuccessful request to repository: &quot; + &quot;got zero bytes&quot;;</span>
        }

<span class="nc" id="L420">        return libContents;</span>
    }

    /**
     * Provide access to this OS's default save path
     */
    public String getSavePath() {
<span class="nc" id="L427">        final String osname = System.getProperty(&quot;os.name&quot;).replace(' ', '_');</span>
<span class="nc" id="L428">        return this.savePath.get(osname);</span>
    }

    /**
     * Provide access to the remote file timestamp
     */
    public long lastModified(final String filename, final String[] errmsg, final String repositoryKey) {

<span class="nc" id="L436">        long stamp = 0L;</span>

<span class="nc" id="L438">        String repositoryAddrString = KeyManipulator.getServiceLocation(repositoryKey);</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (StringUtils.contains(repositoryAddrString, &quot;//&quot;)) {</span>
<span class="nc" id="L441">            repositoryAddrString = repositoryAddrString.substring(repositoryAddrString.indexOf(&quot;//&quot;));</span>
        }

        IJniRepositoryPlace repositoryProxy;

        try {
<span class="nc" id="L447">            repositoryProxy = (IJniRepositoryPlace) Namespace.lookup(repositoryAddrString);</span>
<span class="nc" id="L448">        } catch (NamespaceException ne) {</span>
<span class="nc" id="L449">            errmsg[0] = &quot;JNI.returnFile: &quot; + ne;</span>
<span class="nc" id="L450">            return stamp;</span>
<span class="nc" id="L451">        }</span>

        // Ask the repository to send the timestamp

        try {
<span class="nc" id="L456">            stamp = repositoryProxy.lastModified(filename);</span>
<span class="nc" id="L457">        } catch (RuntimeException e) {</span>
<span class="nc" id="L458">            errmsg[0] = &quot;Error calling lastModified: &quot; + e;</span>
<span class="nc" id="L459">        }</span>

<span class="nc" id="L461">        return stamp;</span>
    }

    /**
     * Static main used from Makefiles to produce the correct expanded name of the library. Guaranteed to match when the
     * calling program asks for it via the repository mechanism
     */
    public static void main(final String[] args) throws IOException {

<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (args.length &lt; 1) {</span>
<span class="nc" id="L471">            logger.info(&quot;usage: java JNI [-L LEVEL] libname&quot;);</span>
<span class="nc" id="L472">            return;</span>
        }

<span class="nc" id="L475">        int argpos = 0;</span>
<span class="nc bnc" id="L476" title="All 4 branches missed.">        while ((argpos &lt; args.length) &amp;&amp; args[argpos].startsWith(&quot;-&quot;)) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (&quot;--&quot;.equals(args[argpos])) {</span>
<span class="nc" id="L478">                argpos++;</span>
<span class="nc" id="L479">                break;</span>
            }
        }

<span class="nc" id="L483">        final JNI jni = new JNI();</span>
<span class="nc" id="L484">        String path = jni.getSavePath();</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">        if (path != null &amp;&amp; !path.endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L486">            path += &quot;/&quot;;</span>
        }
<span class="nc bnc" id="L488" title="All 2 branches missed.">        for (int i = argpos; i &lt; args.length; i++) {</span>
<span class="nc" id="L489">            logger.info(&quot;{}{}&quot;, path, jni.filesystemLibraryName(jni.expandLibraryName(args[i])));</span>
        }
<span class="nc" id="L491">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>