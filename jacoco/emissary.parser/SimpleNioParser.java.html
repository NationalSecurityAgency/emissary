<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleNioParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.parser</a> &gt; <span class="el_source">SimpleNioParser.java</span></div><h1>SimpleNioParser.java</h1><pre class="source lang-java linenums">package emissary.parser;

import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * A very simple minded parser implementation that assumes each input channel is one session. This parser has no idea
 * about headers and footers, just the basic session and not much of an idea about that.
 */
public class SimpleNioParser extends NIOSessionParser {

<span class="fc" id="L21">    private final static Logger logger = LoggerFactory.getLogger(SimpleNioParser.class);</span>

<span class="fc" id="L23">    protected int currentSessionIndex = 0;</span>

    /**
     * Create a session parser on the data
     */
    @SuppressWarnings(&quot;CheckedExceptionNotThrown&quot;)
    public SimpleNioParser(SeekableByteChannel channel) throws ParserException {
<span class="fc" id="L30">        super(channel);</span>
<span class="fc" id="L31">    }</span>

    /**
     * Creates a hashtable of elements from the session: header, footer, body, and other meta data values extracted from the
     * session data.
     *
     * @param session The session to be decomposed into separate elements.
     * @return A map of session elements
     */
    protected DecomposedSession decomposeSession(@Nullable InputSession session) throws ParserException {
        try {
<span class="fc" id="L42">            DecomposedSession d = new DecomposedSession();</span>
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">            if (session != null) {</span>

<span class="fc" id="L45">                d.setHeader(makeDataSlice(session.getHeader()));</span>

<span class="fc" id="L47">                d.setFooter(makeDataSlice(session.getFooter()));</span>

<span class="fc" id="L49">                d.setData(makeDataSlice(session.getData()));</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">                long length = d.getData() == null ? -1L : d.getData().length;</span>

                // Cook the raw metadata and transfer to DecomposedSession
<span class="fc" id="L53">                Map&lt;String, Object&gt; md = session.getMetaData();</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">                if (md != null) {</span>
<span class="fc" id="L55">                    Map&lt;String, String&gt; cooked = cookMetaRecords(md);</span>
<span class="fc" id="L56">                    d.setMetaData(new HashMap&lt;&gt;()); // clear</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">                    for (Map.Entry&lt;String, String&gt; entry : cooked.entrySet()) {</span>
<span class="nc" id="L58">                        d.addMetaData(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L59">                    }</span>
                }

                // Use session length if no data length
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">                if (length &lt; 0) {</span>
<span class="nc" id="L64">                    length = session.getLength();</span>
                }
<span class="fc" id="L66">                d.addMetaData(ORIG_DOC_SIZE_KEY, Long.toString(length));</span>
            }
<span class="fc" id="L68">            return d;</span>
<span class="nc" id="L69">        } catch (IOException ex) {</span>
<span class="nc" id="L70">            throw new ParserException(&quot;Error while building DecomposedSession&quot;, ex);</span>
        }
    }

    /**
     * Turn the metadata PositionRecord elements into real data
     *
     * @param raw map of PositionRecord objects
     * @return map of metadata
     */
    protected Map&lt;String, String&gt; cookMetaRecords(Map&lt;String, Object&gt; raw) throws IOException {

<span class="fc" id="L82">        Map&lt;String, String&gt; cooked = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : raw.entrySet()) {</span>
<span class="nc" id="L84">            String key = entry.getKey();</span>
<span class="nc" id="L85">            Object tmp = entry.getValue();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            if (tmp != null) {</span>
                String value;
<span class="nc bnc" id="L88" title="All 2 branches missed.">                if (tmp instanceof PositionRecord) {</span>
<span class="nc" id="L89">                    value = new String(makeDataSlice((PositionRecord) tmp)).trim();</span>
                } else {
<span class="nc" id="L91">                    value = tmp.toString();</span>
                }
<span class="nc" id="L93">                String name = renameMetadataRecord(key);</span>
<span class="nc" id="L94">                cooked.put(name, value);</span>
            }
<span class="nc" id="L96">        }</span>
<span class="fc" id="L97">        return cooked;</span>
    }

    /**
     * Allow subclasses to arbitrarily rename metadata fields This is a do nothing function in the base class.
     *
     * @param s the name of the field to consider renaming
     * @return the renamed field or the original name if no change
     */
    protected String renameMetadataRecord(String s) {
<span class="nc" id="L107">        return s;</span>
    }

    /**
     * Possible help to debug this factory mess
     * 
     * @return string representation
     */
    @Override
    public String toString() {
<span class="nc" id="L117">        return SimpleNioParser.class.getName() + &quot; isa&quot; + this.getClass().getName();</span>
    }

    /**
     * Creates a hashtable of elements from the session: header, footer, body, and other meta data values extracted from the
     * session data for the next session in the data. This Simple base implementation only treats the whole file as one
     * session
     * 
     * @return next session
     */
    @Override
    public DecomposedSession getNextSession() throws ParserException {
        try {
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (isFullyParsed()) {</span>
<span class="fc" id="L131">                throw new ParserEOFException(&quot;Past end of data&quot;);</span>
            }

<span class="fc" id="L134">            long csize = channel.size();</span>

<span class="fc" id="L136">            InputSession i = new InputSession(new PositionRecord(0, csize), // overall record</span>
                    new PositionRecord(0, csize)); // data record
<span class="fc" id="L138">            i.setValid(true);</span>
<span class="fc" id="L139">            setFullyParsed(true);</span>
<span class="fc" id="L140">            return decomposeSession(i);</span>
<span class="nc" id="L141">        } catch (IOException ex) {</span>
<span class="nc" id="L142">            throw new ParserException(&quot;Exception occurred reading channel&quot;, ex);</span>
        }
    }

    /**
     * Slice data from a buffer based on a single position record
     *
     * @param r the position record indicating absolute offsets
     */
    byte[] makeDataSlice(PositionRecord r) throws IOException {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (r.getLength() &gt; MAX_ARRAY_SIZE_LONG) {</span>
<span class="nc" id="L153">            throw new IllegalStateException(&quot;Implementation currently only handles up to Intger.MAX_VALUE lengths&quot;);</span>
        }
<span class="fc" id="L155">        int len = (int) r.getLength();</span>
<span class="fc" id="L156">        ByteBuffer n = ByteBuffer.allocate(len);</span>

        try {
<span class="fc" id="L159">            channel.position(r.getPosition());</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            while (n.hasRemaining()) {</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">                if (channel.read(n) == -1) {</span>
<span class="nc" id="L162">                    channel.close();</span>
<span class="nc" id="L163">                    break;</span>
                }
            }
<span class="nc" id="L166">        } catch (BufferUnderflowException ex) {</span>
<span class="nc" id="L167">            logger.warn(&quot;Underflow getting {} bytes at {}&quot;, n.capacity(), r.getPosition());</span>
<span class="fc" id="L168">        }</span>
<span class="fc" id="L169">        return n.array();</span>
    }

    /**
     * Slice data from a buffer based on a single position record
     *
     * @param records the list of position records indicating absolute offsets
     */
    @Nullable
    byte[] makeDataSlice(@Nullable List&lt;PositionRecord&gt; records) throws IOException {
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">        if (records == null || records.isEmpty()) {</span>
<span class="fc" id="L180">            return null;</span>
        }
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if (records.size() == 1) {</span>
<span class="fc" id="L183">            return makeDataSlice(records.get(0));</span>
        }

<span class="nc" id="L186">        int total = 0;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        for (PositionRecord r : records) {</span>
<span class="nc" id="L188">            total += (int) r.getLength();</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">            if (total &gt; MAX_ARRAY_SIZE || total &lt; 0) {</span>
<span class="nc" id="L190">                throw new IllegalStateException(&quot;This implementation cannot create data larger than &quot; + MAX_ARRAY_SIZE);</span>
            }
<span class="nc" id="L192">        }</span>

<span class="nc" id="L194">        ByteBuffer n = ByteBuffer.allocate(total);</span>
<span class="nc" id="L195">        int limit = 0;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        for (PositionRecord r : records) {</span>
<span class="nc" id="L197">            channel.position(r.getPosition());</span>
<span class="nc" id="L198">            limit += (int) r.getLength();</span>
<span class="nc" id="L199">            n.limit(limit);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            while (n.hasRemaining()) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (channel.read(n) == -1) {</span>
<span class="nc" id="L202">                    channel.close();</span>
<span class="nc" id="L203">                    break;</span>
                }
            }
<span class="nc" id="L206">        }</span>

<span class="nc" id="L208">        return n.array();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>