<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Executrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util.shell</a> &gt; <span class="el_source">Executrix.java</span></div><h1>Executrix.java</h1><pre class="source lang-java linenums">package emissary.util.shell;

import emissary.config.Configurator;
import emissary.config.ServiceConfigGuide;
import emissary.directory.KeyManipulator;
import emissary.util.io.FileManipulator;

import com.google.common.primitives.Ints;
import jakarta.annotation.Nullable;
import org.apache.commons.exec.ExecuteWatchdog;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.SystemUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Map;

import static emissary.core.constants.Configurations.PLACE_NAME;
import static emissary.core.constants.Configurations.SERVICE_KEY;

/**
 * This class wraps up things related to exec-ing of external processes and reading and writing disk files.
 */
@SuppressWarnings(&quot;AvoidObjectArrays&quot;)
public class Executrix {
<span class="fc" id="L42">    private static final Logger logger = LoggerFactory.getLogger(Executrix.class);</span>

    private static final int DEFAULT_VM_SIZE_LIMIT = 200000;
    private static final int DEFAULT_CPU_TIME_LIMIT = 300;
    private static final long DEFAULT_PROCESS_MAX_MILLIS = 300 * 1000L; // 5 min

<span class="fc" id="L48">    public enum OUTPUT_TYPE {</span>
<span class="fc" id="L49">        STD, FILE</span>
    }

    protected String command;
    protected String inFileEnding;
    protected String outFileEnding;
    protected String output;
    protected String order;
    protected String numArgs;
    protected String tmpDir;
    protected File tmpDirFile;
    protected int minimumDataSize;
    protected int maximumDataSize;
    protected String placeName;
    protected int vmSizeLimit;
    protected int cpuTimeLimit;
    protected long processMaxMillis;

    // Pieces and parts of file and path names
    public static final int DIR = 0;
    public static final int BASE = 1;
    public static final int BASE_PATH = 2;
    public static final int IN = 3;
    public static final int OUT = 4;
    public static final int INPATH = 5;
    public static final int OUTPATH = 6;

    /**
     * Create using all defaults
     */
<span class="fc" id="L79">    public Executrix() {</span>
<span class="fc" id="L80">        configure(null);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Create configuring from config source
     * 
     * @param configG the configuration items to use
     */
<span class="fc" id="L88">    public Executrix(final Configurator configG) {</span>
<span class="fc" id="L89">        configure(configG);</span>
<span class="fc" id="L90">    }</span>

    /**
     * Configure all the extra command stuff along with the normal config Config Items read here are:
     * 
     * &lt;ul&gt;
     * &lt;li&gt;EXEC_COMMAND: the command to execute&lt;/li&gt;
     * &lt;li&gt;IN_FILE_ENDING: extension of input file, default is none&lt;/li&gt;
     * &lt;li&gt;OUT_FILE_ENDING: extension of output file, default is .out if input extension is blank, none otherwise&lt;/li&gt;
     * &lt;li&gt;OUTPUT_TYPE: FILE or STD for where the output of EXEC_COMMAND goes, default STD&lt;/li&gt;
     * &lt;li&gt;ORDER: default is NORMAL&lt;/li&gt;
     * &lt;li&gt;NUM_ARGS: obsolete&lt;/li&gt;
     * &lt;li&gt;TEMP_DIR: default is java.io.tmpdir&lt;/li&gt;
     * &lt;li&gt;MINIMUM_DATA_SIZE: default is 0&lt;/li&gt;
     * &lt;li&gt;MAXIMUM_DATA_SIZE: default is 64*1024&lt;/li&gt;
     * &lt;li&gt;PLACE_NAME: also required by places in general&lt;/li&gt;
     * &lt;li&gt;VM_SIZE_LIMIT: default is 200000 for ulimit argument&lt;/li&gt;
     * &lt;li&gt;CPU_TIME_LIMIT: default is 300 seconds for ulimit argument&lt;/li&gt;
     * &lt;li&gt;PROCESS_MAX_MILLIS: default is 300000 (5 Min) for process Watchdog. Set to 0 to disable watchdog use&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param configGArg the configuration stream
     */
    protected void configure(@Nullable final Configurator configGArg) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        final Configurator configG = (configGArg != null) ? configGArg : new ServiceConfigGuide();</span>

<span class="fc" id="L116">        this.command = configG.findStringEntry(&quot;EXEC_COMMAND&quot;, &quot;echo 'YouForGotToSetEXEC_COMMAND' | tee bla.txt&quot;);</span>
<span class="fc" id="L117">        this.inFileEnding = configG.findStringEntry(&quot;IN_FILE_ENDING&quot;, &quot;&quot;);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        this.outFileEnding = configG.findStringEntry(&quot;OUT_FILE_ENDING&quot;, this.inFileEnding.isEmpty() ? &quot;.out&quot; : &quot;&quot;);</span>
<span class="fc" id="L119">        this.output = configG.findStringEntry(&quot;OUTPUT_TYPE&quot;, &quot;STD&quot;);</span>
<span class="fc" id="L120">        this.order = configG.findStringEntry(&quot;ORDER&quot;, &quot;NORMAL&quot;);</span>
<span class="fc" id="L121">        this.numArgs = configG.findStringEntry(&quot;NUM_ARGS&quot;, &quot;&quot;);</span>
<span class="fc" id="L122">        this.tmpDir = configG.findStringEntry(&quot;TEMP_DIR&quot;, System.getProperty(&quot;java.io.tmpdir&quot;, &quot;/tmp&quot;));</span>
<span class="fc" id="L123">        this.tmpDirFile = new File(this.tmpDir);</span>
<span class="fc" id="L124">        this.minimumDataSize = configG.findIntEntry(&quot;MINIMUM_DATA_SIZE&quot;, 0);</span>
<span class="fc" id="L125">        this.maximumDataSize = configG.findIntEntry(&quot;MAXIMUM_DATA_SIZE&quot;, 64 * 1024);</span>
<span class="fc" id="L126">        this.placeName = configG.findStringEntry(PLACE_NAME, null);</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (this.placeName == null) {</span>
<span class="fc" id="L128">            final String key = configG.findStringEntry(SERVICE_KEY, null);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            this.placeName = key == null ? &quot;UNKNOWN&quot; : KeyManipulator.getServiceName(key);</span>
        }
<span class="fc" id="L131">        this.placeName = this.placeName.replace(' ', '_');</span>
<span class="fc" id="L132">        this.vmSizeLimit = configG.findIntEntry(&quot;VM_SIZE_LIMIT&quot;, DEFAULT_VM_SIZE_LIMIT);</span>
<span class="fc" id="L133">        this.cpuTimeLimit = configG.findIntEntry(&quot;CPU_TIME_LIMIT&quot;, DEFAULT_CPU_TIME_LIMIT);</span>
        // Set to 0 to disable watchdog monitoring
<span class="fc" id="L135">        this.processMaxMillis = configG.findLongEntry(&quot;PROCESS_MAX_MILLIS&quot;, DEFAULT_PROCESS_MAX_MILLIS);</span>
<span class="fc" id="L136">    }</span>

    /**
     * Creates a set of temp file names (does not do any disk activity)
     *
     * @return new {@link TempFileNames} instance
     */
    public TempFileNames createTempFilenames() {
<span class="fc" id="L144">        return new TempFileNames(this.tmpDir, this.placeName, this.inFileEnding, this.outFileEnding);</span>
    }

    /**
     * Make a set of temp file names (does not do any disk activity)
     *
     * @deprecated see {@link #createTempFilenames}
     */
    @Deprecated
    public String[] makeTempFilenames() {
<span class="fc" id="L154">        final TempFileNames tfn = createTempFilenames();</span>

<span class="fc" id="L156">        final String[] names = new String[7];</span>
<span class="fc" id="L157">        names[DIR] = tfn.getTempDir();</span>
<span class="fc" id="L158">        names[BASE] = tfn.getBase();</span>
<span class="fc" id="L159">        names[BASE_PATH] = tfn.getBasePath();</span>
<span class="fc" id="L160">        names[IN] = tfn.getIn();</span>
<span class="fc" id="L161">        names[OUT] = tfn.getOut();</span>
<span class="fc" id="L162">        names[INPATH] = tfn.getInputFilename();</span>
<span class="fc" id="L163">        names[OUTPATH] = tfn.getOutputFilename();</span>

<span class="fc" id="L165">        return names;</span>

    }

    /**
     * Read entire file from disk to a byte array
     * 
     * @param theFileName the name of the file to read
     * @throws IOException on error
     * @see #readFile(String,int)
     */
    public static byte[] readFile(final String theFileName) throws IOException {
<span class="fc" id="L177">        return readFile(theFileName, -1);</span>
    }

    /**
     * Read portion of a file from disk to a byte array
     * 
     * @param theFileName the name of the file to read
     * @param length the max bytes to read or -1 for all
     * @throws IOException on error
     */
    public static byte[] readFile(final String theFileName, final int length) throws IOException {
<span class="fc" id="L188">        try (RandomAccessFile raf = new RandomAccessFile(theFileName, &quot;r&quot;)) {</span>
<span class="fc bfc" id="L189" title="All 4 branches covered.">            byte[] theContent = new byte[length == -1 || length &gt;= raf.length() ? Ints.saturatedCast(raf.length()) : length];</span>
<span class="fc" id="L190">            raf.readFully(theContent);</span>
<span class="fc" id="L191">            return theContent;</span>
        }
    }

    /**
     * Write byte array slice to a file, swallow exception
     * 
     * @param theContent bytes to write
     * @param pos starting position in theContent byte array
     * @param len number of bytes to write
     * @param filename the file to write to
     * @param append if true we append to the file
     * @return true if it worked
     */
    public static boolean writeDataToFile(@Nullable final byte[] theContent, final int pos, final int len, @Nullable final String filename,
            final boolean append) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (filename == null) {</span>
<span class="fc" id="L208">            return false;</span>
        }

<span class="fc" id="L211">        final File dir = new File(filename).getParentFile();</span>
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">        if (dir != null &amp;&amp; !dir.exists()) {</span>
<span class="fc" id="L213">            final boolean status = dir.mkdirs();</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">            if (!status) {</span>
<span class="nc" id="L215">                logger.warn(&quot;Unable to create directory path to file {}&quot;, filename);</span>
<span class="nc" id="L216">                return false;</span>
            }
        }

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (filename.isEmpty()) {</span>
<span class="nc" id="L221">            logger.warn(&quot;Empty file name in writeFile:{}&quot;, filename);</span>
<span class="nc" id="L222">            return false;</span>
        }
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (theContent == null) {</span>
<span class="fc" id="L225">            logger.warn(&quot;Null content in writeFile:{}&quot;, filename);</span>
<span class="fc" id="L226">            return false;</span>
        }
        try {
<span class="fc" id="L229">            writeFile(theContent, pos, len, filename, append);</span>
<span class="fc" id="L230">            return true;</span>
<span class="nc" id="L231">        } catch (IOException e) {</span>
<span class="nc" id="L232">            logger.error(&quot;writeDataToFile({}) exception&quot;, filename, e);</span>
        }
<span class="nc" id="L234">        return false;</span>
    }

    /**
     * Write byte array data to a file, swallow exception
     * 
     * @param theContent bytes to write
     * @param theFileName the file to write to
     * @return true if it worked
     */
    public static boolean writeDataToFile(@Nullable final byte[] theContent, final String theFileName) {
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (theContent == null) {</span>
<span class="fc" id="L246">            logger.warn(&quot;Null content in writeDataToFile({})&quot;, theFileName);</span>
<span class="fc" id="L247">            return false;</span>
        }
<span class="fc" id="L249">        return writeDataToFile(theContent, 0, theContent.length, theFileName, false);</span>
    }

    /**
     * Write byte array data to a file, swallow exception
     * 
     * @param theContent bytes to write
     * @param theFileName the file to write to
     * @param append if true we append to the file
     * @return true if it worked
     */
    public static boolean writeDataToFile(@Nullable final byte[] theContent, final String theFileName, final boolean append) {
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (theContent == null) {</span>
<span class="fc" id="L262">            logger.warn(&quot;Null content in writeDataToFile({})&quot;, theFileName);</span>
<span class="fc" id="L263">            return false;</span>
        }
<span class="fc" id="L265">        return writeDataToFile(theContent, 0, theContent.length, theFileName, append);</span>
    }

    /**
     * Write byte array slice to file
     * 
     * @param theContent source data
     * @param pos starting offset of slice
     * @param len length of slice
     * @param filename destination filename
     * @param append true if existing file should be appended to
     */
    public static void writeFile(final byte[] theContent, final int pos, final int len, final String filename, final boolean append)
            throws IOException {
<span class="fc" id="L279">        try (FileOutputStream theOutput = new FileOutputStream(filename, append);</span>
<span class="fc" id="L280">                BufferedOutputStream theStream = new BufferedOutputStream(theOutput)) {</span>
<span class="fc" id="L281">            theStream.write(theContent, pos, len);</span>
        }
<span class="fc" id="L283">    }</span>

    /**
     * Write byte array data to file
     * 
     * @param theContent source data
     * @param theFileName destination filename
     */
    public static void writeFile(final byte[] theContent, final String theFileName) throws IOException {
<span class="nc" id="L292">        writeFile(theContent, 0, theContent.length, theFileName, false);</span>
<span class="nc" id="L293">    }</span>

    /**
     * Write byte array data to file with append flag
     * 
     * @param theContent source data
     * @param theFileName destination filename
     * @param append true if existing file should be appended to
     */
    public static void writeFile(final byte[] theContent, final String theFileName, final boolean append) throws IOException {
<span class="nc" id="L303">        writeFile(theContent, 0, theContent.length, theFileName, append);</span>
<span class="nc" id="L304">    }</span>

    /**
     * Read data from file name passed in and return data read in a byte array. Just like readFile but does not throw an
     * exception
     * 
     * @param theFileName disk location to read from
     * @return byte array containing the data or null on io exception
     * @see #readFile(String)
     */
    public static byte[] readDataFromFile(final String theFileName) {
<span class="fc" id="L315">        return readDataFromFile(theFileName, false);</span>
    }

    /**
     * Read data from file name passed in and return data read in a byte array. Just like readFile but does not throw an
     * exception
     * 
     * @param theFileName disk location to read from
     * @param quiet don't log any exceptions if true
     * @return byte array containing the data or null on io exception
     * @see #readFile(String)
     */
    @Nullable
    public static byte[] readDataFromFile(final String theFileName, final boolean quiet) {
        try {
<span class="fc" id="L330">            return readFile(theFileName, -1);</span>
<span class="fc" id="L331">        } catch (IOException e) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (!quiet) {</span>
<span class="fc" id="L333">                logger.warn(&quot;readDataFromFile({}) Exception: &quot;, theFileName, e);</span>
            }
<span class="fc" id="L335">            return null;</span>
        }
    }

    /**
     * Read data from random access file passed in and return data read in a byte array.
     * 
     * @param raf the random access file
     * @return byte array containing the data or null on io exception
     */
    public static byte[] readDataFromFile(final RandomAccessFile raf) {
<span class="fc" id="L346">        return readDataFromFile(raf, 0, -1);</span>
    }

    /**
     * Read data from random access file passed in and return data read in a byte array.
     * 
     * @param raf the random access file
     * @param offset the offset in the channel
     * @param length the maximum byte count to read or -1 for all
     * @return byte array containing the data or null on io exception
     */
    @Nullable
    public static byte[] readDataFromFile(final RandomAccessFile raf, final int offset, final int length) {
        // Seek to offset specified
        try {
<span class="fc" id="L361">            raf.seek(offset);</span>
<span class="nc" id="L362">        } catch (IOException ex) {</span>
<span class="nc" id="L363">            logger.warn(&quot;Seek to {} on file failed&quot;, offset, ex);</span>
<span class="nc" id="L364">            return null;</span>
<span class="fc" id="L365">        }</span>

        final long remain;
        try {
<span class="fc" id="L369">            remain = raf.length() - raf.getFilePointer();</span>
<span class="nc" id="L370">        } catch (IOException iox) {</span>
<span class="nc" id="L371">            logger.warn(&quot;Cannot get size of file&quot;, iox);</span>
<span class="nc" id="L372">            return null;</span>
<span class="fc" id="L373">        }</span>

        // Size the result array
        final byte[] data;
<span class="fc bfc" id="L377" title="All 6 branches covered.">        if ((remain &gt; 0) &amp;&amp; ((remain &lt; length) || (length == -1))) {</span>
<span class="fc" id="L378">            data = new byte[(int) remain];</span>
<span class="pc bpc" id="L379" title="1 of 4 branches missed.">        } else if (length &gt; 0 &amp;&amp; remain &gt; 0) {</span>
<span class="fc" id="L380">            data = new byte[length];</span>
        } else {
<span class="fc" id="L382">            return null;</span>
        }

        // Grab the data from the raf
        try {
<span class="fc" id="L387">            raf.readFully(data);</span>
<span class="nc" id="L388">        } catch (EOFException ex) {</span>
<span class="nc" id="L389">            logger.warn(&quot;RandomAccessFile underflow trying for {}&quot;, data.length, ex);</span>
<span class="nc" id="L390">        } catch (IOException ex) {</span>
<span class="nc" id="L391">            logger.warn(&quot;Unable to read from random access file&quot;, ex);</span>
<span class="pc" id="L392">        }</span>
<span class="fc" id="L393">        return data;</span>
    }

    /**
     * Read all byte data from a channel and return in an array
     * 
     * @param channel the channel containing the data
     * @return bytes of data or null on exception
     */
    public static byte[] readDataFromChannel(final SeekableByteChannel channel) {
<span class="fc" id="L403">        return readDataFromChannel(channel, 0, -1);</span>
    }

    /**
     * Read byte data from a channel and return in an array
     * 
     * @param channel the channel containing the data
     * @param offset the offset in the channel
     * @param length the maximum byte count to read or -1 for all
     * @return bytes of data or null on exception
     */
    @Nullable
    public static byte[] readDataFromChannel(@Nullable final SeekableByteChannel channel, final long offset, final int length) {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (channel == null) {</span>
<span class="nc" id="L417">            return null;</span>
        }

        final long size;
        try {
<span class="fc" id="L422">            size = channel.size();</span>
<span class="nc" id="L423">        } catch (IOException iox) {</span>
<span class="nc" id="L424">            logger.warn(&quot;Unable to get channel size&quot;, iox);</span>
<span class="nc" id="L425">            return null;</span>
<span class="fc" id="L426">        }</span>

<span class="pc bpc" id="L428" title="1 of 4 branches missed.">        if ((offset &gt;= 0) &amp;&amp; (offset &lt; size)) {</span>
            try {
<span class="fc" id="L430">                channel.position(offset);</span>
<span class="nc" id="L431">            } catch (IOException iox) {</span>
<span class="nc" id="L432">                logger.warn(&quot;Cannot position channel to offset {}&quot;, offset, iox);</span>
<span class="nc" id="L433">                return null;</span>
<span class="fc" id="L434">            }</span>
        } else {
<span class="fc" id="L436">            logger.warn(&quot;Negative or out of bounds offset supplied&quot;);</span>
<span class="fc" id="L437">            return null;</span>
        }

<span class="fc" id="L440">        long remain = -1L;</span>
        try {
<span class="fc" id="L442">            remain = size - channel.position();</span>
<span class="nc" id="L443">        } catch (IOException iox) {</span>
<span class="nc" id="L444">            logger.warn(&quot;Cannot get size of channel&quot;, iox);</span>
<span class="fc" id="L445">        }</span>

        // Size the result array
        final byte[] data;
<span class="fc bfc" id="L449" title="All 4 branches covered.">        if ((remain &lt; length) || (length == -1)) {</span>
<span class="fc" id="L450">            data = new byte[(int) remain];</span>
        } else {
<span class="fc" id="L452">            data = new byte[length];</span>
        }

        // Grab the data from the channel
        try {
<span class="fc" id="L457">            final ByteBuffer buf = ByteBuffer.wrap(data);</span>
<span class="fc" id="L458">            int totRead = 0;</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">            while (totRead &lt; data.length) {</span>
<span class="fc" id="L460">                int read = channel.read(buf);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">                if (read == -1) {</span>
<span class="nc" id="L462">                    break;</span>
                }
<span class="fc" id="L464">                totRead += read;</span>
<span class="fc" id="L465">            }</span>
<span class="nc" id="L466">        } catch (BufferUnderflowException ex) {</span>
<span class="nc" id="L467">            logger.warn(&quot;Buffer underflow trying for {}&quot;, data.length, ex);</span>
<span class="nc" id="L468">        } catch (IOException iox) {</span>
<span class="nc" id="L469">            logger.warn(&quot;Unable to read from channel&quot;, iox);</span>
<span class="pc" id="L470">        }</span>
<span class="fc" id="L471">        return data;</span>
    }

    /**
     * Copy file given string names
     * 
     * @param infile the file to copy from
     * @param outfile the file to copy to
     */
    public static void copyFile(final String infile, final String outfile) throws IOException {
<span class="fc" id="L481">        final File fin = new File(infile);</span>
<span class="fc" id="L482">        final File fout = new File(outfile);</span>
<span class="fc" id="L483">        copyFile(fin, fout);</span>
<span class="fc" id="L484">    }</span>

    /**
     * Copy file given file objects
     * 
     * @param frm the file to copy from
     * @param to the file to copy to
     */
    public static void copyFile(final File frm, final File to) throws IOException {
<span class="fc" id="L493">        final byte[] buf = new byte[1024];</span>
<span class="fc" id="L494">        try (InputStream fis = Files.newInputStream(frm.toPath());</span>
<span class="fc" id="L495">                OutputStream fos = new BufferedOutputStream(Files.newOutputStream(to.toPath()))) {</span>
            int len;
<span class="fc bfc" id="L497" title="All 2 branches covered.">            while ((len = fis.read(buf)) != -1) {</span>
<span class="fc" id="L498">                fos.write(buf, 0, len);</span>
            }
        }
<span class="fc" id="L501">    }</span>

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @return process exit status
     */
    public int execute(final String cmd) {
<span class="nc" id="L510">        return execute(new String[] {cmd}, (StringBuilder) null, (StringBuilder) null, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @param out destination for the standard output as a string
     * @return process exit status
     */
    public int execute(final String cmd, final StringBuffer out) {
<span class="nc" id="L521">        return execute(new String[] {cmd}, out, (StringBuffer) null, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @param out destination for the standard output as a string
     * @return process exit status
     */
    public int execute(final String cmd, final StringBuilder out) {
<span class="nc" id="L532">        return execute(new String[] {cmd}, out, (StringBuilder) null, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @param out destination for the standard output as a string
     * @param err destination for the standard error
     * @return process exit status
     */
    public int execute(final String cmd, final StringBuffer out, final StringBuffer err) {
<span class="nc" id="L544">        return execute(new String[] {cmd}, out, err, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @param out destination for the standard output as a string
     * @param err destination for the standard error
     * @return process exit status
     */
    public int execute(final String cmd, final StringBuilder out, final StringBuilder err) {
<span class="nc" id="L556">        return execute(new String[] {cmd}, out, err, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @param out destination for the standard output as a string
     * @param err destination for the standard error
     * @param charset character set of the output stream
     * @return process exit status
     */
    public int execute(final String cmd, final StringBuffer out, final StringBuffer err, final String charset) {
<span class="nc" id="L569">        return execute(new String[] {cmd}, out, err, charset);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the string command to execute
     * @param out destination for the standard output as a string
     * @param err destination for the standard error
     * @param charset character set of the output stream
     * @return process exit status
     */
    public int execute(final String cmd, final StringBuilder out, final StringBuilder err, final String charset) {
<span class="nc" id="L582">        return execute(new String[] {cmd}, out, err, charset);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the string command to execute
     * @param data the input data to the command
     * @return process exit status
     */
    public int execute(final String cmd, final byte[] data) {
<span class="fc" id="L593">        return execute(new String[] {cmd}, data, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the string command to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @return process exit status
     */
    public int execute(final String cmd, final byte[] data, final StringBuilder out) {
<span class="fc" id="L605">        return execute(new String[] {cmd}, data, out, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the string command to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @return process exit status
     */
    public int execute(final String cmd, final byte[] data, final StringBuilder out, final StringBuilder err) {
<span class="fc" id="L618">        return execute(new String[] {cmd}, data, out, err, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the string command to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @param charset character set of the output
     * @return process exit status
     */
    public int execute(final String cmd, final byte[] data, final StringBuilder out, final StringBuilder err, final String charset) {
<span class="fc" id="L632">        return execute(new String[] {cmd}, data, out, err, charset, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @return process exit status
     */
    public int execute(final String[] cmd) {
<span class="fc" id="L642">        return execute(cmd, (StringBuilder) null, (StringBuilder) null, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @return process exit status
     */
    public int execute(final String[] cmd, final StringBuffer out) {
<span class="nc" id="L653">        return execute(cmd, out, (StringBuffer) null, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @return process exit status
     */
    public int execute(final String[] cmd, final StringBuilder out) {
<span class="fc" id="L664">        return execute(cmd, out, (StringBuilder) null, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @param charset character set of the output
     * @return process exit status
     */
    public int execute(final String[] cmd, final StringBuffer out, final String charset) {
<span class="nc" id="L676">        return execute(cmd, out, (StringBuffer) null, charset);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @return process exit status
     */
    public int execute(final String[] cmd, final StringBuffer out, final StringBuffer err) {
<span class="nc" id="L688">        return execute(cmd, out, err, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @return process exit status
     */
    public int execute(final String[] cmd, final StringBuilder out, final StringBuilder err) {
<span class="fc" id="L700">        return execute(cmd, out, err, (String) null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @param charset character set of the output
     * @return process exit status
     */
    public int execute(final String[] cmd, @Nullable final StringBuffer out, @Nullable final StringBuffer err, @Nullable final String charset) {
<span class="nc bnc" id="L713" title="All 2 branches missed.">        final StringBuilder bout = (out != null) ? new StringBuilder() : null;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        final StringBuilder berr = (err != null) ? new StringBuilder() : null;</span>

<span class="nc" id="L716">        final int status = execute(cmd, bout, berr, charset);</span>

<span class="nc bnc" id="L718" title="All 4 branches missed.">        if ((out != null) &amp;&amp; (bout != null)) {</span>
<span class="nc" id="L719">            out.append(bout.toString());</span>
        }
<span class="nc bnc" id="L721" title="All 4 branches missed.">        if ((err != null) &amp;&amp; (berr != null)) {</span>
<span class="nc" id="L722">            err.append(berr.toString());</span>
        }
<span class="nc" id="L724">        return status;</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @return process exit status
     */
    public int execute(final String[] cmd, @Nullable final StringBuilder out, @Nullable final StringBuilder err, @Nullable final String charset) {
<span class="fc" id="L736">        return execute(cmd, out, err, charset, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     * 
     * @param cmd the command and arguments to execute
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @param env environment variables for the new process supplied in name=value format.
     * @return process exit status
     */
    public int execute(final String[] cmd, final StringBuilder out, final StringBuilder err, final String charset,
            @Nullable final Map&lt;String, String&gt; env) {
<span class="fc" id="L750">        return execute(cmd, null, out, err, charset, env);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @return process exit status
     */
    public int execute(final String[] cmd, final byte[] data) {
<span class="nc" id="L761">        return execute(cmd, data, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @return process exit status
     */
    public int execute(final String[] cmd, final byte[] data, @Nullable final StringBuilder out) {
<span class="fc" id="L773">        return execute(cmd, data, out, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @return process exit status
     */
    public int execute(final String[] cmd, final byte[] data, final StringBuilder out, @Nullable final StringBuilder err) {
<span class="fc" id="L786">        return execute(cmd, data, out, err, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @param charset character set of the output
     * @return process exit status
     */
    public int execute(final String[] cmd, final byte[] data, final StringBuilder out, final StringBuilder err, @Nullable final String charset) {
<span class="fc" id="L800">        return execute(cmd, data, out, err, charset, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as a string
     * @param err the destination to capture the standard error
     * @param charset character set of the output
     * @param env environment variables for the new process supplied in name=value format.
     * @return process exit status
     */
    public int execute(final String[] cmd, @Nullable final byte[] data, @Nullable final StringBuilder out, @Nullable final StringBuilder err,
            @Nullable final String charset, @Nullable final Map&lt;String, String&gt; env) {
<span class="fc" id="L816">        return execute(new ExecuteConfig.SbExecuteConfig(cmd, data, out, err, charset, env));</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec and captures binary output
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as bytes
     * @param err the destination to capture the standard error
     * @return process exit status
     */
    public int execute(final String[] cmd, @Nullable final byte[] data, @Nullable final ByteArrayOutputStream out,
            @Nullable final StringBuilder err) {
<span class="fc" id="L830">        return execute(cmd, data, out, err, null, null);</span>
    }

    /**
     * Executes a command in a new process through Runtime Exec and captures binary output
     *
     * @param cmd the command and arguments to execute
     * @param data the input data to the command
     * @param out the destination to capture the standard output as bytes
     * @param err the destination to capture the standard error
     * @param charset character set of the output
     * @param env environment variables for the new process supplied in name=value format.
     * @return process exit status
     */
    public int execute(final String[] cmd, @Nullable final byte[] data, @Nullable final ByteArrayOutputStream out, @Nullable final StringBuilder err,
            @Nullable final String charset, @Nullable final Map&lt;String, String&gt; env) {
<span class="fc" id="L846">        return execute(new ExecuteConfig.BaosExecuteConfig(cmd, data, out, err, charset, env));</span>
    }

    private int execute(ExecuteConfig eConfig) {
<span class="fc" id="L850">        int exitValue = -1;</span>
<span class="fc" id="L851">        ExecuteWatchdog dog = null;</span>
        try {
<span class="fc" id="L853">            final ProcessBuilder pb = eConfig.getProcessBuilder();</span>
<span class="fc" id="L854">            final Process p = pb.start();</span>
<span class="fc" id="L855">            final ProcessReader stdOutThread = eConfig.getStdOutProcessReader(p);</span>
<span class="fc" id="L856">            final ProcessReader stdErrThread = eConfig.getStdErrProcessReader(p);</span>

            // pass context to child threads so the info is available for any messages logged on those threads
<span class="fc" id="L859">            stdOutThread.setContextMap(MDC.getCopyOfContextMap());</span>
<span class="fc" id="L860">            stdErrThread.setContextMap(MDC.getCopyOfContextMap());</span>

<span class="fc" id="L862">            stdOutThread.start();</span>
<span class="fc" id="L863">            stdErrThread.start();</span>
<span class="fc" id="L864">            streamData(p, eConfig.getData());</span>

            // kill process if it's not done after 5 minutes - would prefer to
            // pass in a timeout value
<span class="fc bfc" id="L868" title="All 2 branches covered.">            if (this.processMaxMillis &gt;= 1) {</span>
<span class="fc" id="L869">                dog = new ExecuteWatchdog(this.processMaxMillis);</span>
<span class="fc" id="L870">                dog.start(p);</span>
            }
<span class="fc" id="L872">            p.waitFor();</span>
<span class="fc" id="L873">            stdOutThread.join();</span>
<span class="fc" id="L874">            stdErrThread.join();</span>
<span class="fc" id="L875">            stdOutThread.finish();</span>
<span class="fc" id="L876">            stdErrThread.finish();</span>
<span class="fc" id="L877">            exitValue = p.exitValue();</span>
<span class="nc" id="L878">        } catch (IOException e) {</span>
<span class="nc" id="L879">            logger.warn(&quot;Failure during execution: {}, external command={}&quot;, e, Arrays.asList(eConfig.getCmd()));</span>
<span class="nc" id="L880">        } catch (InterruptedException e) {</span>
<span class="nc" id="L881">            logger.warn(&quot;Interrupted during execution: {}, external command={}&quot;, e, Arrays.asList(eConfig.getCmd()));</span>
<span class="nc" id="L882">            Thread.currentThread().interrupt();</span>
        } finally {
<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (dog != null) {</span>
<span class="fc" id="L885">                dog.stop();</span>
<span class="fc" id="L886">                dog = null;</span>
            }
        }
<span class="fc" id="L889">        return exitValue;</span>
    }


    private static void streamData(Process p, byte[] data) throws IOException {
<span class="fc" id="L894">        try (OutputStream os = new BufferedOutputStream(new DataOutputStream(p.getOutputStream()))) {</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (ArrayUtils.isNotEmpty(data)) {</span>
<span class="fc" id="L896">                os.write(data);</span>
<span class="fc" id="L897">                os.flush();</span>
            }
        }
<span class="fc" id="L900">    }</span>

    /**
     * Write data out for processing into a new subdir under our configured temp area
     * 
     * @param data the bytes to write
     * @return the tempNames structure that was created
     * @deprecated see {@link #writeInputDataToNewTempDir(byte[])}
     */
    @Deprecated
    public String[] writeDataToNewTempDir(final byte[] data) {
<span class="fc" id="L911">        return writeDataToNewTempDir(data, 0, data.length);</span>
    }

    /**
     * Write data out for processing into a new subdir under our configured temp area
     * 
     * @param data the bytes to write
     * @param start offset in array to start writing
     * @param len length of data to write
     * @return the tempNames structure that was created
     * @deprecated see {@link #writeInputDataToNewTempDir(byte[], int, int)}
     */
    @Deprecated
    public String[] writeDataToNewTempDir(final byte[] data, final int start, final int len) {
<span class="fc" id="L925">        final String[] tnames = makeTempFilenames();</span>
<span class="fc" id="L926">        writeDataToFile(data, start, len, tnames[INPATH], false);</span>
<span class="fc" id="L927">        return tnames;</span>
    }

    /**
     * Write data out for processing into a new subdir under our configured temp area
     *
     * @param data the bytes to write
     * @param dirn the string name of a new tmp directory to use
     * @return the file that was created
     */
    @Nullable
    public File writeDataToNewTempDir(final byte[] data, final String dirn) {
<span class="nc" id="L939">        final File dir = new File(dirn);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (!dir.mkdirs()) {</span>
<span class="nc" id="L941">            logger.warn(&quot;Unable to create directory path for file {}&quot;, dirn);</span>
<span class="nc" id="L942">            return null;</span>
        }

        // Make tmp file in new tmp dir
<span class="nc" id="L946">        final String inputFileName = FileManipulator.mkTempFile(dirn) + getInFileEnding();</span>

        // Write it out
<span class="nc" id="L949">        writeDataToFile(data, 0, data.length, inputFileName, false);</span>

<span class="nc" id="L951">        return new File(inputFileName);</span>
    }

    /**
     * Write data out for processing into a new subdir under our configured temp area
     *
     * @param dirn the string name of a new tmp directory to use
     * @param data the bytes to write
     * @return the file that was created
     * @deprecated use {@link #writeDataToNewTempDir(byte[], String)}
     */
    @Nullable
    @Deprecated
    @SuppressWarnings(&quot;InconsistentOverloads&quot;)
    public File writeDataToNewTempDir(final String dirn, final byte[] data) {
<span class="nc" id="L966">        return writeDataToNewTempDir(data, dirn);</span>
    }


    /**
     * Write data out for processing into a new subdir under our configured temp area
     *
     * @param data the bytes to write
     * @return the tempNames structure that was created
     */
    public TempFileNames writeInputDataToNewTempDir(final byte[] data) {
<span class="nc" id="L977">        return writeInputDataToNewTempDir(data, 0, data.length);</span>
    }

    /**
     * Write data out for processing into a new subdir under our configured temp area
     *
     * @param data the bytes to write
     * @param start offset in array to start writing
     * @param len length of data to write
     * @return the tempNames structure that was created
     */
    public TempFileNames writeInputDataToNewTempDir(final byte[] data, final int start, final int len) {
<span class="fc" id="L989">        final TempFileNames tnames = createTempFilenames();</span>
<span class="fc" id="L990">        writeDataToFile(data, start, len, tnames.getInputFilename(), false);</span>
<span class="fc" id="L991">        return tnames;</span>
    }

    /**
     * Gets the value of command that this instance will execute adding configured limits and configured paths to the
     * configuration value
     * 
     * @return the value of command
     */
    public String getCommand() {
<span class="fc" id="L1001">        return this.command;</span>
    }

    /**
     * Gets the value of command that this instance will execute adding configured limits and supplied paths to the
     * configuration value
     * 
     * @param tmpNames set of input/output directory names
     * @return the value of command
     */
    public String[] getCommand(final String[] tmpNames) {
<span class="fc" id="L1012">        return getCommand(tmpNames, getCommand(), this.cpuTimeLimit, this.vmSizeLimit);</span>
    }

    /**
     * Gets the value of a command that can be executed adding configured limits and supplied paths to the configuration
     * value
     *
     * @param tmpNames set of input/output directory names
     * @param commandArg a command string to work with
     * @return the value of command
     */
    public String[] getCommand(final String[] tmpNames, final String commandArg) {
<span class="fc" id="L1024">        return getCommand(tmpNames, commandArg, this.cpuTimeLimit, this.vmSizeLimit);</span>
    }

    /**
     * Gets the value of a command that can be executed adding supplied limits and supplied paths to the configuration value
     * The values in the command string that can be replaced are &amp;lt;INPUT_PATH&amp;gt;, &amp;lt;OUTPUT_PATH&amp;gt;,
     * &amp;lt;INPUT_NAME&amp;gt;, and &amp;lt;OUTPUT_NAME&amp;gt;. On unix systems it is wrapped like
     * &lt;code&gt;/bin/sh -c ulimit -c 0; ulimit -v val; your command&lt;/code&gt;
     * 
     * @param tmpNames set of input/output directory names
     * @param commandArg a command string to work with
     * @param cpuLimit the cpu limit for the ulimit command
     * @param vmSzLimit for the ulimit command
     * @return the value of command
     */
    public String[] getCommand(final String[] tmpNames, final String commandArg, final int cpuLimit, final int vmSzLimit) {
<span class="fc" id="L1040">        String c = commandArg;</span>
<span class="fc" id="L1041">        c = c.replaceAll(&quot;&lt;INPUT_PATH&gt;&quot;, tmpNames[INPATH]);</span>
<span class="fc" id="L1042">        c = c.replaceAll(&quot;&lt;OUTPUT_PATH&gt;&quot;, tmpNames[OUTPATH]);</span>
<span class="fc" id="L1043">        c = c.replaceAll(&quot;&lt;INPUT_NAME&gt;&quot;, tmpNames[IN]);</span>
<span class="fc" id="L1044">        c = c.replaceAll(&quot;&lt;OUTPUT_NAME&gt;&quot;, tmpNames[OUT]);</span>

        // Run the command in shell limiting the core file size to 0 and the specified vm size
<span class="fc" id="L1047">        String ulimitv = &quot;&quot;;</span>
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">        if (!SystemUtils.IS_OS_MAC) {</span>
<span class="nc" id="L1049">            ulimitv = &quot;ulimit -v &quot; + vmSzLimit + &quot;; &quot;;</span>
        }
<span class="fc" id="L1051">        return new String[] {&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ulimit -c 0; &quot; + ulimitv + &quot;cd &quot; + tmpNames[DIR] + &quot;; &quot; + c};</span>
    }

    /**
     * Gets the value of command that this instance will execute adding configured limits and supplied paths to the
     * configuration value
     *
     * @param tmpNames set of input/output directory names
     * @return the value of command
     */
    public String[] getCommand(TempFileNames tmpNames) {
<span class="fc" id="L1062">        return getCommand(tmpNames, getCommand(), this.cpuTimeLimit, this.vmSizeLimit);</span>
    }

    /**
     * Gets the value of a command that can be executed adding configured limits and supplied paths to the configuration
     * value
     *
     * @param tmpNames set of input/output directory names
     * @param commandArg a command string to work with
     * @return the value of command
     */
    public String[] getCommand(final TempFileNames tmpNames, final String commandArg) {
<span class="fc" id="L1074">        return getCommand(tmpNames, commandArg, this.cpuTimeLimit, this.vmSizeLimit);</span>
    }

    /**
     * Gets the value of a command that can be executed adding supplied limits and supplied paths to the configuration value
     * The values in the command string that can be replaced are &amp;lt;INPUT_PATH&amp;gt;, &amp;lt;OUTPUT_PATH&amp;gt;,
     * &amp;lt;INPUT_NAME&amp;gt;, and &amp;lt;OUTPUT_NAME&amp;gt;. On unix systems it is wrapped like
     * &lt;code&gt;/bin/sh -c ulimit -c 0; ulimit -v val; your command&lt;/code&gt;
     *
     * @param tmpNames set of input/output directory names
     * @param commandArg a command string to work with
     * @param cpuLimit the cpu limit for the ulimit command
     * @param vmSzLimit for the ulimit command
     * @return the value of command
     */
    public String[] getCommand(final TempFileNames tmpNames, final String commandArg, final int cpuLimit, final int vmSzLimit) {
<span class="fc" id="L1090">        String c = commandArg;</span>
<span class="fc" id="L1091">        c = c.replaceAll(&quot;&lt;INPUT_PATH&gt;&quot;, tmpNames.getInputFilename());</span>
<span class="fc" id="L1092">        c = c.replaceAll(&quot;&lt;OUTPUT_PATH&gt;&quot;, tmpNames.getOutputFilename());</span>
<span class="fc" id="L1093">        c = c.replaceAll(&quot;&lt;INPUT_NAME&gt;&quot;, tmpNames.getIn());</span>
<span class="fc" id="L1094">        c = c.replaceAll(&quot;&lt;OUTPUT_NAME&gt;&quot;, tmpNames.getOut());</span>

        // Run the command in shell limiting the core file size to 0 and the specified vm size
<span class="fc" id="L1097">        String ulimitv = &quot;&quot;;</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">        if (!SystemUtils.IS_OS_MAC) {</span>
<span class="nc" id="L1099">            ulimitv = &quot;ulimit -v &quot; + vmSzLimit + &quot;; &quot;;</span>
        }
<span class="fc" id="L1101">        return new String[] {&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ulimit -c 0; &quot; + ulimitv + &quot;cd &quot; + tmpNames.getTempDir() + &quot;; &quot; + c};</span>
    }


    /**
     * Gets the value of a command that can be executed adding configured limits and supplied paths to the configuration
     * value
     *
     * @param commandArg a command string to work with
     * @param tmpNames set of input/output directory names
     * @return the value of command
     * @deprecated use {@link #getCommand(String[], String)}
     */
    @Deprecated
    @SuppressWarnings(&quot;InconsistentOverloads&quot;)
    public String[] getCommand(final String commandArg, final String[] tmpNames) {
<span class="nc" id="L1117">        return getCommand(tmpNames, commandArg);</span>
    }

    /**
     * Gets the value of a command that can be executed adding supplied limits and supplied paths to the configuration value
     * The values in the command string that can be replaced are &amp;lt;INPUT_PATH&amp;gt;, &amp;lt;OUTPUT_PATH&amp;gt;,
     * &amp;lt;INPUT_NAME&amp;gt;, and &amp;lt;OUTPUT_NAME&amp;gt;. On unix systems it is wrapped like
     * &lt;code&gt;/bin/sh -c ulimit -c 0; ulimit -v val; your command&lt;/code&gt;
     *
     * @param commandArg a command string to work with
     * @param tmpNames set of input/output directory names
     * @param cpuLimit the cpu limit for the ulimit command
     * @param vmSzLimit for the ulimit command
     * @return the value of command
     * @deprecated use {@link #getCommand(String[], String, int, int)}
     */
    @Deprecated
    @SuppressWarnings(&quot;InconsistentOverloads&quot;)
    public String[] getCommand(final String commandArg, final String[] tmpNames, final int cpuLimit, final int vmSzLimit) {
<span class="nc" id="L1136">        return getCommand(tmpNames, commandArg, cpuLimit, vmSzLimit);</span>
    }

    /**
     * Sets the value of command that this instance will execute
     * 
     * @param argCommand Value to assign to this.command
     */
    public void setCommand(final String argCommand) {
<span class="fc" id="L1145">        this.command = argCommand;</span>
<span class="fc" id="L1146">    }</span>

    /**
     * Gets the value of inFileEnding
     * 
     * @return the value of inFileEnding
     */
    public String getInFileEnding() {
<span class="nc" id="L1154">        return this.inFileEnding;</span>
    }

    /**
     * Sets the value of inFileEnding
     * 
     * @param argInFileEnding Value to assign to this.inFileEnding
     */
    public void setInFileEnding(final String argInFileEnding) {
<span class="fc" id="L1163">        this.inFileEnding = argInFileEnding;</span>
<span class="fc" id="L1164">    }</span>

    /**
     * Gets the value of outFileEnding
     * 
     * @return the value of outFileEnding
     */
    public String getOutFileEnding() {
<span class="nc" id="L1172">        return this.outFileEnding;</span>
    }

    /**
     * Sets the value of outFileEnding
     * 
     * @param argOutFileEnding Value to assign to this.outFileEnding
     */
    public void setOutFileEnding(final String argOutFileEnding) {
<span class="fc" id="L1181">        this.outFileEnding = argOutFileEnding;</span>
<span class="fc" id="L1182">    }</span>

    /**
     * Gets the value of output type (STD or FILE)
     * 
     * @return the value of output
     */
    public String getOutput() {
<span class="fc" id="L1190">        return this.output;</span>
    }

    /**
     * Sets the value of output type (STD or FILE)
     * 
     * @param argOutput Value to assign to this.output
     */
    public void setOutput(final String argOutput) {
<span class="nc bnc" id="L1199" title="All 4 branches missed.">        if (&quot;FILE&quot;.equals(argOutput) || &quot;STD&quot;.equals(argOutput)) {</span>
<span class="nc" id="L1200">            this.output = argOutput;</span>
        } else {
<span class="nc" id="L1202">            throw new IllegalArgumentException(&quot;Output type must be FILE or STD&quot;);</span>
        }
<span class="nc" id="L1204">    }</span>

    /**
     * Set the output type to STD
     */
    public void setOutputStd() {
<span class="nc" id="L1210">        this.output = &quot;STD&quot;;</span>
<span class="nc" id="L1211">    }</span>

    /**
     * Set the output type to FILE
     */
    public void setOutputFile() {
<span class="fc" id="L1217">        this.output = &quot;FILE&quot;;</span>
<span class="fc" id="L1218">    }</span>

    /**
     * Gets the value of order of arguments method
     * 
     * @return the value of order
     */
    public String getOrder() {
<span class="nc" id="L1226">        return this.order;</span>
    }

    /**
     * Sets the value of order, NORMAL or REVERSE
     * 
     * @param argOrder Value to assign to this.order
     */
    public void setOrder(final String argOrder) {
<span class="fc" id="L1235">        this.order = argOrder;</span>
<span class="fc" id="L1236">    }</span>

    /**
     * Gets the value of numArgs
     * 
     * @return the value of numArgs
     */
    public String getNumArgs() {
<span class="nc" id="L1244">        return this.numArgs;</span>
    }

    /**
     * Sets the value of numArgs
     * 
     * @param argNumArgs Value to assign to this.numArgs
     */
    public void setNumArgs(final String argNumArgs) {
<span class="nc" id="L1253">        this.numArgs = argNumArgs;</span>
<span class="nc" id="L1254">    }</span>

    /**
     * Gets the value of tmpDir
     * 
     * @return the value of tmpDir
     */
    public String getTmpDir() {
<span class="fc" id="L1262">        return this.tmpDir;</span>
    }

    /**
     * Sets the value of tmpDir
     * 
     * @param argTmpDir Value to assign to this.tempDir
     */
    public void setTmpDir(final String argTmpDir) {
<span class="fc" id="L1271">        this.tmpDir = argTmpDir;</span>
<span class="fc" id="L1272">    }</span>

    /**
     * Gets the value of tmpDirFile
     * 
     * @return the value of tmpDirFile
     */
    public File getTmpDirFile() {
<span class="nc" id="L1280">        return this.tmpDirFile;</span>
    }

    /**
     * Sets the value of tmpDirFile
     * 
     * @param argTmpDirFile Value to assign to this.tmpDirFile
     */
    public void setTmpDirFile(final File argTmpDirFile) {
<span class="fc" id="L1289">        this.tmpDirFile = argTmpDirFile;</span>
<span class="fc" id="L1290">    }</span>

    /**
     * Gets the value of minimumDataSize
     * 
     * @return the value of minimumDataSize
     */
    public int getMinimumDataSize() {
<span class="nc" id="L1298">        return this.minimumDataSize;</span>
    }

    /**
     * Sets the value of minimumDataSize
     * 
     * @param argMinimumDataSize Value to assign to this.minimumDataSize
     */
    public void setMinimumDataSize(final int argMinimumDataSize) {
<span class="nc" id="L1307">        this.minimumDataSize = argMinimumDataSize;</span>
<span class="nc" id="L1308">    }</span>

    /**
     * Gets the value of maximumDataSize
     * 
     * @return the value of maximumDataSize
     */
    public int getMaximumDataSize() {
<span class="nc" id="L1316">        return this.maximumDataSize;</span>
    }

    /**
     * Sets the value of maximumDataSize
     * 
     * @param argMaximumDataSize Value to assign to this.maximumDataSize
     */
    public void setMaximumDataSize(final int argMaximumDataSize) {
<span class="nc" id="L1325">        this.maximumDataSize = argMaximumDataSize;</span>
<span class="nc" id="L1326">    }</span>

    /**
     * Recursively remove up all files in a directory and then remove the directory itself.
     * 
     * @param dir the directory to remove
     * @return true if it works, false otherwise
     */
    public static boolean cleanupDirectory(final String dir) {
<span class="fc" id="L1335">        return cleanupDirectory(new File(dir));</span>
    }

    /**
     * Recursively remove up all files in a directory and then remove the directory itself. If the passed directory does not
     * exist then it will return true. If the passed directory is actually a file it will try and delete that. If an IO
     * problem happens listing the files then it will return false.
     * 
     * @param dir the directory to remove
     * @return true if it works, false otherwise
     */
    @SuppressWarnings(&quot;CatchingUnchecked&quot;)
    public static boolean cleanupDirectory(final File dir) {
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        if (!dir.exists()) {</span>
<span class="fc" id="L1349">            return true;</span>
<span class="fc bfc" id="L1350" title="All 2 branches covered.">        } else if (dir.isFile()) {</span>
<span class="fc" id="L1351">            boolean deleted = dir.delete();</span>
<span class="pc bpc" id="L1352" title="2 of 4 branches missed.">            if (!deleted &amp;&amp; dir.exists()) {</span>
<span class="fc" id="L1353">                deleted = dir.delete();</span>
            }
<span class="pc bpc" id="L1355" title="3 of 4 branches missed.">            if (!deleted &amp;&amp; dir.exists()) {</span>
<span class="nc" id="L1356">                logger.warn(&quot;Cannot delete {}&quot;, dir.getAbsolutePath());</span>
<span class="nc" id="L1357">                return false;</span>
            }
<span class="fc" id="L1359">            return true;</span>
        } else {
<span class="fc" id="L1361">            final File[] files = dir.listFiles();</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">            if (files == null) {</span>
                // null is returned if it is not a dir or an IOException occurs. As the logic prevents a non dir path
                // getting here an IOException happened.
<span class="fc" id="L1365">                return false;</span>
            }
<span class="fc bfc" id="L1367" title="All 2 branches covered.">            for (final File f : files) {</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">                if (f.isDirectory()) {</span>
<span class="fc" id="L1369">                    cleanupDirectory(f);</span>
                } else {
<span class="fc" id="L1371">                    logger.debug(&quot;Deleting {}&quot;, f.getAbsolutePath());</span>
<span class="fc" id="L1372">                    boolean deleted = f.delete();</span>
<span class="pc bpc" id="L1373" title="3 of 4 branches missed.">                    if (!deleted &amp;&amp; f.exists()) {</span>
<span class="nc" id="L1374">                        deleted = f.delete();</span>
                    }
<span class="pc bpc" id="L1376" title="3 of 4 branches missed.">                    if (!deleted &amp;&amp; f.exists()) {</span>
<span class="nc" id="L1377">                        logger.warn(&quot;Cannot delete {}&quot;, f.getAbsolutePath());</span>
                    }
                }
            }
<span class="fc" id="L1381">            logger.debug(&quot;Deleting {}&quot;, dir.getAbsolutePath());</span>

            try {

                // Try 1
<span class="fc" id="L1386">                boolean deleted = dir.delete();</span>

                // Try 2
<span class="pc bpc" id="L1389" title="3 of 4 branches missed.">                if (!deleted &amp;&amp; dir.exists()) {</span>
                    try {
<span class="nc" id="L1391">                        Thread.sleep(10);</span>
<span class="nc" id="L1392">                    } catch (InterruptedException ignore) {</span>
<span class="nc" id="L1393">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L1394">                    }</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">                    if (dir.exists()) {</span>
<span class="nc" id="L1396">                        deleted = dir.delete();</span>
                    }
                }

                // Try 3
<span class="pc bpc" id="L1401" title="3 of 4 branches missed.">                if (!deleted &amp;&amp; dir.exists()) {</span>
                    try {
<span class="nc" id="L1403">                        Thread.sleep(10);</span>
<span class="nc" id="L1404">                    } catch (InterruptedException ignore) {</span>
<span class="nc" id="L1405">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L1406">                    }</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">                    if (dir.exists()) {</span>
<span class="nc" id="L1408">                        logger.debug(&quot;Temporary directory is still there. doing rm-rf {}&quot;, dir.getAbsolutePath());</span>
<span class="nc" id="L1409">                        new Executrix().execute(new String[] {&quot;rm&quot;, &quot;-rf&quot;, dir.getAbsolutePath()});</span>
                    }
                }
<span class="nc" id="L1412">            } catch (Exception ex) {</span>
<span class="nc" id="L1413">                logger.debug(&quot;Unable to remove directory {}&quot;, dir.getAbsolutePath(), ex);</span>
<span class="fc" id="L1414">            }</span>

<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">            return !dir.exists();</span>
        }
    }

    public void setProcessMaxMillis(final long millis) {
<span class="fc" id="L1421">        this.processMaxMillis = millis;</span>
<span class="fc" id="L1422">    }</span>

    public long getProcessMaxMillis() {
<span class="nc" id="L1425">        return this.processMaxMillis;</span>
    }

    private abstract static class ExecuteConfig {

        final String[] cmd;
        final byte[] data;
        final StringBuilder err;
        final String charset;
        final Map&lt;String, String&gt; env;

<span class="fc" id="L1436">        public ExecuteConfig(String[] cmd, byte[] data, StringBuilder err, String charset, Map&lt;String, String&gt; env) {</span>
<span class="fc" id="L1437">            this.cmd = cmd;</span>
<span class="fc" id="L1438">            this.data = data;</span>
<span class="fc" id="L1439">            this.err = err;</span>
<span class="fc" id="L1440">            this.charset = charset;</span>
<span class="fc" id="L1441">            this.env = env;</span>
<span class="fc" id="L1442">        }</span>

        public String[] getCmd() {
<span class="nc" id="L1445">            return cmd;</span>
        }

        public byte[] getData() {
<span class="fc" id="L1449">            return data;</span>
        }

        public ProcessBuilder getProcessBuilder() {
<span class="fc" id="L1453">            logger.debug(&quot;Executing command: {}&quot;, Arrays.asList(cmd));</span>
<span class="fc" id="L1454">            final ProcessBuilder pb = new ProcessBuilder(cmd);</span>
<span class="fc bfc" id="L1455" title="All 2 branches covered.">            if (env != null) {</span>
<span class="fc" id="L1456">                pb.environment().putAll(env);</span>
            }
<span class="fc" id="L1458">            return pb;</span>

        }

        @SuppressWarnings(&quot;MethodCanBeStatic&quot;)
        public ProcessReader getStdOutProcessReader(Process p) {
<span class="fc" id="L1464">            return new ReadOutputLogger(&quot;stdOut&quot;, p.getInputStream());</span>
        }

        public ProcessReader getStdErrProcessReader(Process p) {
<span class="fc bfc" id="L1468" title="All 2 branches covered.">            return err == null ? new ReadOutputLogger(&quot;stdErr&quot;, p.getErrorStream()) : new ReadOutputBuffer(p.getErrorStream(), err, charset);</span>
        }

        private static class SbExecuteConfig extends ExecuteConfig {
            final StringBuilder out;

            public SbExecuteConfig(String[] cmd, byte[] data, StringBuilder out, StringBuilder err, String charset, Map&lt;String, String&gt; env) {
<span class="fc" id="L1475">                super(cmd, data, err, charset, env);</span>
<span class="fc" id="L1476">                this.out = out;</span>
<span class="fc" id="L1477">            }</span>

            @Override
            public ProcessReader getStdOutProcessReader(Process p) {
<span class="fc bfc" id="L1481" title="All 2 branches covered.">                return out == null ? super.getStdOutProcessReader(p) : new ReadOutputBuffer(p.getInputStream(), out);</span>
            }

        }

        private static class BaosExecuteConfig extends ExecuteConfig {
            final ByteArrayOutputStream out;

            public BaosExecuteConfig(String[] cmd, byte[] data, ByteArrayOutputStream out, StringBuilder err, String charset,
                    Map&lt;String, String&gt; env) {
<span class="fc" id="L1491">                super(cmd, data, err, charset, env);</span>
<span class="fc" id="L1492">                this.out = out;</span>
<span class="fc" id="L1493">            }</span>

            @Override
            public ProcessReader getStdOutProcessReader(Process p) {
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">                return out == null ? super.getStdOutProcessReader(p) : new ReadBinaryOutputBuffer(p.getInputStream(), out);</span>
            }
        }

    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>