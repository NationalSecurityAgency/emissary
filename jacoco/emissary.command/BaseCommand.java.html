<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.command</a> &gt; <span class="el_source">BaseCommand.java</span></div><h1>BaseCommand.java</h1><pre class="source lang-java linenums">package emissary.command;

import emissary.command.converter.PathExistsConverter;
import emissary.command.converter.ProjectBaseConverter;
import emissary.config.ConfigUtil;
import emissary.core.EmissaryException;

import ch.qos.logback.classic.ClassicConstants;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.util.ContextInitializer;
import ch.qos.logback.core.joran.spi.JoranException;
import ch.qos.logback.core.joran.util.ConfigurationWatchListUtil;
import jakarta.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.ParameterException;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

@Command(description = &quot;Base Command&quot;)
<span class="fc" id="L30">public abstract class BaseCommand implements EmissaryCommand {</span>
<span class="fc" id="L31">    static final Logger LOG = LoggerFactory.getLogger(BaseCommand.class);</span>

    public static final String COMMAND_NAME = &quot;BaseCommand&quot;;

    @Option(names = {&quot;-c&quot;, &quot;--config&quot;}, description = &quot;config dir, comma separated if multiple, defaults to &lt;projectBase&gt;/config&quot;,
            converter = PathExistsConverter.class)
    @Nullable
    private Path config;

<span class="fc" id="L40">    @Option(names = {&quot;-b&quot;, &quot;--projectBase&quot;}, description = &quot;defaults to PROJECT_BASE, errors if different\nDefault: ${DEFAULT-VALUE}&quot;,</span>
            converter = ProjectBaseConverter.class)
<span class="fc" id="L42">    private Path projectBase = Paths.get(System.getenv(&quot;PROJECT_BASE&quot;));</span>

    @Option(names = &quot;--logbackConfig&quot;, description = &quot;logback configuration file, defaults to &lt;configDir&gt;/logback.xml&quot;)
    @Nullable
    private String logbackConfig;

    @Option(names = {&quot;--flavor&quot;}, description = &quot;emissary config flavor, comma separated for multiple&quot;)
    private String flavor;

    @Option(names = {&quot;--binDir&quot;}, description = &quot;emissary bin dir, defaults to &lt;projectBase&gt;/bin&quot;)
    @Nullable
    private Path binDir;

    @Option(names = {&quot;--outputRoot&quot;}, description = &quot;root output directory, defaults to &lt;projectBase&gt;/localoutput&quot;)
    @Nullable
    private Path outputDir;

    @Option(names = {&quot;--errorRoot&quot;}, description = &quot;root error directory, defaults to &lt;projectBase&gt;/localerrors&quot;)
    @Nullable
    private Path errorDir;

<span class="fc" id="L63">    @Option(names = {&quot;-q&quot;, &quot;--quiet&quot;}, description = &quot;hide banner and non essential messages\nDefault: ${DEFAULT-VALUE}&quot;)</span>
    private boolean quiet = false;

    public Path getConfig() {
<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (config == null) {</span>
<span class="fc" id="L68">            config = getProjectBase().toAbsolutePath().resolve(&quot;config&quot;);</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">            if (!Files.exists(config)) {</span>
<span class="nc" id="L70">                throw new IllegalArgumentException(&quot;Config dir not configured and &quot; + config.toAbsolutePath() + &quot; does not exist&quot;);</span>
            }
        }

<span class="fc" id="L74">        return config;</span>
    }

    public Path getProjectBase() {
<span class="fc" id="L78">        return projectBase;</span>
    }

    public String getLogbackConfig() {
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (logbackConfig == null) {</span>
<span class="fc" id="L83">            return getConfig() + &quot;/logback.xml&quot;;</span>
        }
<span class="nc" id="L85">        return logbackConfig;</span>
    }

    public String getFlavor() {
<span class="fc" id="L89">        return flavor;</span>
    }

    protected void overrideFlavor(String flavor) {
<span class="fc" id="L93">        logInfo(&quot;Overriding current {} {} to {} &quot;, ConfigUtil.CONFIG_FLAVOR_PROPERTY, getFlavor(), flavor);</span>
<span class="fc" id="L94">        this.flavor = flavor;</span>
<span class="fc" id="L95">        System.setProperty(ConfigUtil.CONFIG_FLAVOR_PROPERTY, getFlavor());</span>
<span class="fc" id="L96">    }</span>

    public Path getBinDir() {
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (binDir == null) {</span>
<span class="fc" id="L100">            return getProjectBase().toAbsolutePath().resolve(&quot;bin&quot;);</span>
        }
<span class="nc" id="L102">        return binDir;</span>
    }

    public Path getOutputDir() {
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        if (outputDir == null) {</span>
<span class="fc" id="L107">            return getProjectBase().toAbsolutePath().resolve(&quot;localoutput&quot;);</span>
        }
<span class="nc" id="L109">        return outputDir;</span>
    }

    public Path getErrorDir() {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (errorDir == null) {</span>
<span class="fc" id="L114">            return getProjectBase().toAbsolutePath().resolve(&quot;localerror&quot;);</span>
        }
<span class="nc" id="L116">        return errorDir;</span>
    }

    public boolean getQuiet() {
<span class="fc" id="L120">        return quiet;</span>
    }

    public boolean isVerbose() {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        return !getQuiet();</span>
    }

    @Override
    public void setupCommand() {
<span class="fc" id="L129">        setupConfig();</span>
<span class="fc" id="L130">    }</span>

    public void setupConfig() {
<span class="fc" id="L133">        logInfo(&quot;{} is set to {} &quot;, ConfigUtil.PROJECT_BASE_ENV, getProjectBase().toAbsolutePath().toString());</span>
<span class="fc" id="L134">        setSystemProperty(ConfigUtil.CONFIG_DIR_PROPERTY, getConfig().toAbsolutePath().toString());</span>
<span class="fc" id="L135">        setSystemProperty(ConfigUtil.CONFIG_BIN_PROPERTY, getBinDir().toAbsolutePath().toString());</span>
<span class="fc" id="L136">        setSystemProperty(ConfigUtil.CONFIG_OUTPUT_ROOT_PROPERTY, getOutputDir().toAbsolutePath().toString());</span>
<span class="fc" id="L137">        logInfo(&quot;Emissary error dir set to {} &quot;, getErrorDir().toAbsolutePath().toString());</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (getFlavor() != null) {</span>
<span class="fc" id="L139">            setSystemProperty(ConfigUtil.CONFIG_FLAVOR_PROPERTY, getFlavor());</span>
        }
<span class="fc" id="L141">    }</span>

    protected void setSystemProperty(String key, String value) {
<span class="fc" id="L144">        logInfo(&quot;Setting {} to {} &quot;, key, value);</span>
<span class="fc" id="L145">        System.setProperty(key, value);</span>
<span class="fc" id="L146">    }</span>

    /**
     * Create a new command and parse the args.
     * &lt;p&gt;
     * Useful for testings. Also calls setup so properties are set
     * 
     * @param clazz the Class of return type class
     * @param args vararg of Strings
     */
    @SuppressWarnings(&quot;SystemOut&quot;)
    public static &lt;T extends EmissaryCommand&gt; T parse(Class&lt;T&gt; clazz, String... args) throws EmissaryException {
        T cmd;
        try {
<span class="fc" id="L160">            cmd = clazz.cast(Class.forName(clazz.getName()).getDeclaredConstructor().newInstance());</span>
<span class="nc" id="L161">        } catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L162">            throw new EmissaryException(&quot;Cannot construct command&quot;, e);</span>
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L165">        PrintStream ps = new PrintStream(baos);</span>
<span class="fc" id="L166">        PrintStream old = System.out;</span>
<span class="fc" id="L167">        System.setOut(ps);</span>

        CommandLine cl;
        int code;
        try {
<span class="fc" id="L172">            cl = new CommandLine(cmd);</span>
<span class="fc" id="L173">            code = cl.execute(args);</span>
        } finally {
<span class="fc" id="L175">            System.out.flush();</span>
<span class="fc" id="L176">            System.setOut(old);</span>
        }
<span class="pc bpc" id="L178" title="2 of 4 branches missed.">        if (cl != null &amp;&amp; code == 2) {</span>
<span class="nc" id="L179">            throw new ParameterException(cl, baos.toString());</span>
        }
<span class="fc" id="L181">        cmd.setup();</span>
<span class="fc" id="L182">        return cmd;</span>
    }

    /**
     * Create a new command and parse the args
     * &lt;p&gt;
     * Useful for testings
     * 
     * @param clazz the Class of return type class
     * @param args vararg of Strings
     */
    public static &lt;T extends EmissaryCommand&gt; T parse(Class&lt;T&gt; clazz, List&lt;String&gt; args) throws EmissaryException {
<span class="fc" id="L194">        return parse(clazz, args.toArray(new String[0]));</span>
    }

    /*
     * Try to reinitialize the logback context with the configured file you may have 2 log files if anything logged before
     * we do this. Useful when you are running a server For troubleshooting, looking at the http://localhost:8001/lbConfig
     * when this works, you will see the initial logger and then new one
     *
     * Need to reinit because logback config uses ${emissary.node.name}-${emissary.node.port} which are now set by the
     * commands after logback is initialized
     */
    public void reinitLogback() {
<span class="fc" id="L206">        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</span>
<span class="fc" id="L207">        URL logCfg = ConfigurationWatchListUtil.getMainWatchURL(loggerContext);</span>

<span class="pc bpc" id="L209" title="1 of 6 branches missed.">        if (logCfg != null &amp;&amp; (logCfg.toString().endsWith(&quot;logback-test.xml&quot;) || logCfg.toString().endsWith(&quot;logback-test.groovy&quot;))) {</span>
            // logCfg can be null if Emissary.setupLogbackForConsole is called
<span class="fc" id="L211">            LOG.warn(&quot;Not using {}, staying with test config {}&quot;, getLogbackConfig(), logCfg);</span>
<span class="fc" id="L212">            doLogbackReinit(loggerContext, logCfg.getPath());</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        } else if (Files.exists(Paths.get(getLogbackConfig()))) {</span>
<span class="fc" id="L214">            doLogbackReinit(loggerContext, getLogbackConfig());</span>
        } else {
<span class="nc" id="L216">            LOG.warn(&quot;logback configuration not found {}, not reconfiguring logging&quot;, getLogbackConfig());</span>
        }

<span class="fc" id="L219">    }</span>

    private void doLogbackReinit(LoggerContext loggerContext, String configFilePath) {
<span class="fc" id="L222">        System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, configFilePath);</span>
<span class="fc" id="L223">        loggerContext.reset();</span>
<span class="fc" id="L224">        ContextInitializer newContext = new ContextInitializer(loggerContext);</span>
        try {
<span class="fc" id="L226">            newContext.autoConfig();</span>
<span class="nc" id="L227">        } catch (JoranException e) {</span>
<span class="nc" id="L228">            LOG.error(&quot;Problem reconfiguring logback with {}&quot;, getLogbackConfig(), e);</span>
<span class="fc" id="L229">        }</span>
<span class="fc" id="L230">    }</span>

    public void logInfo(String format, Object... args) {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (isVerbose()) {</span>
<span class="fc" id="L234">            LOG.info(format, args);</span>
        }
<span class="fc" id="L236">    }</span>

    @Override
    public void outputBanner() {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (isVerbose()) {</span>
<span class="fc" id="L241">            new Banner().dump();</span>
        }
<span class="fc" id="L243">    }</span>

    @Override
<span class="fc" id="L246">    public void run() {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>