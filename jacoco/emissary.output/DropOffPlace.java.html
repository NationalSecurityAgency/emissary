<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DropOffPlace.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.output</a> &gt; <span class="el_source">DropOffPlace.java</span></div><h1>DropOffPlace.java</h1><pre class="source lang-java linenums">package emissary.output;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.core.DataObjectFactory;
import emissary.core.Form;
import emissary.core.IBaseDataObject;
import emissary.directory.DirectoryEntry;
import emissary.output.filter.IDropOffFilter;
import emissary.place.EmptyFormPlace;
import emissary.place.ServiceProviderPlace;
import emissary.util.DataUtil;
import emissary.util.DisposeHelper;
import emissary.util.ShortNameComparator;

import jakarta.annotation.Nullable;

import java.io.IOException;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * DropOffPlace manages the output from the system It has evolved into a controller of sorts with way too many options,
 * that controls which types of output are desired and called the appropriate output helper for the desired output.
 **/
public class DropOffPlace extends ServiceProviderPlace implements EmptyFormPlace {

<span class="pc" id="L35">    protected boolean doSynchronized = false;</span>
    protected Set&lt;String&gt; elideContentForms;
    protected Set&lt;String&gt; noNukeForms;
<span class="pc" id="L38">    protected List&lt;IDropOffFilter&gt; outputFilters = new ArrayList&lt;&gt;();</span>
<span class="pc" id="L39">    protected boolean failurePolicyTerminate = true;</span>
    protected DropOffUtil dropOffUtil;
<span class="pc" id="L41">    private boolean outputCompletionPayloadSize = false;</span>

    /**
     * Primary place constructor
     * 
     * @param configInfo our config stuff from the startup
     * @param dir string name of the directory to register into
     * @param placeLoc string form of our key
     */
    public DropOffPlace(final String configInfo, final String dir, final String placeLoc) throws IOException {
<span class="nc" id="L51">        super(configInfo, dir, placeLoc);</span>
<span class="nc" id="L52">        configurePlace();</span>
<span class="nc" id="L53">    }</span>

    /**
     * Test form of constructor
     */
    public DropOffPlace(final String configInfo) throws IOException {
<span class="nc" id="L59">        this(configInfo, &quot;DropOffPlace.example.com:8001&quot;);</span>
<span class="nc" id="L60">    }</span>

    /**
     * Test form of constructor
     */
    protected DropOffPlace(final String configInfo, final String placeLocation) throws IOException {
<span class="nc" id="L66">        super(configInfo, placeLocation);</span>
<span class="nc" id="L67">        configurePlace();</span>
<span class="nc" id="L68">    }</span>

<span class="fc" id="L70">    public DropOffPlace(final Configurator configInfo) throws IOException {</span>
<span class="fc" id="L71">        this.configG = configInfo;</span>
<span class="fc" id="L72">        configurePlace();</span>
<span class="fc" id="L73">    }</span>

    /**
     * Constructor for hooking in to all the defaults
     */
<span class="nc" id="L78">    public DropOffPlace() throws IOException {</span>
<span class="nc" id="L79">        configurePlace();</span>
<span class="nc" id="L80">    }</span>

    /**
     * Setup configuration items we need and build the output filter
     */
    protected void configurePlace() {
        // Set configuration info on file paths
<span class="fc" id="L87">        this.dropOffUtil = new DropOffUtil(configG);</span>
<span class="fc" id="L88">        this.doSynchronized = configG.findBooleanEntry(&quot;SYNCHRONIZED_PROCESS&quot;, false);</span>
<span class="fc" id="L89">        this.failurePolicyTerminate = configG.findBooleanEntry(&quot;FAILURE_TERMINATES_CHAIN&quot;, true);</span>
<span class="fc" id="L90">        this.outputCompletionPayloadSize = configG.findBooleanEntry(&quot;OUTPUT_COMPLETION_PAYLOAD_SIZE&quot;, false);</span>
        // Build and store all the filter that are desired IN THE ORDER SPECIFIED
<span class="fc" id="L92">        final List&lt;String&gt; filterClasses = configG.findEntries(&quot;OUTPUT_FILTER&quot;);</span>
<span class="fc" id="L93">        initializeFilters(filterClasses);</span>

<span class="fc" id="L95">    }</span>

    /**
     * Start up the requested filter
     * 
     * @param filterClasses the name:class values of the configured filter for this drop off
     */
    protected void initializeFilters(final List&lt;String&gt; filterClasses) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (final String entry : filterClasses) {</span>
            final String name;
            final String clazz;
<span class="fc" id="L106">            Configurator filterConfig = null;</span>
<span class="fc" id="L107">            final int colpos = entry.indexOf(':');</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            if (colpos &gt; -1) {</span>
<span class="fc" id="L109">                name = entry.substring(0, colpos);</span>
<span class="fc" id="L110">                clazz = entry.substring(colpos + 1);</span>
<span class="fc" id="L111">                final String filterConfigName = configG.findStringEntry(name);</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">                if (filterConfigName != null) {</span>
                    try {
<span class="nc" id="L114">                        filterConfig = ConfigUtil.getConfigInfo(filterConfigName);</span>
<span class="nc" id="L115">                    } catch (IOException configError) {</span>
<span class="nc" id="L116">                        logger.warn(&quot;Specified filter configuration {} cannot be loaded&quot;, filterConfigName);</span>
<span class="nc" id="L117">                        continue;</span>
<span class="nc" id="L118">                    }</span>
                }
<span class="fc" id="L120">            } else {</span>
<span class="nc" id="L121">                name = null;</span>
<span class="nc" id="L122">                clazz = entry;</span>
            }

            try {
<span class="fc" id="L126">                final Object filter = emissary.core.Factory.create(clazz);</span>
<span class="pc bpc" id="L127" title="2 of 4 branches missed.">                if (filter != null &amp;&amp; filter instanceof IDropOffFilter) {</span>
<span class="fc" id="L128">                    final IDropOffFilter f = (IDropOffFilter) filter;</span>
<span class="fc" id="L129">                    f.initialize(configG, name, filterConfig);</span>
<span class="fc" id="L130">                    addFilter(f);</span>
<span class="fc" id="L131">                } else {</span>
<span class="nc" id="L132">                    logger.error(&quot;Misconfigured filter {} is not an IDropOffFilter instance, ignoring it&quot;, clazz);</span>
                }
<span class="nc" id="L134">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L135">                logger.error(&quot;Unable to create or initialize {}&quot;, clazz, ex);</span>
<span class="fc" id="L136">            }</span>
<span class="fc" id="L137">        }</span>

        // Collect the set of content types to elide
<span class="fc" id="L140">        this.elideContentForms = configG.findEntriesAsSet(&quot;ELIDE_CONTENT&quot;);</span>

        // collect the set of no-nuke forms
<span class="fc" id="L143">        this.noNukeForms = configG.findEntriesAsSet(&quot;NO_NUKE_FORM&quot;);</span>

<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L146">            logger.debug(&quot;Setting ELIDE_CONTENT forms to &quot; + this.elideContentForms);</span>
<span class="fc" id="L147">            final StringBuilder sb = new StringBuilder(&quot;Output Filters:&quot;);</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (this.outputFilters.size() &gt; 0) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                for (final IDropOffFilter f : this.outputFilters) {</span>
<span class="fc" id="L150">                    sb.append(&quot; &quot;).append(f.getFilterName()).append(&quot;(&quot;).append(f.getClass().getName()).append(&quot;)&quot;);</span>
<span class="fc" id="L151">                }</span>
            } else {
<span class="nc" id="L153">                sb.append(&quot; NONE!&quot;);</span>
            }
<span class="fc" id="L155">            logger.info(sb.toString());</span>
        }

<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L159">            final IBaseDataObject fakePayload = DataObjectFactory.getInstance(new byte[0], &quot;fakename&quot;, Form.UNKNOWN);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            for (final IDropOffFilter filter : getFilters()) {</span>
<span class="nc" id="L161">                final String name = filter.getFilterName();</span>
<span class="nc" id="L162">                final String spec = filter.getOutputSpec();</span>

<span class="nc" id="L164">                logger.debug(&quot;Adding filter={}, spec={}, sample={}, class={}&quot;, name, spec, this.dropOffUtil.getPathFromSpec(spec, fakePayload),</span>
<span class="nc" id="L165">                        filter.getClass().getSimpleName());</span>
<span class="nc" id="L166">            }</span>
        }
<span class="fc" id="L168">    }</span>

    /** {@inheritDoc } */
    @Override
    public void shutDown() {
<span class="fc" id="L173">        super.shutDown();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (final IDropOffFilter filter : this.outputFilters) {</span>
<span class="fc" id="L175">            logger.debug(&quot;Shutdown filter {}&quot;, filter.getFilterName());</span>
<span class="fc" id="L176">            filter.close();</span>
<span class="fc" id="L177">        }</span>
<span class="fc" id="L178">    }</span>

    /**
     * &quot;HD&quot; agent calls this method when visiting the place. If you use {@link emissary.core.MobileAgent} this method is
     * never called. This method overrides {@link ServiceProviderPlace} and allows this processing place to have access to
     * all payloads wanting to be dropped off in a single list.
     * 
     * @param payloadList list of IBaseDataObject from an {@link emissary.core.HDMobileAgent}
     */
    @Override
    public List&lt;IBaseDataObject&gt; agentProcessHeavyDuty(final List&lt;IBaseDataObject&gt; payloadList) throws Exception {

<span class="fc" id="L190">        logger.debug(&quot;Entering DropOffPlace.agentProcessHeavyDuty with {} payload items&quot;, payloadList.size());</span>

        // Prepare each incoming payload object
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (final IBaseDataObject d : payloadList) {</span>
            try {
                // checking to see if any object in the tree is marked as not outputable
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">                if (!d.isOutputable()) {</span>
<span class="nc" id="L197">                    logger.info(&quot;Skipping object since it is not able to be output ID:{}&quot;, this.dropOffUtil.getBestId(d, payloadList.get(0)));</span>
<span class="nc" id="L198">                    return Collections.emptyList();</span>
                }

                // Process the payload item with HDcontext=true
<span class="fc" id="L202">                processData(d, true);</span>
<span class="nc" id="L203">            } catch (RuntimeException e) {</span>
<span class="nc" id="L204">                logger.error(&quot;Place.process threw:&quot;, e);</span>
<span class="nc" id="L205">                d.addProcessingError(&quot;agentProcessHD(&quot; + myKey + &quot;): &quot; + e);</span>

<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (!d.currentForm().equals(Form.ERROR)) {</span>
<span class="nc" id="L208">                    d.pushCurrentForm(Form.ERROR);</span>
                }
<span class="fc" id="L210">            }</span>
<span class="fc" id="L211">        }</span>

        // Prepare the data and metadata for filter output
<span class="fc" id="L214">        final Map&lt;String, Object&gt; filterParams = new HashMap&lt;&gt;();</span>
<span class="fc" id="L215">        preFilterHook(payloadList, filterParams);</span>

        // Run the filter on the output, indicating that
        // the records are pre-sorted, if the filter cares
<span class="fc" id="L219">        runOutputFilters(payloadList, filterParams);</span>

        // Any cleanup operations needed
<span class="fc" id="L222">        postFilterHook(payloadList, filterParams);</span>

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (!payloadList.isEmpty()) {</span>
            // Should have been sorted by the prefilter hook

            // Just report the TLD object ID
<span class="fc" id="L228">            final IBaseDataObject tld = payloadList.get(0);</span>


<span class="pc bpc" id="L231" title="1 of 4 branches missed.">            if (outputCompletionPayloadSize &amp;&amp; tld.hasContent()) {</span>
<span class="fc" id="L232">                logger.info(</span>
                        &quot;Finished DropOff for object {}, with external id: {}, with total processing time: {}ms, with filetype: {}, payload size: {} bytes&quot;,
<span class="fc" id="L234">                        tld.getInternalId(), this.dropOffUtil.getBestId(tld, tld),</span>
<span class="fc" id="L235">                        Duration.between(tld.getCreationTimestamp(), Instant.now()).toMillis(),</span>
<span class="fc" id="L236">                        tld.getFileType(), tld.getChannelSize());</span>
            } else {
<span class="fc" id="L238">                logger.info(&quot;Finished DropOff for object {}, with external id: {}, with total processing time: {}ms, with filetype: {}&quot;,</span>
<span class="fc" id="L239">                        tld.getInternalId(), this.dropOffUtil.getBestId(tld, tld),</span>
<span class="fc" id="L240">                        Duration.between(tld.getCreationTimestamp(), Instant.now()).toMillis(),</span>
<span class="fc" id="L241">                        tld.getFileType());</span>
            }

        }

        // Execute 'Dispose Runnables' to tidy up resources used with SeekableByteChannelFactory implementations
<span class="fc" id="L247">        DisposeHelper.execute(payloadList);</span>

        // This place does not sprout, return an empty list
<span class="fc" id="L250">        return Collections.emptyList();</span>
    }

    /**
     * Called by MobileAgent through ServiceProviderPlace to handle a single payload
     * 
     * @param tData the payload to work on
     */
    @Override
    public void process(final IBaseDataObject tData) {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (DataUtil.isEmpty(tData)) {</span>
<span class="nc" id="L261">            logger.warn(&quot;null/empty data object&quot;);</span>
<span class="nc" id="L262">            return;</span>
        }

        // checking to see if the object is marked as not outputable
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (!tData.isOutputable()) {</span>
<span class="nc" id="L267">            logger.warn(&quot;Skipping object since it is not able to be output ID:{}&quot;, this.dropOffUtil.getBestId(tData, tData));</span>
<span class="nc" id="L268">            return;</span>
        }

        // synchronization can be set by config file entry
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (this.doSynchronized) {</span>
<span class="nc" id="L273">            synchronized (this) {</span>
<span class="nc" id="L274">                processData(tData, false);</span>
<span class="nc" id="L275">            }</span>
        } else {
<span class="nc" id="L277">            processData(tData, false);</span>
        }

        // Execute 'Dispose Runnables' to tidy up resources used with SeekableByteChannelFactory implementations
<span class="nc" id="L281">        DisposeHelper.execute(tData);</span>
<span class="nc" id="L282">    }</span>

    /**
     * Prepare a list of payload object to be filtered
     * 
     * @param payloadList the list of items that were eligible for output
     * @param filterParams metadata needed for the output filter
     */
    public void preFilterHook(final List&lt;IBaseDataObject&gt; payloadList, final Map&lt;String, Object&gt; filterParams) {
        // Sort the list of records
<span class="fc" id="L292">        Collections.sort(payloadList, new ShortNameComparator());</span>
<span class="fc" id="L293">        filterParams.put(IDropOffFilter.PRE_SORTED, Boolean.TRUE);</span>
<span class="fc" id="L294">        filterParams.put(IDropOffFilter.TLD_PARAM, payloadList.get(0));</span>

        // Prepare the metadata
<span class="fc" id="L297">        this.dropOffUtil.processMetadata(payloadList);</span>
<span class="fc" id="L298">    }</span>

    /**
     * Clean up after all filter are done
     * 
     * @param payloadList the list of items that were eligible for output
     * @param filterParams metadata needed for the output filter
     */
    public void postFilterHook(final List&lt;IBaseDataObject&gt; payloadList, final Map&lt;String, Object&gt; filterParams) {
        // remove the current forms we used or could have used
<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (final IBaseDataObject dataObject : payloadList) {</span>
            // Save off no-nuke forms
<span class="fc" id="L310">            final List&lt;String&gt; saveForms = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            for (final String nnf : this.noNukeForms) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (dataObject.searchCurrentForm(nnf) &gt; -1) {</span>
<span class="nc" id="L313">                    saveForms.add(nnf);</span>
                }
<span class="nc" id="L315">            }</span>
            // nuke 'em
<span class="fc" id="L317">            this.nukeMyProxies(dataObject);</span>

            // Restore the no-nukes
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            for (final String sf : saveForms) {</span>
<span class="nc" id="L321">                dataObject.pushCurrentForm(sf);</span>
<span class="nc" id="L322">            }</span>
<span class="fc" id="L323">        }</span>

<span class="fc" id="L325">    }</span>

    /**
     * Internal method to process a single data object
     * 
     * @param tData the payload to work on or prepare
     * @param haveList true if in HD context
     */
    protected void processData(final IBaseDataObject tData, final boolean haveList) {

<span class="fc" id="L335">        logger.debug(&quot;DropOff is working on {}, current form is {}&quot;, tData.shortName(), tData.getAllCurrentForms());</span>

<span class="fc" id="L337">        final StringBuilder poppedForms = new StringBuilder();</span>

<span class="fc" id="L339">        String prevBin = &quot;&quot;;</span>

        // skip the I/O for some types for all filter
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (int i = 0; i &lt; tData.currentFormSize(); i++) {</span>
<span class="fc" id="L343">            final String cf = tData.currentFormAt(i);</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (this.elideContentForms.contains(cf)) {</span>
<span class="nc" id="L345">                tData.setData((&quot;[[ &quot; + tData.getAllCurrentForms() + &quot; content elided in DropOffPlace. ]]&quot;).getBytes());</span>
            }
        }

        // Write out data for all the destinations we area proxy for, popping
        // them off the stack as they are handled.

<span class="fc" id="L352">        final Set&lt;String&gt; serviceProxies = getProxies();</span>
<span class="fc" id="L353">        final Set&lt;String&gt; cfSet = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int i = 0; i &lt; tData.currentFormSize(); i++) {</span>
<span class="fc" id="L355">            final String cf = tData.currentFormAt(i);</span>

<span class="pc bpc" id="L357" title="2 of 4 branches missed.">            if (serviceProxies.contains(cf) || serviceProxies.contains(&quot;*&quot;)) {</span>
                // Record extra drop offs in the transform history since
                // we are taking precedence over the normal agent/directory mechanism
                // Do this before popping the extra destination so that it
                // is not just lost forever. Since the agent appends
                // one entry to the history when it sends the agent here,
                // that's the top current form and
                // we don't want to duplicate that one

<span class="pc bpc" id="L366" title="8 of 10 branches missed.">                if (!prevBin.equals(cf) &amp;&amp; (i &gt; 0) &amp;&amp; !cfSet.contains(cf) &amp;&amp; !(&quot;UNKNOWN&quot;.equals(cf) || cf.endsWith(&quot;-PROCESSED&quot;))) {</span>
                    // e.g.: [dataType].DROP_OFF.IO.host.dom:port/DropOffPlace
<span class="nc" id="L368">                    final DirectoryEntry de = getDirectoryEntry();</span>
<span class="nc" id="L369">                    de.setDataType(&quot;[&quot; + cf + &quot;]&quot;);</span>
<span class="nc" id="L370">                    tData.appendTransformHistory(de.getKey());</span>
                }

                // Accumulate forms we have handled in poppedForms
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                if (poppedForms.length() &gt; 0) {</span>
<span class="nc" id="L375">                    poppedForms.append(&quot; &quot;);</span>
                }
<span class="fc" id="L377">                poppedForms.append(cf);</span>
<span class="fc" id="L378">                cfSet.add(cf);</span>

<span class="fc" id="L380">                prevBin = cf;</span>
            }
        }

        // Record the list of forms
<span class="fc" id="L385">        tData.setParameter(&quot;POPPED_FORMS&quot;, poppedForms.toString());</span>

        // Do the output filtering now if we aren't in HD mode
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (!haveList) {</span>

            // There currently are no extra params needed
<span class="nc" id="L391">            final Map&lt;String, Object&gt; filterParams = new HashMap&lt;&gt;();</span>

<span class="nc" id="L393">            runOutputFilters(tData, filterParams);</span>

            // Actually remove the current forms we used or could have used
<span class="nc" id="L396">            this.nukeMyProxies(tData);</span>

<span class="nc" id="L398">            logger.debug(&quot;DropOff finished with {}&quot;, tData.shortName());</span>
        }
<span class="fc" id="L400">    }</span>

    /**
     * Run all the output filter
     * 
     * @param target either IBaseDataObject or List thereof
     * @param filterParams other parameters that filter need
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    protected void runOutputFilters(final Object target, final Map&lt;String, Object&gt; filterParams) {

<span class="fc" id="L411">        IBaseDataObject doTarget = null;</span>
<span class="fc" id="L412">        List&lt;IBaseDataObject&gt; listTarget = null;</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (target instanceof IBaseDataObject) {</span>
<span class="nc" id="L414">            doTarget = (IBaseDataObject) target;</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        } else if (target instanceof List) {</span>
<span class="fc" id="L416">            listTarget = (List&lt;IBaseDataObject&gt;) target;</span>
        } else {
<span class="nc" id="L418">            logger.error(&quot;Cannot run filter on {}&quot;, target.getClass().getName());</span>
<span class="nc" id="L419">            return;</span>
        }

        // Write output onto each of the filter that have been
        // configured, as long as they work
<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (final IDropOffFilter filter : this.outputFilters) {</span>
<span class="fc" id="L425">            final long start = System.currentTimeMillis();</span>

            // call the filter to output its data
<span class="fc" id="L428">            int filterStatus = IDropOffFilter.STATUS_FAILURE;</span>
            try {
<span class="pc bpc" id="L430" title="2 of 4 branches missed.">                if (listTarget != null &amp;&amp; filter.isOutputtable(listTarget)) {</span>
<span class="fc" id="L431">                    filterStatus = filter.filter(listTarget, filterParams);</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">                } else if (doTarget != null &amp;&amp; filter.isOutputtable(doTarget)) {</span>
<span class="nc" id="L433">                    filterStatus = filter.filter(doTarget, filterParams);</span>
                } else {
<span class="nc bnc" id="L435" title="All 2 branches missed.">                    logger.debug(&quot;Filter {} not Outputtable for {}&quot;, filter.getFilterName(), listTarget != null ? &quot;list&quot; : &quot;single payload&quot;);</span>
<span class="nc" id="L436">                    filterStatus = IDropOffFilter.STATUS_SUCCESS;</span>
                }
<span class="fc" id="L438">                logger.debug(&quot;Filter {} took {}s - {}&quot;, filter.getFilterName(), (System.currentTimeMillis() - start) / 1000.0, filterStatus);</span>
<span class="fc" id="L439">            } catch (RuntimeException e) {</span>
<span class="fc" id="L440">                logger.error(&quot;Filter {} failed&quot;, filter.getFilterName(), e);</span>
<span class="fc" id="L441">            }</span>

<span class="pc bpc" id="L443" title="1 of 4 branches missed.">            if ((filterStatus != IDropOffFilter.STATUS_SUCCESS) &amp;&amp; this.failurePolicyTerminate) {</span>
<span class="fc" id="L444">                logger.error(&quot;DropOff Filter chain terminated at {} due to error return status&quot;, filter.getFilterName());</span>
<span class="fc" id="L445">                break;</span>
            }
<span class="fc" id="L447">        }</span>
<span class="fc" id="L448">    }</span>

    /**
     * Provide access to the filter
     * 
     * @return a copy of the list of filter
     */
    public List&lt;IDropOffFilter&gt; getFilters() {
<span class="nc" id="L456">        return new ArrayList&lt;&gt;(this.outputFilters);</span>
    }

    /**
     * Provide access to filter names
     * 
     * @return an array of filter names or an empty array if none
     * @deprecated use {@link #getFilterNamesList()}
     */
    @Deprecated
    @SuppressWarnings(&quot;AvoidObjectArrays&quot;)
    public String[] getFilterNames() {
<span class="nc" id="L468">        return getFilterNamesList().toArray(new String[0]);</span>
    }

    /**
     * Provide access to filter names
     *
     * @return a list of filter names or an empty list if none
     */
    public List&lt;String&gt; getFilterNamesList() {
<span class="nc" id="L477">        final List&lt;String&gt; fnames = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        for (final IDropOffFilter f : this.outputFilters) {</span>
<span class="nc" id="L479">            fnames.add(f.getFilterName());</span>
<span class="nc" id="L480">        }</span>
<span class="nc" id="L481">        return fnames;</span>
    }

    /**
     * Provide access to filter by name
     * 
     * @return the named filter or null if none by that name
     */
    @Nullable
    public IDropOffFilter getFilter(final String name) {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        for (final IDropOffFilter f : this.outputFilters) {</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            if (f.getFilterName().equals(name)) {</span>
<span class="fc" id="L493">                return f;</span>
            }
<span class="nc" id="L495">        }</span>
<span class="nc" id="L496">        return null;</span>
    }

    public DropOffUtil getDropOffUtil() {
<span class="nc" id="L500">        return this.dropOffUtil;</span>
    }

    /**
     * Add a filter
     * 
     * @param filter the new filter to add, must already be configured and initialized
     */
    public void addFilter(final IDropOffFilter filter) {
<span class="fc" id="L509">        this.outputFilters.add(filter);</span>
<span class="fc" id="L510">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>