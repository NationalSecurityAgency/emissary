<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DropOffUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.output</a> &gt; <span class="el_source">DropOffUtil.java</span></div><h1>DropOffUtil.java</h1><pre class="source lang-java linenums">package emissary.output;

import emissary.config.ConfigUtil;
import emissary.config.Configurator;
import emissary.core.Family;
import emissary.core.IBaseDataObject;
import emissary.util.FlexibleDateTimeParser;
import emissary.util.ShortNameComparator;
import emissary.util.TimeUtil;
import emissary.util.shell.Executrix;

import jakarta.annotation.Nullable;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import static emissary.core.Form.PREFIXES_LANG;
import static emissary.core.Form.TEXT;
import static emissary.core.Form.UNKNOWN;
import static emissary.core.constants.Parameters.FILEXT;
import static emissary.core.constants.Parameters.FILE_ABSOLUTEPATH;
import static emissary.core.constants.Parameters.ORIGINAL_FILENAME;
import static emissary.util.TimeUtil.DATE_ISO_8601;
import static emissary.util.TimeUtil.getDateOrdinalWithTime;

public class DropOffUtil {
<span class="fc" id="L50">    protected static final Logger logger = LoggerFactory.getLogger(DropOffUtil.class);</span>

<span class="fc" id="L52">    protected static final String SEPARATOR = FileSystems.getDefault().getSeparator();</span>
<span class="fc" id="L53">    protected static final String OS_NAME = System.getProperty(&quot;os.name&quot;).toUpperCase(Locale.getDefault());</span>

    protected String unixRoot;

    protected String placeOutputData;

    /** Sources for building an ID for an item */
<span class="fc" id="L60">    protected List&lt;String&gt; idTokens = new ArrayList&lt;&gt;();</span>

    /** Sources for building a date string for an item */
<span class="fc" id="L63">    protected List&lt;String&gt; dateTokens = new ArrayList&lt;&gt;();</span>

    /** params to get from parent and save as PARENT_param */
<span class="fc" id="L66">    protected List&lt;String&gt; parentParams = new ArrayList&lt;&gt;();</span>

    /** Output directories */
<span class="fc" id="L69">    protected Map&lt;String, File&gt; outputDirectories = new HashMap&lt;&gt;();</span>

    protected Executrix executrix;

    // Items for generating random filenames
<span class="fc" id="L74">    protected static final SecureRandom prng = new SecureRandom();</span>
<span class="fc" id="L75">    protected static final byte[] ALPHABET = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.getBytes();</span>
<span class="fc" id="L76">    protected String prefix = &quot;TXT&quot;;</span>
<span class="fc" id="L77">    protected boolean uuidInOutputFilenames = true;</span>
<span class="fc" id="L78">    protected int maxFilextLen = Integer.MAX_VALUE;</span>

    // Items for generating UUIDs
    private static final String AUTO_GENERATED_ID = &quot;AUTO_GENERATED_ID&quot;;
    private static final String PARENT_AUTO_GENERATED_ID = &quot;PARENT_AUTO_GENERATED_ID&quot;;
<span class="fc" id="L83">    @Nullable</span>
    private String autoGeneratedIdPrefix = null;

    protected static final String EXTENDED_FILETYPE = &quot;EXTENDED_FILETYPE&quot;;
    protected static final String PARENT_FILETYPE = &quot;PARENT_FILETYPE&quot;;
    protected static final String SHORTNAME = &quot;SHORTNAME&quot;;
    protected static final String TARGETBIN = &quot;TARGETBIN&quot;;

    private static final String DEFAULT_EVENT_DATE_TO_NOW = &quot;DEFAULT_EVENT_DATE_TO_NOW&quot;;
<span class="fc" id="L92">    protected boolean defaultEventDateToNow = true;</span>

    /**
     * Create with the default configuration
     */
<span class="fc" id="L97">    public DropOffUtil() {</span>
<span class="fc" id="L98">        configure(null);</span>
<span class="fc" id="L99">    }</span>

    /**
     * Create with the specified configuration
     */
<span class="fc" id="L104">    public DropOffUtil(final Configurator configG) {</span>
<span class="fc" id="L105">        configure(configG);</span>
<span class="fc" id="L106">    }</span>

    /**
     * Set up config for this class
     * &lt;ul&gt;
     * &lt;li&gt;ID_PARAMETER : multiple parameter values, ordered list of how to build a EMISSARY_ID&lt;/li&gt;
     * &lt;li&gt;ID : backwards compatibility for ID_PARAMETER only used if ID_PARAMETER does not exist&lt;/li&gt;
     * &lt;li&gt;DATE_PARAMETER : multiple parameter values, ordered list of how to build a date path&lt;/li&gt;
     * &lt;li&gt;OUTPUT_FILE_PREFIX: string to use when generating random filenames, default: TXT&lt;/li&gt;
     * &lt;li&gt;UUID_IN_OUTPUT_FILENAMES: boolean [true]&lt;/li&gt;
     * &lt;li&gt;AUTO_GENERATED_ID_PREFIX: prefix to use for an auto-generated id&lt;/li&gt;
     * &lt;/ul&gt;
     */
    protected void configure(@Nullable final Configurator configG) {
<span class="fc" id="L120">        Configurator actualConfigG = configG;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (actualConfigG == null) {</span>
            try {
<span class="fc" id="L123">                actualConfigG = ConfigUtil.getConfigInfo(DropOffUtil.class);</span>
<span class="nc" id="L124">            } catch (IOException e) {</span>
<span class="nc" id="L125">                logger.error(&quot;Cannot open default config file&quot;, e);</span>
<span class="fc" id="L126">            }</span>
        }

<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (actualConfigG != null) {</span>
<span class="fc" id="L130">            this.placeOutputData = actualConfigG.findStringEntry(&quot;OUTPUT_DATA&quot;, &quot;outputData&quot;);</span>
<span class="fc" id="L131">            this.unixRoot = actualConfigG.findStringEntry(&quot;UNIX_ROOT&quot;, null);</span>
<span class="fc" id="L132">            this.executrix = new Executrix(actualConfigG);</span>
<span class="fc" id="L133">            this.idTokens = actualConfigG.findEntries(&quot;ID_PARAMETER&quot;);</span>
<span class="fc" id="L134">            this.autoGeneratedIdPrefix = actualConfigG.findStringEntry(&quot;AUTO_GENERATED_ID_PREFIX&quot;);</span>

            // truncate the prefix if necessary
<span class="pc bpc" id="L137" title="1 of 4 branches missed.">            if (!StringUtils.isBlank(this.autoGeneratedIdPrefix) &amp;&amp; (this.autoGeneratedIdPrefix.length() &gt; 4)) {</span>
<span class="fc" id="L138">                this.autoGeneratedIdPrefix = this.autoGeneratedIdPrefix.substring(0, 4);</span>
            }
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            if (this.idTokens.isEmpty()) {</span>
<span class="fc" id="L141">                this.idTokens = actualConfigG.findEntries(&quot;ID&quot;);</span>
            }
<span class="fc" id="L143">            this.dateTokens = actualConfigG.findEntries(&quot;DATE_PARAMETER&quot;);</span>
<span class="fc" id="L144">            this.parentParams = actualConfigG.findEntries(&quot;PARENT_PARAM&quot;);</span>


<span class="fc" id="L147">            this.defaultEventDateToNow = actualConfigG.findBooleanEntry(DEFAULT_EVENT_DATE_TO_NOW, this.defaultEventDateToNow);</span>

<span class="fc" id="L149">            this.prefix = actualConfigG.findStringEntry(&quot;OUTPUT_FILE_PREFIX&quot;, prefix);</span>
<span class="fc" id="L150">            this.uuidInOutputFilenames = actualConfigG.findBooleanEntry(&quot;UUID_IN_OUTPUT_FILENAMES&quot;, this.uuidInOutputFilenames);</span>
            // limit the length of the FILEXT param
<span class="fc" id="L152">            this.maxFilextLen = actualConfigG.findIntEntry(&quot;MAX_FILEXT_LEN&quot;, this.maxFilextLen);</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (this.maxFilextLen &lt; 0) {</span>
<span class="nc" id="L154">                this.maxFilextLen = Integer.MAX_VALUE;</span>
            }

        } else {
<span class="nc" id="L158">            logger.debug(&quot;Configuration is null for DropOffUtil, using defaults&quot;);</span>
<span class="nc" id="L159">            this.executrix = new Executrix();</span>
        }
<span class="fc" id="L161">    }</span>

    /**
     * Generate a new random build file name using the configured prefix and strategy
     */
    public String generateBuildFileName() {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (this.uuidInOutputFilenames) {</span>
<span class="fc" id="L168">            return prefix + getDateOrdinalWithTime(Instant.now()) + UUID.randomUUID();</span>
        } else {
            // Using some constants plus yyyyJJJhhmmss plus random digit, letter, digit
<span class="nc" id="L171">            return prefix + getDateOrdinalWithTime(Instant.now()) + prng.nextInt(10) + ALPHABET[prng.nextInt(ALPHABET.length)] + prng.nextInt(10);</span>
        }
    }

    /**
     * Drop off often needs to make way for a file it wants to write Do so and return the name of the file that can now be
     * written
     */
    public String makeWayForIncomingFile(final IBaseDataObject ibdo, final String suffix) {
<span class="nc" id="L180">        return makeWayForIncomingFile(ibdo, suffix, null);</span>
    }

    @Nullable
    public String makeWayForIncomingFile(final IBaseDataObject ibdo, final String suffix, @Nullable final String spec) {
        // Construct output file from DropOff output path and IBaseDataObject filename
<span class="nc" id="L186">        final String outputFile = getShortOutputFileName(ibdo, spec);</span>

        // Return value when finally set
<span class="nc" id="L189">        final String fileName = outputFile + suffix;</span>

        // Set up path and make it writable
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (!setupPath(fileName)) {</span>
<span class="nc" id="L193">            return null;</span>
        }

<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (removeExistingFile(fileName)) {</span>
<span class="nc" id="L197">            return fileName;</span>
        }

<span class="nc" id="L200">        return null;</span>
    }

    /**
     * Remove a file if it exists
     */
    public boolean removeExistingFile(final String fileName) {
        // If a file already exists under this name, we're going
        // to have to move it aside. This is going to break the link
        // if it is an attachment to another parent document.
<span class="fc" id="L210">        final Path theFile = Paths.get(fileName);</span>
        try {
<span class="fc" id="L212">            Files.deleteIfExists(theFile);</span>
<span class="nc" id="L213">        } catch (IOException e) {</span>
<span class="nc" id="L214">            logger.error(&quot;Trouble removing file: {}&quot;, theFile, e);</span>
<span class="fc" id="L215">        }</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        return !Files.exists(theFile);</span>
    }

    /**
     * mkdir -p to a path and make sure it is writable
     *
     * @param fileName the file name, including directory and filename parts
     * @return true iff it works
     */
    public boolean setupPath(final String fileName) {
<span class="fc" id="L226">        final String pathName = fileName.substring(0, fileName.lastIndexOf(SEPARATOR));</span>
<span class="fc" id="L227">        final Path thePath = Paths.get(pathName);</span>

        // If the specified output directory doesn't exist try creating it
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (!Files.exists(thePath)) {</span>
<span class="fc" id="L231">            int tryCount = 1;</span>
            do {
                try {
<span class="fc" id="L234">                    Files.createDirectories(thePath);</span>
<span class="nc" id="L235">                } catch (IOException e) {</span>
<span class="nc" id="L236">                    logger.warn(&quot;Trouble setting up directories:{}&quot;, thePath, e);</span>
<span class="fc" id="L237">                }</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                if (!Files.exists(thePath)) {</span>
                    try {
<span class="nc" id="L240">                        Thread.sleep(50L * tryCount);</span>
<span class="nc" id="L241">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L242">                        Thread.currentThread().interrupt();</span>
<span class="nc" id="L243">                    }</span>
                }
<span class="fc" id="L245">                tryCount++;</span>
<span class="pc bpc" id="L246" title="3 of 4 branches missed.">            } while (!Files.exists(thePath) &amp;&amp; tryCount &lt;= 10);</span>

<span class="pc bpc" id="L248" title="1 of 2 branches missed.">            if (!Files.exists(thePath)) {</span>
<span class="nc" id="L249">                logger.warn(&quot;Cannot create directory for output: {} in {} attempts&quot;, thePath, tryCount);</span>
<span class="nc" id="L250">                return false;</span>
            }

<span class="pc bpc" id="L253" title="3 of 4 branches missed.">            if (tryCount &gt; 2 &amp;&amp; logger.isDebugEnabled()) {</span>
<span class="nc" id="L254">                logger.debug(&quot;Output path created for {} but it took {} attempts&quot;, thePath, tryCount);</span>
            }
        }

        // If the specified output directory doesn't have write permission try to fix it
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (!Files.isWritable(thePath)) {</span>
<span class="nc" id="L260">            logger.warn(&quot;No write permission for {}, setting it now&quot;, pathName);</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">            if (!thePath.toFile().setWritable(true) || !Files.isWritable(thePath)) {</span>
<span class="nc" id="L262">                logger.warn(&quot;Cannot write to directory for output: {}&quot;, thePath);</span>
<span class="nc" id="L263">                return false;</span>
            }
        }

<span class="fc" id="L267">        return true;</span>
    }

    public String getOutputDirectory() {
<span class="nc" id="L271">        return this.placeOutputData;</span>
    }

    /**
     * Create a path name from the spec for the specified spec using d as the TLD if d is a TLD, null otherwise
     *
     * @param spec the spec to fill in
     * @param d the payload to pull values from
     * @see #getPathFromSpec(String,IBaseDataObject,IBaseDataObject)
     */
    public String getPathFromSpec(final String spec, final IBaseDataObject d) {
        // pass self as tld if tld, null if not
<span class="nc bnc" id="L283" title="All 4 branches missed.">        return getPathFromSpec(spec, d, (d != null &amp;&amp; !d.shortName().contains(Family.SEP)) ? d : null);</span>
    }

    /**
     * Create a path name from the spec for the specified spec Specs understand the following 'language' of replacement
     * stuff. Anything not understood is a literal
     *
     * &lt;pre&gt;
     * &lt;code&gt;@TLD{'KEY'}&lt;/code&gt; is to pull the named KEY from the top level document Metadata
     * &lt;code&gt;@META{'KEY'}&lt;/code&gt; is to pull the named KEY from the MetaData
     * %U% = USER
     * %I% = INPUT_FILE_NAME (whole thing)
     * %S% = INPUT_FILE SHORT NAME
     * %P% = INPUT_FILE PATH (all but short name)
     * %i% = INPUT_FILE_NAME with slashes converted to underscores
     * %p% = INPUT_FILE PATH with slashes converted to underscores
     * %F% = FILETYPE
     * %L% = LANGUAGE
     * %G% = DTG multi directory layout yyyy-mm-dd/hh/mi(div)10
     * %R% = ROOT (Unix or Win depending on OS)
     * %B% = ID for the payload depending on type (no -att-)
     * %b% = ID for the payload depending on type (with -att-)
     * %Y% = Four digit year
     * %M% = Two digit month
     * %D% = Two digit day of month
     * %J% = Three digit ordinal day of the year
     * &lt;/pre&gt;
     *
     * @param specArg the incoming specification
     * @param d the payload we are making a path for
     * @param tld the top level document in the d family, possibly null
     * @return string path name with correct separators for this OS
     */
    public String getPathFromSpec(final String specArg, @Nullable final IBaseDataObject d, @Nullable final IBaseDataObject tld) {
<span class="fc" id="L317">        final StringBuilder sb = new StringBuilder(128);</span>

        // Provide a default spec, just like the old days...
<span class="fc" id="L320">        String spec = specArg;</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (spec == null) {</span>
<span class="nc" id="L322">            spec = &quot;%R%/@TLD{'TARGETBIN'}/%S%&quot;;</span>
        }

<span class="fc bfc" id="L325" title="All 2 branches covered.">        for (int i = 0; i &lt; spec.length(); i++) {</span>
<span class="fc" id="L326">            final char c = spec.charAt(i);</span>

<span class="pc bpc" id="L328" title="1 of 4 branches missed.">            if (c == '%' &amp;&amp; i &lt; spec.length() - 2) {</span>
<span class="fc" id="L329">                final char t = spec.charAt(i + 1);</span>
<span class="fc" id="L330">                final char x = spec.charAt(i + 2);</span>

<span class="pc bpc" id="L332" title="1 of 2 branches missed.">                if (x == c) {</span>
<span class="pc bpc" id="L333" title="14 of 17 branches missed.">                    switch (t) {</span>
                        case 'U':
<span class="nc bnc" id="L335" title="All 2 branches missed.">                            if (tld != null) {</span>
<span class="nc" id="L336">                                sb.append(nvl(tld.getParameter(&quot;UserName&quot;), &quot;no-userid&quot;));</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                            } else if (d != null) {</span>
<span class="nc" id="L338">                                sb.append(nvl(d.getParameter(&quot;UserName&quot;), &quot;no-userid&quot;));</span>
                            }
                            break;
                        case 'S':
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">                            if (d != null) {</span>
<span class="fc" id="L343">                                sb.append(d.shortName());</span>
                            }
                            break;
                        case 'I':
<span class="nc bnc" id="L347" title="All 2 branches missed.">                            if (d != null) {</span>
<span class="nc" id="L348">                                sb.append(d.getFilename());</span>
                            }
                            break;
                        case 'i':
<span class="nc bnc" id="L352" title="All 2 branches missed.">                            if (d != null) {</span>
<span class="nc" id="L353">                                sb.append(d.getFilename().replaceAll(&quot;[/\\\\]&quot;, &quot;_&quot;));</span>
                            }
                            break;
                        case 'P':
<span class="nc bnc" id="L357" title="All 2 branches missed.">                            if (d != null) {</span>
<span class="nc" id="L358">                                sb.append(d.getFilename(), 0, d.getFilename().length() - d.shortName().length());</span>
                            }
                            break;
                        case 'p':
<span class="nc bnc" id="L362" title="All 2 branches missed.">                            if (d != null) {</span>
<span class="nc" id="L363">                                sb.append(d.getFilename().substring(0, d.getFilename().length() - d.shortName().length()).replaceAll(&quot;[/\\\\]&quot;, &quot;_&quot;));</span>
                            }
                            break;
                        case 'F':
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                            if (d != null) {</span>
<span class="fc" id="L368">                                sb.append(nvl(cleanSpecPath(d.getFileType()), &quot;NONE&quot;));</span>
                            }
                            break;
                        case 'L':
<span class="nc bnc" id="L372" title="All 2 branches missed.">                            if (d != null) {</span>
<span class="nc" id="L373">                                sb.append(nvl(d.getParameter(&quot;LANGUAGE&quot;), &quot;NONE&quot;));</span>
                            }
                            break;
                        case 'G':
<span class="nc bnc" id="L377" title="All 2 branches missed.">                            if (tld != null) {</span>
<span class="nc" id="L378">                                sb.append(datePath(cleanSpecPath(tld.getStringParameter(&quot;DTG&quot;))));</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                            } else if (d != null) {</span>
<span class="nc" id="L380">                                sb.append(datePath(cleanSpecPath(d.getStringParameter(&quot;DTG&quot;))));</span>
                            }
                            break;
                        case 'R':
<span class="fc" id="L384">                            sb.append(getRootPath());</span>
<span class="fc" id="L385">                            break;</span>
                        case 'B':
<span class="nc bnc" id="L387" title="All 2 branches missed.">                            if (tld != null) {</span>
<span class="nc" id="L388">                                sb.append(cleanSpecPath(getBestIdFrom(tld)));</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                            } else if (d != null) {</span>
<span class="nc" id="L390">                                sb.append(cleanSpecPath(getBestIdFrom(d)));</span>
                            }
                            break;
                        case 'b':
<span class="nc bnc" id="L394" title="All 2 branches missed.">                            sb.append(cleanSpecPath((tld != null) ? getBestIdFrom(tld) : getBestIdFrom(d)));</span>
<span class="nc" id="L395">                            final String sn = d.shortName();</span>
<span class="nc" id="L396">                            final int pos = sn.indexOf(Family.SEP);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                            if (pos &gt; 0) {</span>
<span class="nc" id="L398">                                sb.append(sn.substring(pos));</span>
                            }
                            break;
                        case 'Y':
<span class="nc" id="L402">                            sb.append(TimeUtil.getDate(&quot;yyyy&quot;, &quot;GMT&quot;));</span>
<span class="nc" id="L403">                            break;</span>
                        case 'M':
<span class="nc" id="L405">                            sb.append(TimeUtil.getDate(&quot;MM&quot;, &quot;GMT&quot;));</span>
<span class="nc" id="L406">                            break;</span>
                        case 'D':
<span class="nc" id="L408">                            sb.append(TimeUtil.getDate(&quot;dd&quot;, &quot;GMT&quot;));</span>
<span class="nc" id="L409">                            break;</span>
                        case 'J':
<span class="nc" id="L411">                            sb.append(TimeUtil.getDate(&quot;DDD&quot;, &quot;GMT&quot;));</span>
<span class="nc" id="L412">                            break;</span>
                        default:
<span class="nc" id="L414">                            sb.append(c).append(t).append(x);</span>
                    }
<span class="fc" id="L416">                    i += 2; // SUPPRESS CHECKSTYLE ModifiedControlVariable</span>
                } else {
                    // No trailing % after character
<span class="nc" id="L419">                    sb.append(c);</span>
                }

<span class="pc bpc" id="L422" title="9 of 10 branches missed.">            } else if (c == '@' &amp;&amp; i &lt; spec.length() - 8 &amp;&amp; spec.charAt(i + 1) == 'M' &amp;&amp; spec.charAt(i + 2) == 'E' &amp;&amp; spec.charAt(i + 3) == 'T'</span>
<span class="nc bnc" id="L423" title="All 6 branches missed.">                    &amp;&amp; spec.charAt(i + 4) == 'A' &amp;&amp; spec.charAt(i + 5) == '{' &amp;&amp; spec.charAt(i + 6) == '\'') {</span>

<span class="nc" id="L425">                final int endpos = spec.indexOf(&quot;'&quot;, i + 7);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                if (endpos &gt; i + 7) {</span>
<span class="nc" id="L427">                    final String token = spec.substring(i + 7, endpos);</span>
<span class="nc" id="L428">                    final String value = cleanSpecPath(d.getStringParameter(token));</span>
<span class="nc" id="L429">                    sb.append(nvl(value, &quot;NO-&quot; + token));</span>
<span class="nc" id="L430">                    i += 8 + token.length(); // META{'token'} SUPPRESS CHECKSTYLE ModifiedControlVariable</span>
<span class="nc" id="L431">                } else {</span>
<span class="nc" id="L432">                    sb.append(c);</span>
                }
<span class="pc bpc" id="L434" title="9 of 10 branches missed.">            } else if (c == '@' &amp;&amp; i &lt; spec.length() - 7 &amp;&amp; spec.charAt(i + 1) == 'T' &amp;&amp; spec.charAt(i + 2) == 'L' &amp;&amp; spec.charAt(i + 3) == 'D'</span>
<span class="nc bnc" id="L435" title="All 6 branches missed.">                    &amp;&amp; spec.charAt(i + 4) == '{' &amp;&amp; spec.charAt(i + 5) == '\'' &amp;&amp; tld != null) {</span>
<span class="nc" id="L436">                final int endpos = spec.indexOf(&quot;'&quot;, i + 6);</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                if (endpos &gt; i + 6) {</span>
<span class="nc" id="L438">                    final String token = spec.substring(i + 6, endpos);</span>
<span class="nc" id="L439">                    final String value = cleanSpecPath(tld.getStringParameter(token));</span>
<span class="nc" id="L440">                    sb.append(nvl(value, &quot;NO-&quot; + token));</span>
<span class="nc" id="L441">                    i += 7 + token.length(); // TLD{'token'} SUPPRESS CHECKSTYLE ModifiedControlVariable</span>
<span class="nc" id="L442">                } else {</span>
<span class="nc" id="L443">                    sb.append(c);</span>
                }
<span class="nc" id="L445">            } else {</span>
<span class="fc" id="L446">                sb.append(c);</span>
            }

        }

<span class="fc" id="L451">        String answer = sb.toString();</span>

        // Set the proper path separator
<span class="fc" id="L454">        answer = answer.replace('\\', '/');</span>
<span class="fc" id="L455">        answer = answer.replaceAll(&quot;\\.([/\\\\])&quot;, &quot;_$1&quot;);</span>

<span class="fc" id="L457">        return answer;</span>
    }

    @Nullable
    protected String cleanSpecPath(@Nullable String token) {
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        return token == null ? null : token.replaceAll(&quot;[.]+&quot;, &quot;.&quot;);</span>
    }

    /**
     * Extract the ID from the payload. The ID from the payload is specified in the cfg file. An ID = SHORTNAME will use the
     * shortname. An ID = AUTO_GENERATED_ID will use an auto gen uuid. If no id value is found, defaults to using an auto
     * generated id.
     *
     * @return id
     */
    public String getBestIdFrom(final IBaseDataObject d) {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        for (final String s : this.idTokens) {</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">            if (!StringUtils.isBlank(d.getStringParameter(s))) {</span>
<span class="fc" id="L475">                return d.getStringParameter(s);</span>
            }
<span class="fc bfc" id="L477" title="All 2 branches covered.">            if (SHORTNAME.equals(s)) {</span>
<span class="fc" id="L478">                final String shortName = d.shortName();</span>
                // if shortname is not blank use it, if blank move on...
<span class="fc bfc" id="L480" title="All 2 branches covered.">                if (!StringUtils.isBlank(shortName)) {</span>
<span class="fc" id="L481">                    return shortName;</span>
                }
            }
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (AUTO_GENERATED_ID.equals(s)) {</span>
<span class="fc" id="L485">                return getRandomUuid(d);</span>
            }
<span class="fc" id="L487">        }</span>
        // if nothing else worked, use an auto gen id
<span class="fc" id="L489">        return getRandomUuid(d);</span>
    }

    /**
     * Extract the ID from the payload. The ID from the payload is specified in the cfg file. An ID = SHORTNAME will use the
     * shortname. An ID = AUTO_GENERATED_ID will be ignored. If no id value is found, returns empty array.
     *
     * @return id
     * @deprecated use {@link #getExistingIdsList(IBaseDataObject)}
     */
    @Deprecated
    @SuppressWarnings(&quot;AvoidObjectArrays&quot;)
    public String[] getExistingIds(final IBaseDataObject d) {
<span class="fc" id="L502">        return getExistingIdsList(d).toArray(new String[0]);</span>
    }

    /**
     * Extract the ID from the payload. The ID from the payload is specified in the cfg file. An ID = SHORTNAME will use the
     * shortname. An ID = AUTO_GENERATED_ID will be ignored. If no id value is found, returns empty list.
     *
     * @return a list of id values
     */
    public List&lt;String&gt; getExistingIdsList(final IBaseDataObject d) {
<span class="fc" id="L512">        final List&lt;String&gt; values = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        for (final String s : this.idTokens) {</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">            if (!StringUtils.isBlank(d.getStringParameter(s))) {</span>
<span class="fc" id="L515">                values.add(d.getStringParameter(s));</span>
            }
<span class="fc bfc" id="L517" title="All 2 branches covered.">            if (SHORTNAME.equals(s)) {</span>
<span class="fc" id="L518">                final String shortName = d.shortName();</span>
                // if shortname is not blank use it, if blank move on...
<span class="fc bfc" id="L520" title="All 2 branches covered.">                if (!StringUtils.isBlank(shortName)) {</span>
<span class="fc" id="L521">                    values.add(shortName);</span>
                }
            }
<span class="fc" id="L524">        }</span>
<span class="fc" id="L525">        return values;</span>
    }

    public String getRootPath() {
<span class="fc" id="L529">        return this.unixRoot;</span>
    }

    public String getSubDirName(final IBaseDataObject d) {
<span class="nc" id="L533">        return getSubDirName(d, null, null);</span>
    }

    public String getSubDirName(final IBaseDataObject d, @Nullable final String spec, @Nullable final IBaseDataObject tld) {
<span class="fc" id="L537">        String fileName = null;</span>

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(spec)) {</span>
<span class="nc" id="L540">            fileName = getPathFromSpec(spec, d);</span>
        }

<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(fileName)) {</span>
<span class="nc" id="L544">            logger.debug(&quot;usingPathFromSpec instead of TARGETBIN: {}&quot;, fileName);</span>
<span class="nc" id="L545">            return fileName;</span>
<span class="pc bpc" id="L546" title="2 of 4 branches missed.">        } else if (tld != null &amp;&amp; tld.getStringParameter(TARGETBIN) != null) {</span>
<span class="nc" id="L547">            logger.debug(&quot;TARGETBIN is {}&quot;, tld.getParameter(TARGETBIN));</span>
<span class="nc" id="L548">            return fixFileNameSeparators(tld.getStringParameter(TARGETBIN));</span>
        } else {
<span class="fc" id="L550">            logger.debug(&quot;TARGETBIN is null&quot;);</span>
<span class="fc" id="L551">            return &quot;NO-CASE&quot; + SEPARATOR + TimeUtil.getCurrentDate();</span>
        }
    }

    public String getRelativeShortOutputFileName(final IBaseDataObject d) {
<span class="nc" id="L556">        return getRelativeShortOutputFileName(d, null);</span>
    }

    public String getRelativeShortOutputFileName(final IBaseDataObject d, @Nullable final String spec) {
<span class="nc bnc" id="L560" title="All 2 branches missed.">        return getRelativeShortOutputFileName(d, spec, !d.shortName().contains(Family.SEP) ? d : null);</span>
    }

    public String getRelativeShortOutputFileName(final IBaseDataObject d, final String spec, @Nullable final IBaseDataObject tld) {
<span class="nc" id="L564">        final String sdir = getSubDirName(d, spec, tld);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (&quot;&quot;.equals(sdir)) {</span>
<span class="nc" id="L566">            return SEPARATOR + d.shortName();</span>
        } else {
<span class="nc" id="L568">            return SEPARATOR + sdir + SEPARATOR + d.shortName();</span>
        }
    }

    public String getShortOutputFileName(final IBaseDataObject d) {
<span class="nc" id="L573">        return getShortOutputFileName(d, null);</span>
    }

    public String getShortOutputFileName(final IBaseDataObject d, @Nullable final String spec) {
<span class="nc bnc" id="L577" title="All 2 branches missed.">        return getShortOutputFileName(d, spec, !d.shortName().contains(Family.SEP) ? d : null);</span>
    }

    public String getShortOutputFileName(final IBaseDataObject d, final String spec, @Nullable final IBaseDataObject tld) {
<span class="nc" id="L581">        return getRelativeShortOutputFileName(d, spec, tld);</span>
    }

    /**
     * Replace any file separators that are not for this platform with the correct one
     */
    public String fixFileNameSeparators(final String s) {
        // other platform;
        String badfs;

<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (&quot;/&quot;.equals(SEPARATOR)) {</span>
<span class="nc" id="L592">            badfs = &quot;\\&quot;;</span>
        } else {
<span class="nc" id="L594">            badfs = &quot;/&quot;;</span>
        }

<span class="nc" id="L597">        final StringBuilder ret = new StringBuilder(s.length());</span>

<span class="nc bnc" id="L599" title="All 2 branches missed.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (s.charAt(i) == badfs.charAt(0)) {</span>
<span class="nc" id="L601">                ret.append(SEPARATOR);</span>
            } else {
<span class="nc" id="L603">                ret.append(s.charAt(i));</span>
            }
        }

<span class="nc" id="L607">        return ret.toString();</span>
    }

    protected Object nvl(@Nullable final Object a, final Object b) {
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        if (a != null) {</span>
<span class="fc" id="L612">            return a;</span>
        }
<span class="nc" id="L614">        return b;</span>
    }

    /**
     * Format string to date path (yyyy-mm-dd/hh/(mm%10))
     *
     * @param dtg expected format yyyymmddhhmmss
     * @return yyyy-mm-dd/hh/(mm%10)
     */
    protected String datePath(@Nullable final String dtg) {
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (dtg == null) {</span>
<span class="nc" id="L625">            return TimeUtil.getDateAsPath(Instant.now());</span>
        } else {
<span class="nc" id="L627">            return dtg.substring(0, 4) + &quot;-&quot; + // yyyy</span>
<span class="nc" id="L628">                    dtg.substring(4, 6) + &quot;-&quot; + // mm</span>
<span class="nc" id="L629">                    dtg.substring(6, 8) + &quot;/&quot; + // dd</span>
<span class="nc" id="L630">                    dtg.substring(8, 10) + &quot;/&quot; + // HH</span>
<span class="nc" id="L631">                    dtg.substring(10, 11) + &quot;0&quot;; // M0</span>
        }
    }

    /**
     * Make a dot file name from the supplied path Ex: /path/to/file.txt --&amp;gt; /path/to/.file.txt
     *
     * @param fullName the full path and filename of the file
     * @return the path as is but with a leading dot in the filename
     */
    public String makeDotFile(final String fullName) {
<span class="nc" id="L642">        final int fpos = fullName.lastIndexOf(&quot;/&quot;);</span>
<span class="nc" id="L643">        final int rpos = fullName.lastIndexOf(&quot;\\&quot;);</span>
<span class="nc bnc" id="L644" title="All 4 branches missed.">        if (fpos == -1 &amp;&amp; rpos == -1) {</span>
<span class="nc" id="L645">            return &quot;.&quot; + fullName;</span>
        }
<span class="nc" id="L647">        final int pos = Math.max(fpos, rpos);</span>
<span class="nc" id="L648">        return fullName.substring(0, pos + 1) + &quot;.&quot; + fullName.substring(pos + 1);</span>
    }

    /**
     * Get the file type from the metadata or the form string passed in
     *
     * @param bdo IBaseDataObject
     * @return the file type
     */
    public static String getFileType(final IBaseDataObject bdo) {
<span class="fc" id="L658">        return getAndPutFileType(bdo, null, null);</span>
    }

    /**
     * Get the file type from the IBaseDataObject or the form string passed in
     *
     * @param bdo IBaseDataObject
     * @param metaData Optional map of metadata that might be modified.
     * @param formsArg Optional space separated string of current forms
     * @return the file type
     */
    public static String getAndPutFileType(final IBaseDataObject bdo, @Nullable final Map&lt;String, String&gt; metaData, @Nullable final String formsArg) {
<span class="fc" id="L670">        String forms = formsArg;</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">        if (forms == null) {</span>
<span class="fc" id="L672">            forms = bdo.getStringParameter(FileTypeCheckParameter.POPPED_FORMS.getFieldName());</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (forms == null) {</span>
<span class="fc" id="L674">                forms = &quot;&quot;;</span>
            }
        }

        String fileType;
<span class="fc bfc" id="L679" title="All 2 branches covered.">        if (bdo.hasParameter(FileTypeCheckParameter.FILETYPE.getFieldName())) {</span>
<span class="fc" id="L680">            fileType = bdo.getStringParameter(FileTypeCheckParameter.FILETYPE.getFieldName());</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        } else if (bdo.hasParameter(FileTypeCheckParameter.FINAL_ID.getFieldName())) {</span>
<span class="fc" id="L682">            fileType = bdo.getStringParameter(FileTypeCheckParameter.FINAL_ID.getFieldName());</span>
<span class="fc" id="L683">            logger.debug(&quot;FINAL_ID FileType is ({})&quot;, fileType);</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            if (metaData != null) {</span>
<span class="fc" id="L685">                metaData.put(FileTypeCheckParameter.FILETYPE.getFieldName(), fileType);</span>
            }
        } else {
<span class="fc bfc" id="L688" title="All 2 branches covered.">            if (forms.contains(&quot; &quot;)) {</span>
<span class="fc" id="L689">                fileType = forms.substring(0, forms.indexOf(&quot; &quot;)).trim();</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                if (metaData != null) {</span>
<span class="fc" id="L691">                    metaData.put(FileTypeCheckParameter.COMPLETE_FILETYPE.getFieldName(), forms);</span>
                }
            } else {
<span class="fc" id="L694">                fileType = forms;</span>
            }
<span class="fc bfc" id="L696" title="All 2 branches covered.">            if (StringUtils.isEmpty(fileType)) {</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">                if (bdo.hasParameter(FileTypeCheckParameter.FONT_ENCODING.getFieldName())) {</span>
<span class="fc" id="L698">                    fileType = TEXT;</span>
                } else {
<span class="fc" id="L700">                    fileType = UNKNOWN;</span>
                }
            }

<span class="fc bfc" id="L704" title="All 2 branches covered.">            if (metaData != null) {</span>
<span class="fc" id="L705">                metaData.put(FileTypeCheckParameter.FILETYPE.getFieldName(), fileType);</span>
            }
        }

<span class="fc bfc" id="L709" title="All 4 branches covered.">        if (UNKNOWN.equals(fileType) &amp;&amp; forms.contains(&quot;MSWORD&quot;)) {</span>
<span class="fc" id="L710">            fileType = &quot;MSWORD_FRAGMENT&quot;;</span>
        }

<span class="pc bpc" id="L713" title="2 of 6 branches missed.">        if (&quot;QUOTED-PRINTABLE&quot;.equals(fileType) || fileType.startsWith(PREFIXES_LANG) || fileType.startsWith(&quot;ENCODING(&quot;)) {</span>
<span class="fc" id="L714">            fileType = TEXT;</span>
        }

<span class="fc" id="L717">        return fileType;</span>
    }

    /**
     * Parameters that are used to determine filetype in {@link #getAndPutFileType(IBaseDataObject, Map, String)}
     */
<span class="fc" id="L723">    public enum FileTypeCheckParameter {</span>
<span class="fc" id="L724">        COMPLETE_FILETYPE(&quot;COMPLETE_FILETYPE&quot;), FILETYPE(&quot;FILETYPE&quot;), FINAL_ID(&quot;FINAL_ID&quot;), FONT_ENCODING(&quot;FontEncoding&quot;), POPPED_FORMS(</span>
                &quot;POPPED_FORMS&quot;);

        final String fieldName;

<span class="fc" id="L729">        FileTypeCheckParameter(String fieldName) {</span>
<span class="fc" id="L730">            this.fieldName = fieldName;</span>
<span class="fc" id="L731">        }</span>

        public String getFieldName() {
<span class="fc" id="L734">            return fieldName;</span>
        }
    }

    /**
     * Extract the ID from the payload. The ID from the payload is specified in the cfg file. An ID = SHORTNAME will use the
     * shortname. An ID = AUTO_GENERATED_ID will use an auto gen uuid. If no id value is found, defaults to using an auto
     * generated id.
     *
     * @param d the payload
     * @param tld if a param is specified and cannot be found in the d method parameter, tries to get param from tld.
     * @return the id based the best ID available, shortname or auto gen id. If no id is found, defaults to auto gen.
     */
    public String getBestId(final IBaseDataObject d, @Nullable final IBaseDataObject tld) {

<span class="fc bfc" id="L749" title="All 2 branches covered.">        for (final String s : this.idTokens) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (AUTO_GENERATED_ID.equals(s)) {</span>
<span class="fc" id="L751">                String parentAutoGeneratedId = null;</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                if (tld != null) {</span>
<span class="fc" id="L753">                    parentAutoGeneratedId = tld.getStringParameter(PARENT_AUTO_GENERATED_ID);</span>
                }
<span class="fc bfc" id="L755" title="All 2 branches covered.">                if (StringUtils.isBlank(parentAutoGeneratedId)) {</span>
<span class="fc" id="L756">                    String uuid = getRandomUuid(d);</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">                    if (tld != null) {</span>
<span class="fc" id="L758">                        tld.setParameter(PARENT_AUTO_GENERATED_ID, uuid);</span>
                    }
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">                    if (!StringUtils.isBlank(uuid)) {</span>
<span class="fc" id="L761">                        final String component = d.shortName();</span>
<span class="fc" id="L762">                        final int pos = component.indexOf(Family.SEP);</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                        if (pos &gt; -1) {</span>
<span class="nc" id="L764">                            uuid += component.substring(pos);</span>
                        }
<span class="fc" id="L766">                        return uuid;</span>
                    }
                }
<span class="fc" id="L769">                String uuid = null;</span>
                // try getting param from the tld
<span class="pc bpc" id="L771" title="2 of 4 branches missed.">                if (!StringUtils.isBlank(parentAutoGeneratedId) &amp;&amp; (tld != null)) {</span>
<span class="fc" id="L772">                    uuid = tld.getStringParameter(PARENT_AUTO_GENERATED_ID);</span>
                }
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">                if (!StringUtils.isBlank(uuid)) {</span>
<span class="fc" id="L775">                    final String component = d.shortName();</span>
<span class="fc" id="L776">                    final int pos = component.indexOf(Family.SEP);</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">                    if (pos &gt; -1) {</span>
<span class="nc" id="L778">                        uuid += component.substring(pos);</span>
                    }
<span class="fc" id="L780">                    d.setParameter(AUTO_GENERATED_ID, &quot;yes&quot;);</span>
<span class="fc" id="L781">                    return uuid;</span>
                }

            }

<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (SHORTNAME.equals(s)) {</span>
<span class="fc" id="L787">                final String shortName = d.shortName();</span>

                // if shortname is not blank use it, if blank move on...
<span class="fc bfc" id="L790" title="All 2 branches covered.">                if (!StringUtils.isBlank(shortName)) {</span>
<span class="fc" id="L791">                    return shortName;</span>
                }

<span class="fc" id="L794">                String path = d.getStringParameter(s);</span>
                // try getting shortname from the tld
<span class="pc bpc" id="L796" title="2 of 4 branches missed.">                if (StringUtils.isBlank(path) &amp;&amp; (tld != null)) {</span>
<span class="fc" id="L797">                    path = tld.getStringParameter(s);</span>
                }
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">                if (!StringUtils.isBlank(path)) {</span>
<span class="nc" id="L800">                    final String component = d.shortName();</span>
<span class="nc" id="L801">                    final int pos = component.indexOf(Family.SEP);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">                    if (pos &gt; -1) {</span>
<span class="nc" id="L803">                        path += component.substring(pos);</span>
                    }
<span class="nc" id="L805">                    return path;</span>
                }

            }
            // the param from the tld has priority over any child
<span class="pc bpc" id="L810" title="2 of 4 branches missed.">            if ((tld != null) &amp;&amp; !StringUtils.isBlank(tld.getStringParameter(s))) {</span>
<span class="nc" id="L811">                String path = tld.getStringParameter(s);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">                if (!StringUtils.isBlank(path)) {</span>
<span class="nc" id="L813">                    final String component = d.shortName();</span>
<span class="nc" id="L814">                    final int pos = component.indexOf(Family.SEP);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                    if (pos &gt; -1) {</span>
<span class="nc" id="L816">                        path += component.substring(pos);</span>
                    }
<span class="nc" id="L818">                    return path;</span>
                }
            }
            // if the param is not in the tld
<span class="fc bfc" id="L822" title="All 2 branches covered.">            if (!StringUtils.isBlank(d.getStringParameter(s))) {</span>
<span class="fc" id="L823">                return d.getStringParameter(s);</span>
            }

<span class="fc" id="L826">        }</span>

        // if nothing works, auto gen an id
<span class="fc" id="L829">        final String uuid = getRandomUuid(d);</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        if (tld != null) {</span>
<span class="fc" id="L831">            tld.setParameter(PARENT_AUTO_GENERATED_ID, uuid);</span>
        }
<span class="fc" id="L833">        return uuid;</span>
    }

    /**
     * Creates a UUID. Includes a prefix if specified.
     *
     * @param d Adds a parameter indicating an auto gen id.
     * @return uuid
     */
    private String getRandomUuid(final IBaseDataObject d) {
<span class="fc" id="L843">        String uuid = UUID.randomUUID().toString();</span>
        // use the prefix
<span class="fc bfc" id="L845" title="All 2 branches covered.">        if (!StringUtils.isBlank(this.autoGeneratedIdPrefix)) {</span>
<span class="fc" id="L846">            uuid = uuid.substring(this.autoGeneratedIdPrefix.length());</span>
<span class="fc" id="L847">            uuid = this.autoGeneratedIdPrefix + uuid;</span>
        }
<span class="fc" id="L849">        d.setParameter(PARENT_AUTO_GENERATED_ID, uuid);</span>
<span class="fc" id="L850">        d.setParameter(AUTO_GENERATED_ID, &quot;yes&quot;);</span>
<span class="fc" id="L851">        return uuid;</span>
    }

    /**
     * Extract language or a default value
     *
     * @param d the payload
     * @return the language or the default value (never null)
     */
    public String getLanguage(final IBaseDataObject d) {
<span class="fc" id="L861">        String lang = d.getStringParameter(&quot;LANGUAGE&quot;);</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (lang == null) {</span>
<span class="fc" id="L863">            lang = &quot;NONE&quot;;</span>
        }
<span class="fc" id="L865">        return lang;</span>
    }

    /**
     * Handle data
     *
     * @param d the data object in question
     * @return the Date when the event occurred
     */
    public Date getEventDate(final IBaseDataObject d, @Nullable final IBaseDataObject tld) {
<span class="fc" id="L875">        Date eventDate = extractEventDateFrom(d, false);</span>
<span class="pc bpc" id="L876" title="1 of 4 branches missed.">        if (eventDate == null &amp;&amp; tld != null) {</span>
<span class="fc" id="L877">            eventDate = extractEventDateFrom(tld, this.defaultEventDateToNow);</span>
        }
<span class="fc" id="L879">        return eventDate;</span>
    }

    @Nullable
    public Date extractEventDateFrom(final IBaseDataObject d, final boolean lastResortDefault) {
<span class="fc bfc" id="L884" title="All 2 branches covered.">        for (final String paramName : this.dateTokens) {</span>
<span class="fc" id="L885">            final String value = d.getStringParameter(paramName);</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">            if (value != null) {</span>
                try {
<span class="fc" id="L888">                    ZonedDateTime zdt = FlexibleDateTimeParser.parse(value, DATE_ISO_8601);</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">                    if (zdt == null) {</span>
<span class="nc" id="L890">                        logger.debug(&quot;FlexibleDateTimeParser returned null trying to parse EventDate&quot;);</span>
                    } else {
<span class="fc" id="L892">                        return Date.from(zdt.toInstant());</span>
                    }
<span class="nc" id="L894">                } catch (DateTimeParseException ex) {</span>
<span class="nc" id="L895">                    logger.debug(&quot;Cannot parse EventDate&quot;, ex);</span>
<span class="nc" id="L896">                }</span>
            }
<span class="fc" id="L898">        }</span>

        // Default to current system time if last resort
<span class="fc bfc" id="L901" title="All 2 branches covered.">        return lastResortDefault ? Date.from(Instant.now()) : null;</span>
    }

    /**
     * Utilizes the static methods getFullFilepathsFromParams and getFileExtensions to extract the file extensions from all
     * the filenames of the object of a given {@link IBaseDataObject}. If one or more file extensions are extracted, the
     * IBaseDataObject's FILEXT parameter is set as the unique set of extracted file extensions, converted to lowercase.
     *
     * @param p IBaseDataObject to process
     *
     */
    void extractUniqueFileExtensions(IBaseDataObject p) {
<span class="fc" id="L913">        List&lt;String&gt; filenames = getFullFilepathsFromParams(p);</span>
<span class="fc" id="L914">        Set&lt;String&gt; extensions = getFileExtensions(filenames, this.maxFilextLen);</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if (!extensions.isEmpty()) {</span>
<span class="fc" id="L916">            p.setParameter(FILEXT, extensions);</span>
        }
<span class="fc" id="L918">    }</span>

    /**
     * Given a list of filenames, extract and return a set of non-blank file extensions converted to lowercase.
     *
     * @param filenames The list of filenames to examine
     * @param maxFilextLen The maximum size we want a file extension to be
     * @return A set of unique file extensions from the filename list
     */
    public static Set&lt;String&gt; getFileExtensions(List&lt;String&gt; filenames, int maxFilextLen) {
<span class="fc" id="L928">        final Set&lt;String&gt; extensions = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        for (String filename : filenames) {</span>

            // add the file extension if it is smaller than maxFilextLen
<span class="fc" id="L932">            final String fext = FilenameUtils.getExtension(filename);</span>
<span class="fc bfc" id="L933" title="All 4 branches covered.">            if (StringUtils.isNotBlank(fext) &amp;&amp; fext.length() &lt;= maxFilextLen) {</span>
<span class="fc" id="L934">                extensions.add(fext.toLowerCase(Locale.getDefault()));</span>
            }
<span class="fc" id="L936">        }</span>
<span class="fc" id="L937">        return extensions;</span>
    }

    /**
     * Checks the Original-Filename and FILE_ABSOLUTEPATH for the filename of the object. Returns a list with the non-empty
     * strings found in these fields. If nothing is found in either field, return an empty list.
     *
     * @param d The IBDO
     * @return The list of filenames found in the field Original-Filename or FILE_ABSOLUTEPATH
     */
    public static List&lt;String&gt; getFullFilepathsFromParams(IBaseDataObject d) {
<span class="fc" id="L948">        return getFullFilepathsFromParams(d, new String[] {ORIGINAL_FILENAME, FILE_ABSOLUTEPATH});</span>
    }

    /**
     * Uses the specified list of fields to check for filenames of the object. Returns a list with the non-empty strings
     * found in these fields. If nothing is found in either field, return an empty list.
     *
     * @param d The IBDO
     * @param filenameFields The list of fields on the IBDO to check
     * @return The list of filenames found in the list of fields on the IBDO
     * @deprecated use {@link #getFullFilepathsFromParams(IBaseDataObject, List)}
     */
    @Deprecated
    @SuppressWarnings(&quot;AvoidObjectArrays&quot;)
    public static List&lt;String&gt; getFullFilepathsFromParams(IBaseDataObject d, String[] filenameFields) {
<span class="fc" id="L963">        return getFullFilepathsFromParams(d, Arrays.asList(filenameFields));</span>
    }

    /**
     * Uses the specified list of fields to check for filenames of the object. Returns a list with the non-empty strings
     * found in these fields. If nothing is found in either field, return an empty list.
     *
     * @param d The IBDO
     * @param filenameFields The list of fields on the IBDO to check
     * @return The list of filenames found in the list of fields on the IBDO
     */
    public static List&lt;String&gt; getFullFilepathsFromParams(IBaseDataObject d, List&lt;String&gt; filenameFields) {

<span class="fc" id="L976">        List&lt;String&gt; filenames = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L978" title="All 2 branches covered.">        for (String ibdoField : filenameFields) {</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">            if (d.hasParameter(ibdoField)) {</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">                for (Object filename : d.getParameter(ibdoField)) {</span>
<span class="fc" id="L981">                    String stringFileName = (String) filename;</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">                    if (StringUtils.isNotBlank(stringFileName)) {</span>
<span class="fc" id="L983">                        filenames.add(stringFileName);</span>
                    }
<span class="fc" id="L985">                }</span>
            }
<span class="fc" id="L987">        }</span>
<span class="fc" id="L988">        return filenames;</span>
    }

    /**
     * Process metadata before doing any output
     *
     * @param payloadList list of items being dropped off that may need initial metadata computations
     */
    public void processMetadata(final List&lt;IBaseDataObject&gt; payloadList) {

        // Keep track of parent's filetype to output; relies on the attachments being sorted
<span class="fc" id="L999">        final Map&lt;String, String&gt; parentTypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1000">        final IBaseDataObject tld = payloadList.get(0);</span>
<span class="fc" id="L1001">        final List&lt;String&gt; extendedFileTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1002">        parentTypes.put(&quot;1&quot;, tld.getFileType());</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        for (int i = 0; i &lt; parentParams.size(); i++) {</span>
<span class="fc" id="L1004">            final String param = parentParams.get(i);</span>
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">            if (tld.hasParameter(param)) {</span>
<span class="fc" id="L1006">                parentTypes.put(&quot;1&quot; + param, tld.getStringParameter(param));</span>
            }
        }

<span class="fc bfc" id="L1010" title="All 2 branches covered.">        for (final IBaseDataObject p : payloadList) {</span>
<span class="fc" id="L1011">            final int level = StringUtils.countMatches(p.shortName(), Family.SEP) + 1;</span>
            // save specified metadata items for children to grab
<span class="fc" id="L1013">            parentTypes.put(&quot;&quot; + level, p.getFileType());</span>

<span class="fc" id="L1015">            extractUniqueFileExtensions(p);</span>

<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">            if (p.getStringParameter(EXTENDED_FILETYPE) == null) {</span>
<span class="fc" id="L1018">                extendedFileTypes.clear();</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">                for (final Map.Entry&lt;String, Collection&lt;Object&gt;&gt; entry : p.getParameters().entrySet()) {</span>
<span class="fc" id="L1020">                    final String key = entry.getKey();</span>
<span class="pc bpc" id="L1021" title="1 of 4 branches missed.">                    if (key != null &amp;&amp; key.endsWith(&quot;_FILETYPE&quot;)) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                        for (final Object value : entry.getValue()) {</span>
<span class="fc" id="L1023">                            final String vs = value.toString();</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">                            if (!extendedFileTypes.contains(vs)) {</span>
<span class="fc" id="L1025">                                extendedFileTypes.add(vs);</span>
                            }
<span class="fc" id="L1027">                        }</span>
                    }
<span class="fc" id="L1029">                }</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">                if (!extendedFileTypes.isEmpty()) {</span>
<span class="fc" id="L1031">                    final StringBuilder extft = new StringBuilder(getFileType(p));</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">                    for (int j = 0; j &lt; extendedFileTypes.size(); j++) {</span>
<span class="fc" id="L1033">                        final String s = extendedFileTypes.get(j);</span>
<span class="fc" id="L1034">                        extft.append(&quot;//&quot;).append(s);</span>
                    }
<span class="fc" id="L1036">                    p.setParameter(EXTENDED_FILETYPE, extft.toString());</span>
                }
            }

<span class="fc bfc" id="L1040" title="All 2 branches covered.">            for (int j = 0; j &lt; parentParams.size(); j++) {</span>
<span class="fc" id="L1041">                final String param = parentParams.get(j);</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">                if (p.hasParameter(param)) {</span>
<span class="fc" id="L1043">                    parentTypes.put(&quot;&quot; + level + param, p.getStringParameter(param));</span>
                } else {
                    // Must clear to keep my children from getting their uncle's value
<span class="fc" id="L1046">                    parentTypes.remove(&quot;&quot; + level + param);</span>
                }

            }

<span class="fc bfc" id="L1051" title="All 2 branches covered.">            if (level &gt; 1) {</span>
                // then it might want some PARENT info

<span class="fc" id="L1054">                final int parentLevel = level - 1;</span>
<span class="fc" id="L1055">                final String pType = parentTypes.get(&quot;&quot; + parentLevel);</span>
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">                if (StringUtils.isNotEmpty(pType)) {</span>
<span class="fc" id="L1057">                    p.setParameter(PARENT_FILETYPE, pType);</span>
                } else {
<span class="nc" id="L1059">                    p.setParameter(PARENT_FILETYPE, parentTypes.get(&quot;1&quot;));</span>
                }
<span class="fc bfc" id="L1061" title="All 2 branches covered.">                for (int j = 0; j &lt; parentParams.size(); j++) {</span>
<span class="fc" id="L1062">                    final String param = parentParams.get(j);</span>
<span class="fc" id="L1063">                    int plvl = parentLevel;</span>
<span class="pc bpc" id="L1064" title="1 of 4 branches missed.">                    while (plvl &gt; 1 &amp;&amp; !parentTypes.containsKey(&quot;&quot; + plvl + param)) {</span>
<span class="fc" id="L1065">                        plvl--;</span>
                    }
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">                    if (StringUtils.isNotBlank(parentTypes.get(plvl + param))) {</span>
<span class="fc" id="L1068">                        p.setParameter(&quot;PARENT_&quot; + param, parentTypes.get(plvl + param));</span>
                    }
                }
            }

<span class="fc bfc" id="L1073" title="All 2 branches covered.">            if (p.hasExtractedRecords()) {</span>
<span class="fc" id="L1074">                final List&lt;IBaseDataObject&gt; childObjList = p.getExtractedRecords();</span>
<span class="fc" id="L1075">                childObjList.sort(new ShortNameComparator());</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">                for (final IBaseDataObject child : childObjList) {</span>
<span class="fc" id="L1077">                    final int parentLevel = StringUtils.countMatches(child.shortName(), Family.SEP);</span>
<span class="fc" id="L1078">                    final String parentFileType = parentTypes.get(&quot;&quot; + parentLevel);</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">                    if (parentFileType != null) {</span>
<span class="fc" id="L1080">                        child.setParameter(PARENT_FILETYPE, parentFileType);</span>
                    }
<span class="fc bfc" id="L1082" title="All 2 branches covered.">                    for (int k = 0; k &lt; parentParams.size(); k++) {</span>
<span class="fc" id="L1083">                        final String param = parentParams.get(k);</span>
<span class="fc" id="L1084">                        int plvl = parentLevel;</span>
<span class="fc bfc" id="L1085" title="All 4 branches covered.">                        while (plvl &gt; 1 &amp;&amp; !parentTypes.containsKey(&quot;&quot; + plvl + param)) {</span>
<span class="fc" id="L1086">                            plvl--;</span>
                        }
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">                        if (StringUtils.isNotBlank(parentTypes.get(plvl + param))) {</span>
<span class="fc" id="L1089">                            child.setParameter(&quot;PARENT_&quot; + param, parentTypes.get(plvl + param));</span>
                        }
                    }
<span class="fc" id="L1092">                }</span>
            }
<span class="fc" id="L1094">        }</span>
<span class="fc" id="L1095">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>