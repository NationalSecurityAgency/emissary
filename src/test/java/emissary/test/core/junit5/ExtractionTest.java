package emissary.test.core.junit5;

import emissary.core.DataObjectFactory;
import emissary.core.Family;
import emissary.core.IBaseDataObject;
import emissary.core.IBaseDataObjectXmlCodecs;
import emissary.core.IBaseDataObjectXmlHelper;
import emissary.core.channels.FileChannelFactory;
import emissary.core.channels.SeekableByteChannelFactory;
import emissary.kff.KffDataObjectHandler;
import emissary.place.IServiceProviderPlace;
import emissary.test.core.junit5.LogbackTester.SimplifiedLogEvent;
import emissary.util.ByteUtil;
import emissary.util.io.ResourceReader;
import emissary.util.os.OSReleaseUtil;
import emissary.util.xml.JDOMUtil;

import com.google.errorprone.annotations.ForOverride;
import jakarta.annotation.Nullable;
import jakarta.xml.bind.DatatypeConverter;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.jdom2.Attribute;
import org.jdom2.DataConversionException;
import org.jdom2.Document;
import org.jdom2.Element;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

import static emissary.core.IBaseDataObjectXmlCodecs.DEFAULT_ELEMENT_DECODERS;
import static emissary.core.IBaseDataObjectXmlCodecs.LENGTH_ATTRIBUTE_NAME;
import static emissary.core.IBaseDataObjectXmlCodecs.SHA256_ELEMENT_ENCODERS;
import static emissary.core.constants.IbdoXmlElementNames.ANSWERS;
import static emissary.core.constants.IbdoXmlElementNames.ATTACHMENT_ELEMENT_PREFIX;
import static emissary.core.constants.IbdoXmlElementNames.BAD_ALT_VIEW;
import static emissary.core.constants.IbdoXmlElementNames.BROKEN;
import static emissary.core.constants.IbdoXmlElementNames.CLASSIFICATION;
import static emissary.core.constants.IbdoXmlElementNames.CURRENT_FORM;
import static emissary.core.constants.IbdoXmlElementNames.DATA;
import static emissary.core.constants.IbdoXmlElementNames.EXTRACTED_RECORD_ELEMENT_PREFIX;
import static emissary.core.constants.IbdoXmlElementNames.FILE_TYPE;
import static emissary.core.constants.IbdoXmlElementNames.FONT_ENCODING;
import static emissary.core.constants.IbdoXmlElementNames.INDEX;
import static emissary.core.constants.IbdoXmlElementNames.INITIAL_FORM;
import static emissary.core.constants.IbdoXmlElementNames.INPUT_ALT_VIEW;
import static emissary.core.constants.IbdoXmlElementNames.NAME;
import static emissary.core.constants.IbdoXmlElementNames.PARAMETER;
import static emissary.core.constants.IbdoXmlElementNames.SETUP;
import static emissary.core.constants.IbdoXmlElementNames.VALUE;
import static emissary.core.constants.IbdoXmlElementNames.VIEW;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

public abstract class ExtractionTest extends UnitTest {

    protected static final Logger logger = LoggerFactory.getLogger(ExtractionTest.class);

    private static final List<IBaseDataObject> NO_ATTACHMENTS = Collections.emptyList();
    private static final byte[] INCORRECT_VIEW_MESSAGE = "This is the incorrect view, the place should not have processed this view".getBytes();

    private AnswerGenerator answerGenerator;

    /**
     * The list of actual logEvents generated by executing the place.
     */
    protected List<SimplifiedLogEvent> actualSimplifiedLogEvents;

    protected KffDataObjectHandler kff =
            new KffDataObjectHandler(KffDataObjectHandler.TRUNCATE_KNOWN_DATA, KffDataObjectHandler.SET_FORM_WHEN_KNOWN,
                    KffDataObjectHandler.SET_FILE_TYPE);
    @Nullable
    protected IServiceProviderPlace place = null;
    @Nullable
    private static final String SYSTEM_OS_RELEASE;
    @Nullable
    private static final String MAJOR_OS_VERSION;

    static {
        if (OSReleaseUtil.isUbuntu()) {
            SYSTEM_OS_RELEASE = "ubuntu";
            MAJOR_OS_VERSION = OSReleaseUtil.getMajorReleaseVersion();
        } else if (OSReleaseUtil.isCentOs()) {
            SYSTEM_OS_RELEASE = "centos";
            MAJOR_OS_VERSION = OSReleaseUtil.getMajorReleaseVersion();
        } else if (OSReleaseUtil.isRhel()) {
            SYSTEM_OS_RELEASE = "rhel";
            MAJOR_OS_VERSION = OSReleaseUtil.getMajorReleaseVersion();
        } else if (OSReleaseUtil.isMac()) {
            SYSTEM_OS_RELEASE = "mac";
            MAJOR_OS_VERSION = OSReleaseUtil.getMajorReleaseVersion();
        } else {
            SYSTEM_OS_RELEASE = null;
            MAJOR_OS_VERSION = null;
        }
    }

    /**
     * Override this or set the generateAnswers system property to true to generate XML for data files.
     *
     * @return defaults to false if no XML should be generated (i.e. normal case of executing tests) or true to generate
     *         automatically
     */
    protected boolean generateAnswers() {
        return Boolean.getBoolean("generateAnswers");
    }

    protected AnswerGenerator createAnswerGenerator() {
        return null; // TODO :: create answer generator
    }

    protected AnswerGenerator getAnswerGenerator() {
        if (answerGenerator == null) {
            answerGenerator = createAnswerGenerator();
        }
        return answerGenerator;
    }

    /**
     * This method returns the XML element decoders.
     *
     * @return the XML element decoders.
     */
    @Deprecated
    protected IBaseDataObjectXmlCodecs.ElementDecoders getDecoders() {
        return DEFAULT_ELEMENT_DECODERS;
    }

    /**
     * This method returns the XML element decoders.
     *
     * @param resource the "resource" currently be tested.
     * @return the XML element decoders.
     */
    protected IBaseDataObjectXmlCodecs.ElementDecoders getDecoders(final String resource) {
        return getDecoders();
    }

    /**
     * This method returns the XML element encoders.
     *
     * @return the XML element encoders.
     */
    @Deprecated
    protected IBaseDataObjectXmlCodecs.ElementEncoders getEncoders() {
        return SHA256_ELEMENT_ENCODERS;
    }

    /**
     * This method returns the XML element encoders.
     *
     * @param resource the "resource" currently be tested.
     * @return the XML element encoders.
     */
    protected IBaseDataObjectXmlCodecs.ElementEncoders getEncoders(final String resource) {
        return getEncoders();
    }

    @BeforeEach
    public void setUpPlace() throws Exception {
        place = createPlace();
    }

    @AfterEach
    public void tearDownPlace() {
        if (place != null) {
            place.shutDown();
            place = null;
        }
    }

    /**
     * Derived classes must implement this
     */
    public abstract IServiceProviderPlace createPlace() throws IOException;

    public static Stream<? extends Arguments> data() {
        return getMyTestParameterFiles(ExtractionTest.class);
    }

    /**
     * Allow overriding the initial form in extensions to this test.
     *
     * By default, get the initial form from the filename in the form {@code INITIAL_FORM@2.dat} where {@code INITIAL_FORM}
     * will be the initial form.
     *
     * @param resource to get the form from
     * @return the initial form
     */
    @ForOverride
    protected String getInitialForm(final String resource) {
        return resource.replaceAll("^.*/([^/@]+)(@\\d+)?\\.dat$", "$1");
    }

    /**
     * Allow the initial IBDO to be overridden - for example, adding additional previous forms
     * <p>
     * This is used in the simple case to generate an IBDO from the file on disk and override the filename
     *
     * @param resource path to the dat file
     * @return the initial IBDO
     */
    @Nullable
    protected IBaseDataObject getInitialIbdo(final String resource) {
        IBaseDataObject ibdo = new ClearDataBaseDataObject();
        try {
            final Path datFileUrl = Paths.get(new ResourceReader().getResource(resource).toURI());
            final InitialFinalFormFormat datFile = new InitialFinalFormFormat(datFileUrl);
            final SeekableByteChannelFactory sbcf = FileChannelFactory.create(datFile.getPath());
            // Create a BDO for the data, and set the filename correctly
            final IBaseDataObject initialIbdo = IBaseDataObjectXmlHelper.createStandardInitialIbdo(ibdo, sbcf, "Classification",
                    datFile.getInitialForm(), kff);
            initialIbdo.setChannelFactory(sbcf);
            initialIbdo.setFilename(datFile.getOriginalFileName());

            return initialIbdo;
        } catch (final URISyntaxException e) {
            fail("Couldn't get path for resource: " + resource, e);
            return null;
        }
    }

    /**
     * This method returns the logger name to capture log events from or null if log events are not to be checked.
     *
     * @return the logger name to capture log events from or null (the default) if log events are not to be checked.
     */
    protected String getLogbackLoggerName() {
        return null;
    }

    @ParameterizedTest
    @MethodSource("data")
    public void testExtractionPlace(String resource) {
        logger.debug("Running {} test on resource {}", place.getClass().getName(), resource);

        // Need a pair consisting of a .dat file and a .xml file (answers)
        Document controlDoc = getAnswerDocumentFor(resource);
        if (controlDoc == null) {
            fail("No answers provided for test " + resource);
        }

        try (InputStream doc = new ResourceReader().getResourceAsStream(resource)) {
            byte[] data = IOUtils.toByteArray(doc);
            String initialForm = getInitialForm(resource);
            IBaseDataObject payload = DataObjectFactory.getInstance(data, resource, initialForm);
            setupPayload(payload, controlDoc);
            processPreHook(payload, controlDoc);
            List<IBaseDataObject> attachments = processHeavyDutyHook(place, payload);
            processPostHook(payload, attachments);
            checkAnswersPreHook(controlDoc, payload, attachments, resource);
            checkAnswers(controlDoc, payload, attachments, resource);
            checkAnswersPostHook(controlDoc, payload, attachments, resource);
        } catch (Exception ex) {
            logger.error("Error running test {}", resource, ex);
            fail("Cannot run test " + resource, ex);
        }
    }

    protected void processPreHook(IBaseDataObject payload, Document controlDoc) {
        // Nothing to do here
    }

    protected void processPostHook(IBaseDataObject payload, List<IBaseDataObject> attachments) {
        // Nothing to do here
    }

    protected List<IBaseDataObject> processHeavyDutyHook(IServiceProviderPlace place, IBaseDataObject payload) throws Exception {
        if (getLogbackLoggerName() == null) {
            actualSimplifiedLogEvents = new ArrayList<>();
            return place.agentProcessHeavyDuty(payload);
        } else {
            try (LogbackTester logbackTester = new LogbackTester(getLogbackLoggerName())) {
                final List<IBaseDataObject> attachments = place.agentProcessHeavyDuty(payload);
                actualSimplifiedLogEvents = logbackTester.getSimplifiedLogEvents();
                return attachments;
            }
        }
    }

    protected void checkAnswersPreHook(Document answers, IBaseDataObject payload, List<IBaseDataObject> attachments, String tname) {
        // Nothing to do here
    }

    protected void checkAnswersPreHook(Element answers, IBaseDataObject payload, IBaseDataObject attachment, String tname) {
        // Nothing to do here
    }

    /**
     * Generates a SHA 256 hash of the provided bytes if they contain any non-printable characters
     *
     * @param bytes the bytes to evaluate
     * @param alwaysHash overrides the non-printable check and always hashes the bytes.
     * @return a value optionally containing the generated hash
     */
    protected Optional<String> hashBytesIfNonPrintable(byte[] bytes, final boolean alwaysHash) {
        if (ArrayUtils.isNotEmpty(bytes) && (alwaysHash || ByteUtil.containsNonIndexableBytes(bytes))) {
            return Optional.ofNullable(ByteUtil.sha256Bytes(bytes));
        }

        return Optional.empty();
    }

    /**
     * This method allows log events to be modified prior to checkAnswers being called.
     *
     * In the default case, do nothing.
     *
     * @param simplifiedLogEvents the log events to be tweaked.
     */
    protected void checkAnswersPreHookLogEvents(List<SimplifiedLogEvent> simplifiedLogEvents) {
        // No-op unless overridden
    }

    protected void checkAnswersPostHook(Document answers, IBaseDataObject payload, List<IBaseDataObject> attachments, String tname) {
        // Nothing to do here
    }

    protected void checkAnswersPostHook(Element answers, IBaseDataObject payload, IBaseDataObject attachment, String tname) {
        // Nothing to do here
    }

    protected void checkAnswers(Document answers, IBaseDataObject payload, List<IBaseDataObject> attachments, String tname)
            throws DataConversionException {
        Element root = answers.getRootElement();
        Element parent = root.getChild(ANSWERS);
        if (parent == null) {
            parent = root;
        }

        // Check the payload
        checkAnswers(parent, payload, attachments, tname);

        // Check each attachment
        for (int attNum = 1; attNum <= attachments.size(); attNum++) {
            String atname = tname + Family.SEP + attNum;
            Element el = getChildAnswers(parent, ATTACHMENT_ELEMENT_PREFIX, attNum);
            if (el != null) {
                checkAnswersPreHook(el, payload, attachments.get(attNum - 1), atname);
                checkAnswers(el, attachments.get(attNum - 1), null, atname);
                checkAnswersPostHook(el, payload, attachments.get(attNum - 1), atname);
            }
        }
    }

    protected void checkAnswers(Element el, IBaseDataObject payload, @Nullable List<IBaseDataObject> attachments, String tname)
            throws DataConversionException {

        int numAtt = -1;
        long numAttElements = 0;
        boolean osSpecificNumAtt = false;
        List<Element> numAttachments = el.getChildren("numAttachments");
        for (Element numAttEl : numAttachments) {
            if (verifyOs(numAttEl)) {
                numAtt = Integer.parseInt(numAttEl.getValue());
                numAttElements = el.getChildren().stream().filter(
                        c -> c.getName().startsWith(ATTACHMENT_ELEMENT_PREFIX) && verifyOs(c)).count();
                // see if os specific numAttachments for check against payload
                if (numAttEl.getAttribute("os-release") != null) {
                    osSpecificNumAtt = true;
                }
                break;
            }
        }

        // check attachments answer file count against payload count
        if (!osSpecificNumAtt) {
            if (numAtt > -1) {
                assertEquals(numAtt, attachments != null ? attachments.size() : 0,
                        String.format("Expected <numAttachments> in %s not equal to number of att in payload.", tname));
            } else if (numAtt == -1 && numAttElements > 0) {
                assertEquals(numAttElements, attachments != null ? attachments.size() : 0,
                        String.format("Expected <att#> in %s not equal to number of att in payload.", tname));
            } else {
                if (attachments != null && !attachments.isEmpty()) {
                    fail(String.format("%d attachments in payload with no count in answer xml, add matching <numAttachments> count for %s",
                            attachments.size(), tname));
                }
            }
        } else {
            int attInPayload = attachments != null ? attachments.size() : 0;
            assertTrue(numAtt <= attInPayload, String.format(
                    "Expected <numAttachments> in %s for specific OS not less than or equal to number of att in payload. ==> expected: <%d> but was: <%d>",
                    tname, numAtt, attInPayload));
            assertTrue(numAttElements <= attInPayload, String.format(
                    "Expected <att#> in %s for specific OS not less than or equal to number of att in payload. ==> expected: <%d> but was: <%d>",
                    tname, numAttElements, attInPayload));
            if (numAtt == -1) {
                assertEquals(0, numAttElements,
                        String.format("OS Specific <numAttachments> & <att#> in %s are not equal. ==> <numAttachments>:<%d> <att#>:<%d>", tname, 0,
                                numAttElements));
            } else {
                assertEquals(numAtt, numAttElements,
                        String.format("OS Specific <numAttachments> & <att#> in %s are not equal. ==> <numAttachments>:<%d> <att#>:<%d>", tname,
                                numAtt, numAttElements));
            }
        }

        for (Element currentForm : el.getChildren(CURRENT_FORM)) {
            String cf = currentForm.getTextTrim();
            if (cf != null) {
                Attribute index = currentForm.getAttribute(INDEX);
                if (index != null) {
                    assertEquals(payload.currentFormAt(index.getIntValue()), cf,
                            String.format("Current form '%s' not found at position [%d] in %s, %s", cf, index.getIntValue(), tname,
                                    payload.getAllCurrentForms()));
                } else {
                    assertTrue(payload.searchCurrentForm(cf) > -1,
                            String.format("Current form %s not found in %s, %s", cf, tname, payload.getAllCurrentForms()));
                }
            }
        }

        String cf = el.getChildTextTrim(CURRENT_FORM);
        if (cf != null) {
            assertTrue(payload.searchCurrentForm(cf) > -1,
                    String.format("Current form '%s' not found in %s, %s", cf, tname, payload.getAllCurrentForms()));
        }

        String ft = el.getChildTextTrim("fileType");
        if (ft != null) {
            assertEquals(ft, payload.getFileType(), String.format("Expected File Type '%s' in %s", ft, tname));
        }

        int cfsize = JDOMUtil.getChildIntValue(el, "currentFormSize");
        if (cfsize > -1) {
            assertEquals(cfsize, payload.currentFormSize(), "Current form size in " + tname);
        }

        String classification = el.getChildTextTrim(CLASSIFICATION);
        if (classification != null) {
            assertEquals(classification, payload.getClassification(),
                    String.format("Classification in '%s' is '%s', not expected '%s'", tname, payload.getClassification(), classification));
        }

        for (Element dataLength : el.getChildren("dataLength")) {
            if (verifyOs(dataLength)) {
                int length;
                try {
                    length = Integer.parseInt(dataLength.getValue());
                } catch (NumberFormatException e) {
                    length = -1;
                }
                if (length > -1) {
                    assertEquals(length, payload.dataLength(), "Data length in " + tname);
                }
            }
        }

        String shortName = el.getChildTextTrim("shortName");
        if (shortName != null && shortName.length() > 0) {
            assertEquals(shortName, payload.shortName(), "Shortname does not match expected in " + tname);
        }

        String fontEncoding = el.getChildTextTrim(FONT_ENCODING);
        if (StringUtils.isNotBlank(fontEncoding)) {
            assertEquals(fontEncoding, payload.getFontEncoding(), "Font encoding does not match expected in " + tname);
        }

        String broke = el.getChildTextTrim(BROKEN);
        if (broke != null && broke.length() > 0) {
            assertEquals(broke, payload.isBroken() ? "true" : "false", "Broken status in " + tname);
        }

        String procError = el.getChildTextTrim("procError");
        if (procError != null && !procError.isEmpty()) {
            assertNotNull(payload.getProcessingError(),
                    String.format("Expected processing error '%s' in %s", procError, tname));
            // simple work around for answer files, so we can see multiple errors w/o dealing with line breaks added on by
            // StringBuilder in BDO
            String shortProcErrMessage = payload.getProcessingError().replaceAll("\n", ";");
            assertEquals(procError, shortProcErrMessage, "Processing Error does not match expected in " + tname);
        }

        // Check specified metadata
        for (Element meta : el.getChildren(PARAMETER)) {
            if (verifyOs(meta)) {
                String key = meta.getChildTextTrim(NAME);
                checkForMissingNameElement(PARAMETER, key, tname);
                checkStringValue(meta, payload.getStringParameter(key), tname);
            }
        }

        // Check specified nometa
        for (Element meta : el.getChildren("nometa")) {
            if (verifyOs(meta)) {
                String key = meta.getChildTextTrim(NAME);
                checkForMissingNameElement("nometa", key, tname);
                assertFalse(payload.hasParameter(key),
                        String.format("Metadata element '%s' in '%s' should not exist, but has value of '%s'", key, tname,
                                payload.getStringParameter(key)));
            }
        }

        // Check the primary view. Even though there is only one
        // primary view there can be multiple elements to test it
        // with differing matchMode operators
        for (Element dataEl : el.getChildren(DATA)) {
            if (verifyOs(dataEl)) {
                byte[] payloadData = payload.data();
                checkStringValue(dataEl, new String(payloadData), tname);
            }
        }

        // Check each alternate view
        for (Element view : el.getChildren(VIEW)) {
            if (verifyOs(view)) {
                String viewName = view.getChildTextTrim(NAME);
                String lengthStr = view.getChildTextTrim(LENGTH_ATTRIBUTE_NAME);
                byte[] viewData = payload.getAlternateView(viewName);
                assertNotNull(viewData, String.format("Alternate View '%s' is missing in %s", viewName, tname));
                if (lengthStr != null) {
                    assertEquals(Integer.parseInt(lengthStr), viewData.length,
                            String.format("Length of Alternate View '%s' is wrong in %s", viewName, tname));
                }
                checkStringValue(view, new String(viewData), tname);
            }
        }

        // Check for noview items
        for (Element view : el.getChildren("noview")) {
            if (verifyOs(view)) {
                String viewName = view.getChildTextTrim(NAME);
                byte[] viewData = payload.getAlternateView(viewName);
                assertNull(viewData, String.format("Alternate View '%s' is present, but should not be, in %s", viewName, tname));
            }
        }

        // Check each extract
        int extractCount = JDOMUtil.getChildIntValue(el, "extractCount");
        long numExtractElements =
                el.getChildren().stream().filter(c -> c.getName().startsWith(EXTRACTED_RECORD_ELEMENT_PREFIX)
                        && !c.getName().startsWith("extractCount")).count();
        if (payload.hasExtractedRecords()) {
            List<IBaseDataObject> extractedChildren = payload.getExtractedRecords();
            int foundCount = extractedChildren.size();
            // check extracted records answer file count against payload count
            if (extractCount > -1) {
                assertEquals(extractCount, foundCount,
                        String.format("Expected <extractCount> in %s not equal to number of extracts in payload.", tname));
            } else if (extractCount == -1 && numExtractElements > 0) {
                assertEquals(numExtractElements, foundCount,
                        String.format("Expected <extract#> in %s not equal to number of extracts in payload.", tname));
            } else {
                fail(String.format("%d extracts in payload with no count in answer xml, add matching <extractCount> count for %s",
                        foundCount, tname));
            }


            for (int attNum = 1; attNum <= extractedChildren.size(); attNum++) {
                Element extel = getChildAnswers(el, EXTRACTED_RECORD_ELEMENT_PREFIX, attNum);
                if (extel != null) {
                    checkAnswers(extel, extractedChildren.get(attNum - 1), NO_ATTACHMENTS, String.format("%s::extract%d", tname, attNum));
                }
            }
        } else {
            if (extractCount > -1) {
                assertEquals(0, extractCount,
                        String.format("No extracted children in '%s' when <extractCount> is %d", tname, extractCount));
            } else if (numExtractElements > 0) {
                assertEquals(0, numExtractElements,
                        String.format("No extracted children in '%s' when <extract#> is %d", tname, numExtractElements));
            }
        }
    }

    private static void checkForMissingNameElement(String parentTag, String key, String tname) {
        if (key == null) {
            fail(String.format("The element %s has a problem in %s: does not have a child name element", parentTag, tname));
        }
    }

    protected void checkStringValue(Element meta, String data, String tname) {
        String key = meta.getChildTextTrim(NAME);
        String value = meta.getChildText(VALUE);
        String matchMode = "equals";
        Attribute mm = meta.getAttribute("matchMode");

        if (value == null) {
            return; // checking the value is optional
        }

        if (mm != null) {
            matchMode = mm.getValue();
        }

        if (matchMode.equals("equals")) {
            assertEquals(value, data,
                    String.format("%s element '%s' problem in %s value '%s' does not equal '%s'", meta.getName(), key, tname, data, value));
        } else if (matchMode.equals(INDEX) || matchMode.equals("contains")) {
            assertTrue(data.contains(value),
                    String.format("%s element '%s' problem in %s value '%s' does not index '%s'", meta.getName(), key, tname, data, value));
        } else if (matchMode.equals("!index") || matchMode.equals("!contains")) {
            assertFalse(data.contains(value),
                    String.format("%s element '%s' problem in %s value '%s' should not be indexed in '%s'", meta.getName(), key, tname, value, data));
        } else if (matchMode.equals("match")) {
            assertTrue(data.matches(value),
                    String.format("%s element '%s' problem in %s value '%s' does not match '%s'", meta.getName(), key, tname, data, value));
        } else if (matchMode.equals("base64")) {
            // decode value as a base64 encoded byte[] array and use the string
            // representation of the byte array for comparison to the incoming value
            value = new String(DatatypeConverter.parseBase64Binary(value));
            assertEquals(value, data,
                    String.format("%s element '%s' problem in %s value '%s' does not match '%s'", meta.getName(), key, tname, data, value));
        } else if ("collection".equalsIgnoreCase(matchMode)) {
            Attribute separatorAttribute = meta.getAttribute("collectionSeparator");
            String separator = null != separatorAttribute ? separatorAttribute.getValue() : ","; // comma is default
            // separator
            List<String> expectedValues = Arrays.asList(value.split(separator));
            List<String> actualValues = Arrays.asList(data.split(separator));
            assertTrue(CollectionUtils.isEqualCollection(expectedValues, actualValues),
                    String.format(
                            "%s element '%s' problem in %s did not have equal collection, value '%s' does not equal '%s' split by separator '%s'",
                            meta.getName(), key, tname, data, value, separator));

        } else {
            fail(String.format("Problematic matchMode specified for test '%s' on %s in element %s", matchMode, key, meta.getName()));
        }
    }

    protected boolean verifyOs(Element element) {
        Attribute specifiedOs = element.getAttribute("os-release");
        Attribute specifiedVersion = element.getAttribute("os-version");
        if (specifiedOs != null) {
            String os = specifiedOs.getValue();
            switch (os) {
                case "ubuntu":
                case "centos":
                case "rhel":
                case "mac":
                    if (specifiedVersion != null) {
                        return os.equals(SYSTEM_OS_RELEASE) && specifiedVersion.getValue().equals(MAJOR_OS_VERSION);
                    } else {
                        // verify os matches, major os version not specified
                        return os.equals(SYSTEM_OS_RELEASE);
                    }
                default:
                    fail("specified OS needs to match ubuntu, centos, rhel, or mac. Provided OS=" + os);
            }
        }
        // os-release is not set as an attribute, element applicable for all os
        return true;
    }

    protected void setupPayload(IBaseDataObject payload, Document doc) {
        kff.hash(payload);
        Element root = doc.getRootElement();
        Element setup = root.getChild(SETUP);
        boolean didSetFiletype = false;
        if (setup != null) {
            List<Element> cfChildren = setup.getChildren(INITIAL_FORM);
            if (!cfChildren.isEmpty()) {
                payload.popCurrentForm(); // remove default
            }

            IBaseDataObjectXmlHelper.ibdoFromXmlMainElements(setup, payload, getDecoders(payload.getFilename()));

            final String fileType = setup.getChildTextTrim(FILE_TYPE);
            if (StringUtils.isNotBlank(fileType)) {
                payload.setFileType(fileType);
                didSetFiletype = true;
            }

            final String inputAlternateView = setup.getChildTextTrim(INPUT_ALT_VIEW);
            if (StringUtils.isNotBlank(inputAlternateView)) {
                final byte[] data = payload.data();
                payload.addAlternateView(inputAlternateView, data);
                payload.setData(INCORRECT_VIEW_MESSAGE);
            }

            final String badAlternateView = setup.getChildTextTrim(BAD_ALT_VIEW);
            if (StringUtils.isNotBlank(badAlternateView)) {
                payload.addAlternateView(badAlternateView, INCORRECT_VIEW_MESSAGE);
            }
        }
        if (!didSetFiletype) {
            payload.setFileType(payload.currentForm());
        }
    }

    protected Element getChildAnswers(Element parent, String name, int index) {
        // look up the new way i.e <att index="1">
        Element el = parent.getChildren().stream()
                .filter(c -> c.getName().equalsIgnoreCase(name) && c.getAttribute(INDEX).getValue().equals(String.valueOf(index)))
                .findFirst()
                .orElse(null);
        if (el == null) {
            // fallback to the old way i.e. <att1>
            el = parent.getChild(name + index);
        }
        return el;
    }
}
