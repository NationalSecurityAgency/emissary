package emissary.test.core.junit5;

import emissary.core.IBaseDataObject;
import emissary.core.IBaseDataObjectXmlCodecs;
import emissary.core.IBaseDataObjectXmlHelper;
import emissary.place.IServiceProviderPlace;
import emissary.util.DisposeHelper;
import emissary.util.io.ResourceReader;

import jakarta.annotation.Nullable;
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.output.Format;
import org.jdom2.output.LineSeparator;
import org.jdom2.output.XMLOutputter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

import static emissary.core.constants.IbdoXmlElementNames.ANSWERS;
import static org.junit.jupiter.api.Assertions.fail;

public abstract class AnswerGenerator {

    protected static final Logger logger = LoggerFactory.getLogger(AnswerGenerator.class);

    /** Open options for (over-)writing answers XML */
    private static final Set<StandardOpenOption> CREATE_WRITE_TRUNCATE = new HashSet<>(Arrays.asList(StandardOpenOption.CREATE,
            StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING));

    /** test/resources folder */
    private static final Path TEST_RESX = getTestResx();

    /**
     * Actually generate the answer file for a given resource
     * <p>
     * Takes initial form and final forms from the filename
     *
     * @param resource to generate against
     */
    public abstract void generateAnswerFiles(String resource, IServiceProviderPlace place, IBaseDataObject initialIbdo,
            IBaseDataObjectXmlCodecs.ElementEncoders encoders, AtomicReference<Class<?>> answerFileClassRef, String logbackLoggerName);

    @Nullable
    public abstract Document getAnswerDocumentFor(String resource, AtomicReference<Class<?>> answerFileClassRef);

    /**
     * Allow the initial IBDO to be overridden before serializing to XML.
     * <p>
     * In the default case, we null out the data in the BDO which will force the data to be loaded from the .dat file
     * instead.
     *
     * @param resource path to the dat file
     * @param initialIbdo to tweak
     */
    protected abstract void tweakInitialIbdoBeforeSerialization(String resource, IBaseDataObject initialIbdo);

    /**
     * Allow the generated IBDO to be overridden - for example, adding certain field values. Will modify the provided IBDO.
     * <p>
     * This is used in the simple case to set the current form for the final object to be taken from the file name. If the
     * test worked correctly no change will be made, but if there is a discrepancy this will be highlighted afterwards when
     * the diff takes place.
     *
     * @param resource path to the dat file
     * @param finalIbdo the existing final BDO after it's been processed by a place
     */
    protected abstract void tweakFinalIbdoBeforeSerialization(String resource, IBaseDataObject finalIbdo);

    /**
     * Allow the children generated by the place to be overridden before serializing to XML.
     * <p>
     * In the default case, do nothing.
     *
     * @param resource path to the dat file
     * @param children to tweak
     */
    protected void tweakFinalResultsBeforeSerialization(final String resource, final List<IBaseDataObject> children) {
        // No-op unless overridden
    }

    /**
     * Allows the log events generated by the place to be modified before serializing to XML.
     * <p>
     * In the default case, do nothing.
     *
     * @param resource path to the dat file
     * @param simplifiedLogEvents to tweak
     */
    protected void tweakFinalLogEventsBeforeSerialization(final String resource, final List<LogbackTester.SimplifiedLogEvent> simplifiedLogEvents) {
        // No-op unless overridden
    }

    /**
     * Dynamically finds the src/test/resources directory to write the XML to.
     * <p>
     * Running locally in an IDE, PROJECT_BASE will likely point to {@code src/main/}
     *
     * Running in Maven/Docker it will most likely point to {@code target/}
     */
    public static Path getTestResx() {
        // Gets us the parent folder to PROJECT_BASE
        Path pathBuilder = Paths.get(System.getenv("PROJECT_BASE"));
        // If in Docker, we need to go into src - we're probably already in it otherwise
        if (pathBuilder.endsWith("main")) { // Docker
            pathBuilder = pathBuilder.getParent();
        } else if (pathBuilder.getFileName().toString().contains("target")) {
            pathBuilder = pathBuilder.getParent().resolve("src");
        }
        // Append test/resources to finish the path off
        return pathBuilder.resolve("test/resources");
    }

    /**
     * Generate the relevant XML and write to disk.
     *
     * @param resource referencing the DAT file
     * @param initialIbdo for 'setup' section
     * @param finalIbdo for 'answers' section
     * @param encoders for encoding ibdo into XML
     * @param results for 'answers' section
     * @param answerFileClassRef answer file class (if different from data class)
     */
    public static void writeAnswerXml(String resource, IBaseDataObject initialIbdo, IBaseDataObject finalIbdo,
            List<IBaseDataObject> results, List<LogbackTester.SimplifiedLogEvent> logEvents, IBaseDataObjectXmlCodecs.ElementEncoders encoders,
            @Nullable AtomicReference<Class<?>> answerFileClassRef) {
        final Element rootElement = IBaseDataObjectXmlHelper.xmlElementFromIbdo(finalIbdo, results, initialIbdo, encoders);
        final Element answerElement = rootElement.getChild(ANSWERS);

        LogbackTester.SimplifiedLogEvent.toXml(logEvents).forEach(answerElement::addContent);

        // Generate the full XML (setup & answers from before & after)
        final byte[] xmlContent = bytesFromDocument(new Document(rootElement));
        // Write out the XML to disk
        writeXml(resource, xmlContent, answerFileClassRef);
    }

    @Nullable
    public static byte[] bytesFromDocument(Document jdom) {
        final Format format = Format.getPrettyFormat().setLineSeparator(LineSeparator.UNIX);
        final XMLOutputter outputter = new XMLOutputter(format);

        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
            outputter.output(jdom, os);
            return os.toByteArray();
        } catch (IOException iox) {
            return null;
        }
    }

    /**
     * Helper method to write XML for a given DAT file.
     *
     * @param resource referencing the DAT file
     * @param xmlContent to write to the XML answer file
     * @param answerFileClassRef answer file class (if different from data class)
     */
    public static void writeXml(String resource, byte[] xmlContent, @Nullable AtomicReference<Class<?>> answerFileClassRef) {
        final Path path = getXmlPath(resource, answerFileClassRef);
        if (path == null) {
            fail(String.format("Could not get path for resource = %s", resource));
        }
        logger.info("Writing answers file to path: {}", path);
        try (FileChannel fc = FileChannel.open(path, CREATE_WRITE_TRUNCATE);
                SeekableInMemoryByteChannel simbc = new SeekableInMemoryByteChannel(xmlContent)) {
            fc.transferFrom(simbc, 0, simbc.size());
        } catch (final IOException ioe) {
            fail(String.format("Couldn't write XML answer file for resource: %s", resource), ioe);
        }
    }

    /**
     * Gets the XML filename/path for the given resource (a .dat file)
     *
     * @param resource path to the .dat file
     * @param answerFileClassRef answer file class (if different from data class)
     * @return path to the corresponding .xml file
     */
    @Nullable
    public static Path getXmlPath(String resource, @Nullable AtomicReference<Class<?>> answerFileClassRef) {
        final int datPos = resource.lastIndexOf(ResourceReader.DATA_SUFFIX);
        if (datPos == -1) {
            logger.debug("Resource is not a DATA file {}", resource);
            return null;
        }

        String xmlPath;
        if (answerFileClassRef == null) {
            xmlPath = resource.substring(0, datPos) + ResourceReader.XML_SUFFIX;
        } else {
            String ansPath = answerFileClassRef.get().getName().replace(".", "/");
            int testNamePos = resource.lastIndexOf("/");
            xmlPath = ansPath + resource.substring(testNamePos, datPos) + ResourceReader.XML_SUFFIX;
        }
        return TEST_RESX.resolve(xmlPath);
    }

    /**
     * Default behavior to fix dispose runnables to change "variant" to "invariant"
     *
     * @param ibdo the base data object containing dispose runnables
     */
    public static void fixDisposeRunnables(IBaseDataObject ibdo) {
        if (ibdo.hasParameter(DisposeHelper.KEY)) {
            final List<Object> values = ibdo.getParameter(DisposeHelper.KEY);
            final List<String> newValues = new ArrayList<>();

            for (Object o : values) {
                newValues.add(o.getClass().getName());
            }

            ibdo.putParameter(DisposeHelper.KEY, newValues);
        }
    }
}
